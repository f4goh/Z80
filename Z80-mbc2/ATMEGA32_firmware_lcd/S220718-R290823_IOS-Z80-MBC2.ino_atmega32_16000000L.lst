
C:\Users\anthony\AppData\Local\Temp\arduino_build_242482/S220718-R290823_IOS-Z80-MBC2.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
       0:	0c 94 1b 04 	jmp	0x836	; 0x836 <__dtors_end>
       4:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
       8:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
       c:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      10:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      14:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      18:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      1c:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      20:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      24:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      28:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      2c:	0c 94 db 14 	jmp	0x29b6	; 0x29b6 <__vector_11>
      30:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      34:	0c 94 a9 14 	jmp	0x2952	; 0x2952 <__vector_13>
      38:	0c 94 83 14 	jmp	0x2906	; 0x2906 <__vector_14>
      3c:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      40:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      44:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      48:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>
      4c:	0c 94 25 15 	jmp	0x2a4a	; 0x2a4a <__vector_19>
      50:	0c 94 43 04 	jmp	0x886	; 0x886 <__bad_interrupt>

00000054 <__trampolines_end>:
__trampolines_start():
      54:	31 10       	cpse	r3, r1
      56:	fd 21       	and	r31, r13
      58:	52 fd       	sbrc	r21, 2
      5a:	cd c6       	rjmp	.+3482   	; 0xdf6 <micros+0x34>
      5c:	fe cd       	rjmp	.-1028   	; 0xfffffc5a <__eeprom_end+0xff7efc5a>
      5e:	3e ff       	.word	0xff3e	; ????
      60:	cd f4       	brhc	.+50     	; 0x94 <__trampolines_end+0x40>
      62:	fd 3e       	cpi	r31, 0xED	; 237
      64:	ff bc       	out	0x2f, r15	; 47
      66:	20 10       	cpse	r2, r0
      68:	bd 20       	and	r11, r13
      6a:	0d 21       	and	r16, r13
      6c:	d9 fd       	.word	0xfdd9	; ????
      6e:	cd c6       	rjmp	.+3482   	; 0xe0a <micros+0x48>
      70:	fe 21       	and	r31, r14
      72:	88 fd       	.word	0xfd88	; ????
      74:	cd c6       	rjmp	.+3482   	; 0xe10 <delay+0x2>
      76:	fe 76       	andi	r31, 0x6E	; 110
      78:	e5 21       	and	r30, r5
      7a:	d9 fd       	.word	0xfdd9	; ????
      7c:	cd c6       	rjmp	.+3482   	; 0xe18 <delay+0xa>
      7e:	fe 21       	and	r31, r14
      80:	75 fd       	sbrc	r23, 5
      82:	cd c6       	rjmp	.+3482   	; 0xe1e <delay+0x10>
      84:	fe e1       	ldi	r31, 0x1E	; 30
      86:	cd 4b       	sbci	r28, 0xBD	; 189
      88:	ff cd       	rjmp	.-1026   	; 0xfffffc88 <__eeprom_end+0xff7efc88>
      8a:	3e ff       	.word	0xff3e	; ????
      8c:	cd 3e       	cpi	r28, 0xED	; 237
      8e:	ff db       	rcall	.-2050   	; 0xfffff88e <__eeprom_end+0xff7ef88e>
      90:	01 fe       	sbrs	r0, 1
      92:	ff 20       	and	r15, r15
      94:	fa e9       	ldi	r31, 0x9A	; 154
      96:	69 4c       	sbci	r22, 0xC9	; 201
      98:	6f 61       	ori	r22, 0x1F	; 31
      9a:	64 20       	and	r6, r4
      9c:	2d 20       	and	r2, r13
      9e:	49 6e       	ori	r20, 0xE9	; 233
      a0:	74 65       	ori	r23, 0x54	; 84
      a2:	6c 2d       	mov	r22, r12
      a4:	48 65       	ori	r20, 0x58	; 88
      a6:	78 20       	and	r7, r8
      a8:	4c 6f       	ori	r20, 0xFC	; 252
      aa:	61 64       	ori	r22, 0x41	; 65
      ac:	65 72       	andi	r22, 0x25	; 37
      ae:	20 2d       	mov	r18, r0
      b0:	20 53       	subi	r18, 0x30	; 48
      b2:	32 30       	cpi	r19, 0x02	; 2
      b4:	30 37       	cpi	r19, 0x70	; 112
      b6:	31 38       	cpi	r19, 0x81	; 129
      b8:	00 53       	subi	r16, 0x30	; 48
      ba:	74 61       	ori	r23, 0x14	; 20
      bc:	72 74       	andi	r23, 0x42	; 66
      be:	69 6e       	ori	r22, 0xE9	; 233
      c0:	67 20       	and	r6, r7
      c2:	41 64       	ori	r20, 0x41	; 65
      c4:	64 72       	andi	r22, 0x24	; 36
      c6:	65 73       	andi	r22, 0x35	; 53
      c8:	73 3a       	cpi	r23, 0xA3	; 163
      ca:	20 00       	.word	0x0020	; ????
      cc:	4c 6f       	ori	r20, 0xFC	; 252
      ce:	61 64       	ori	r22, 0x41	; 65
      d0:	20 65       	ori	r18, 0x50	; 80
      d2:	72 72       	andi	r23, 0x22	; 34
      d4:	6f 72       	andi	r22, 0x2F	; 47
      d6:	20 2d       	mov	r18, r0
      d8:	20 53       	subi	r18, 0x30	; 48
      da:	79 73       	andi	r23, 0x39	; 57
      dc:	74 65       	ori	r23, 0x54	; 84
      de:	6d 20       	and	r6, r13
      e0:	68 61       	ori	r22, 0x18	; 24
      e2:	6c 74       	andi	r22, 0x4C	; 76
      e4:	65 64       	ori	r22, 0x45	; 69
      e6:	00 57       	subi	r16, 0x70	; 112
      e8:	61 69       	ori	r22, 0x91	; 145
      ea:	74 69       	ori	r23, 0x94	; 148
      ec:	6e 67       	ori	r22, 0x7E	; 126
      ee:	20 69       	ori	r18, 0x90	; 144
      f0:	6e 70       	andi	r22, 0x0E	; 14
      f2:	75 74       	andi	r23, 0x45	; 69
      f4:	20 73       	andi	r18, 0x30	; 48
      f6:	74 72       	andi	r23, 0x24	; 36
      f8:	65 61       	ori	r22, 0x15	; 21
      fa:	6d 2e       	mov	r6, r29
      fc:	2e 2e       	mov	r2, r30
      fe:	00 53       	subi	r16, 0x30	; 48
     100:	79 6e       	ori	r23, 0xE9	; 233
     102:	74 61       	ori	r23, 0x14	; 20
     104:	78 20       	and	r7, r8
     106:	65 72       	andi	r22, 0x25	; 37
     108:	72 6f       	ori	r23, 0xF2	; 242
     10a:	72 21       	and	r23, r2
     10c:	00 43       	sbci	r16, 0x30	; 48
     10e:	68 65       	ori	r22, 0x58	; 88
     110:	63 6b       	ori	r22, 0xB3	; 179
     112:	73 75       	andi	r23, 0x53	; 83
     114:	6d 20       	and	r6, r13
     116:	65 72       	andi	r22, 0x25	; 37
     118:	72 6f       	ori	r23, 0xF2	; 242
     11a:	72 21       	and	r23, r2
     11c:	00 69       	ori	r16, 0x90	; 144
     11e:	4c 6f       	ori	r20, 0xFC	; 252
     120:	61 64       	ori	r22, 0x41	; 65
     122:	3a 20       	and	r3, r10
     124:	00 41       	sbci	r16, 0x10	; 16
     126:	64 64       	ori	r22, 0x44	; 68
     128:	72 65       	ori	r23, 0x52	; 82
     12a:	73 73       	andi	r23, 0x33	; 51
     12c:	20 76       	andi	r18, 0x60	; 96
     12e:	69 6f       	ori	r22, 0xF9	; 249
     130:	6c 61       	ori	r22, 0x1C	; 28
     132:	74 69       	ori	r23, 0x94	; 148
     134:	6f 6e       	ori	r22, 0xEF	; 239
     136:	21 00       	.word	0x0021	; ????
     138:	f5 d5       	rcall	.+3050   	; 0xd24 <TwoWire::begin() [clone .constprop.6]+0x44>
     13a:	c5 01       	movw	r24, r10
     13c:	ff ff       	.word	0xffff	; ????
     13e:	21 a3       	std	Z+33, r18	; 0x21
     140:	fd cd       	rjmp	.-1030   	; 0xfffffd3c <__eeprom_end+0xff7efd3c>
     142:	c6 fe       	sbrs	r12, 6
     144:	cd 3e       	cpi	r28, 0xED	; 237
     146:	ff cd       	rjmp	.-1026   	; 0xfffffd46 <__eeprom_end+0xff7efd46>
     148:	72 ff       	sbrs	r23, 2
     14a:	fe 0d       	add	r31, r14
     14c:	28 f9       	.word	0xf928	; ????
     14e:	fe 0a       	sbc	r15, r30
     150:	28 f5       	brcc	.+74     	; 0x19c <__trampolines_end+0x148>
     152:	fe 20       	and	r15, r14
     154:	28 f1       	brcs	.+74     	; 0x1a0 <__trampolines_end+0x14c>
     156:	cd 1a       	sub	r12, r29
     158:	ff cd       	rjmp	.-1026   	; 0xfffffd58 <__eeprom_end+0xff7efd58>
     15a:	69 ff       	.word	0xff69	; ????
     15c:	fe 3a       	cpi	r31, 0xAE	; 174
     15e:	c2 a3       	std	Z+34, r28	; 0x22
     160:	fe cd       	rjmp	.-1028   	; 0xfffffd5e <__eeprom_end+0xff7efd5e>
     162:	e1 fe       	sbrs	r14, 1
     164:	57 1e       	adc	r5, r23
     166:	00 cd       	rjmp	.-1536   	; 0xfffffb68 <__eeprom_end+0xff7efb68>
     168:	be fe       	.word	0xfebe	; ????
     16a:	cd d6       	rcall	.+3482   	; 0xf06 <TwoWire::peek()+0x1a>
     16c:	fe 3e       	cpi	r31, 0xEE	; 238
     16e:	ff b8       	out	0x0f, r15	; 15
     170:	20 05       	cpc	r18, r0
     172:	b9 20       	and	r11, r9
     174:	02 44       	sbci	r16, 0x42	; 66
     176:	4d 7c       	andi	r20, 0xCD	; 205
     178:	cd be       	out	0x3d, r12	; 61
     17a:	fe 7d       	andi	r31, 0xDE	; 222
     17c:	cd be       	out	0x3d, r12	; 61
     17e:	fe cd       	rjmp	.-1028   	; 0xfffffd7c <__eeprom_end+0xff7efd7c>
     180:	e1 fe       	sbrs	r14, 1
     182:	cd be       	out	0x3d, r12	; 61
     184:	fe fe       	.word	0xfefe	; ????
     186:	01 20       	and	r0, r1
     188:	1e cd       	rjmp	.-1476   	; 0xfffffbc6 <__eeprom_end+0xff7efbc6>
     18a:	e1 fe       	sbrs	r14, 1
     18c:	cd be       	out	0x3d, r12	; 61
     18e:	fe 7b       	andi	r31, 0xBE	; 190
     190:	a7 28       	or	r10, r7
     192:	66 cd       	rjmp	.-1332   	; 0xfffffc60 <__eeprom_end+0xff7efc60>
     194:	3e ff       	.word	0xff3e	; ????
     196:	21 d9       	rcall	.-3518   	; 0xfffff3da <__eeprom_end+0xff7ef3da>
     198:	fd cd       	rjmp	.-1030   	; 0xfffffd94 <__eeprom_end+0xff7efd94>
     19a:	c6 fe       	sbrs	r12, 6
     19c:	21 c9       	rjmp	.-3518   	; 0xfffff3e0 <__eeprom_end+0xff7ef3e0>
     19e:	fd cd       	rjmp	.-1030   	; 0xfffffd9a <__eeprom_end+0xff7efd9a>
     1a0:	c6 fe       	sbrs	r12, 6
     1a2:	01 ff       	sbrs	r16, 1
     1a4:	ff 18       	sub	r15, r15
     1a6:	52 7a       	andi	r21, 0xA2	; 162
     1a8:	a7 28       	or	r10, r7
     1aa:	2c cd       	rjmp	.-1448   	; 0xfffffc04 <__eeprom_end+0xff7efc04>
     1ac:	e1 fe       	sbrs	r14, 1
     1ae:	cd be       	out	0x3d, r12	; 61
     1b0:	fe e5       	ldi	r31, 0x5E	; 94
     1b2:	c5 a7       	std	Z+45, r28	; 0x2d
     1b4:	01 f0       	breq	.+0      	; 0x1b6 <__trampolines_end+0x162>
     1b6:	fc ed       	ldi	r31, 0xDC	; 220
     1b8:	42 c1       	rjmp	.+644    	; 0x43e <autoSetRTC()::__c+0x25>
     1ba:	e1 da       	rcall	.-2622   	; 0xfffff77e <__eeprom_end+0xff7ef77e>
     1bc:	8e fe       	.word	0xfe8e	; ????
     1be:	cd 3e       	cpi	r28, 0xED	; 237
     1c0:	ff 21       	and	r31, r15
     1c2:	d9 fd       	.word	0xfdd9	; ????
     1c4:	cd c6       	rjmp	.+3482   	; 0xf60 <TwoWire::write(unsigned char const*, unsigned int)+0x48>
     1c6:	fe 21       	and	r31, r14
     1c8:	e1 fd       	sbrc	r30, 1
     1ca:	cd c6       	rjmp	.+3482   	; 0xf66 <TwoWire::write(unsigned char const*, unsigned int)+0x4e>
     1cc:	fe 01       	movw	r30, r28
     1ce:	ff ff       	.word	0xffff	; ????
     1d0:	18 27       	eor	r17, r24
     1d2:	77 23       	and	r23, r23
     1d4:	15 18       	sub	r1, r5
     1d6:	d0 cd       	rjmp	.-1120   	; 0xfffffd78 <__eeprom_end+0xff7efd78>
     1d8:	e1 fe       	sbrs	r14, 1
     1da:	cd be       	out	0x3d, r12	; 61
     1dc:	fe 7b       	andi	r31, 0xBE	; 190
     1de:	a7 20       	and	r10, r7
     1e0:	b2 cd       	rjmp	.-1180   	; 0xfffffd46 <__eeprom_end+0xff7efd46>
     1e2:	3e ff       	.word	0xff3e	; ????
     1e4:	c3 03       	fmuls	r20, r19
     1e6:	fe cd       	rjmp	.-1028   	; 0xfffffde4 <__eeprom_end+0xff7efde4>
     1e8:	3e ff       	.word	0xff3e	; ????
     1ea:	21 d9       	rcall	.-3518   	; 0xfffff42e <__eeprom_end+0xff7ef42e>
     1ec:	fd cd       	rjmp	.-1030   	; 0xfffffde8 <__eeprom_end+0xff7efde8>
     1ee:	c6 fe       	sbrs	r12, 6
     1f0:	21 bb       	out	0x11, r18	; 17
     1f2:	fd cd       	rjmp	.-1030   	; 0xfffffdee <__eeprom_end+0xff7efdee>
     1f4:	c6 fe       	sbrs	r12, 6
     1f6:	01 ff       	sbrs	r16, 1
     1f8:	ff cd       	rjmp	.-1026   	; 0xfffffdf8 <__eeprom_end+0xff7efdf8>
     1fa:	3e ff       	.word	0xff3e	; ????
     1fc:	60 69       	ori	r22, 0x90	; 144
     1fe:	c1 d1       	rcall	.+898    	; 0x582 <ChangeRTC()::__c+0x2a>
     200:	f1 c9       	rjmp	.-3102   	; 0xfffff5e4 <__eeprom_end+0xff7ef5e4>
     202:	c5 4f       	sbci	r28, 0xF5	; 245
     204:	7b 91       	.word	0x917b	; ????
     206:	5f 79       	andi	r21, 0x9F	; 159
     208:	c1 c9       	rjmp	.-3198   	; 0xfffff58c <__eeprom_end+0xff7ef58c>
     20a:	f5 e5       	ldi	r31, 0x55	; 85
     20c:	7e fe       	.word	0xfe7e	; ????
     20e:	00 28       	or	r0, r0
     210:	06 cd       	rjmp	.-1524   	; 0xfffffc1e <__eeprom_end+0xff7efc1e>
     212:	69 ff       	.word	0xff69	; ????
     214:	23 18       	sub	r2, r3
     216:	f5 e1       	ldi	r31, 0x15	; 21
     218:	f1 c9       	rjmp	.-3102   	; 0xfffff5fc <__eeprom_end+0xff7ef5fc>
     21a:	f5 cd       	rjmp	.-1046   	; 0xfffffe06 <__eeprom_end+0xff7efe06>
     21c:	e1 fe       	sbrs	r14, 1
     21e:	67 cd       	rjmp	.-1330   	; 0xfffffcee <__eeprom_end+0xff7efcee>
     220:	e1 fe       	sbrs	r14, 1
     222:	6f f1       	brie	.+90     	; 0x27e <__trampolines_end+0x22a>
     224:	c9 c5       	rjmp	.+2962   	; 0xdb8 <delayMicroseconds+0xc>
     226:	cd f4       	brhc	.+50     	; 0x25a <__trampolines_end+0x206>
     228:	fe cb       	rjmp	.-2052   	; 0xfffffa26 <__eeprom_end+0xff7efa26>
     22a:	07 cb       	rjmp	.-2546   	; 0xfffff83a <__eeprom_end+0xff7ef83a>
     22c:	07 cb       	rjmp	.-2546   	; 0xfffff83c <__eeprom_end+0xff7ef83c>
     22e:	07 cb       	rjmp	.-2546   	; 0xfffff83e <__eeprom_end+0xff7ef83e>
     230:	07 47       	sbci	r16, 0x77	; 119
     232:	cd f4       	brhc	.+50     	; 0x266 <__trampolines_end+0x212>
     234:	fe b0       	in	r15, 0x0e	; 14
     236:	c1 c9       	rjmp	.-3198   	; 0xfffff5ba <__eeprom_end+0xff7ef5ba>
     238:	cd 72       	andi	r28, 0x2D	; 45
     23a:	ff cd       	rjmp	.-1026   	; 0xfffffe3a <__eeprom_end+0xff7efe3a>
     23c:	1a ff       	.word	0xff1a	; ????
     23e:	cd 06       	cpc	r12, r29
     240:	ff 30       	cpi	r31, 0x0F	; 15
     242:	f5 cd       	rjmp	.-1046   	; 0xfffffe2e <__eeprom_end+0xff7efe2e>
     244:	23 ff       	sbrs	r18, 3
     246:	cd 2e       	mov	r12, r29
     248:	ff c9       	rjmp	.-3074   	; 0xfffff648 <__eeprom_end+0xff7ef648>
     24a:	fe 47       	sbci	r31, 0x7E	; 126
     24c:	d0 fe       	sbrs	r13, 0
     24e:	30 30       	cpi	r19, 0x00	; 0
     250:	02 3f       	cpi	r16, 0xF2	; 242
     252:	c9 fe       	.word	0xfec9	; ????
     254:	3a d8       	rcall	.-3980   	; 0xfffff2ca <__eeprom_end+0xff7ef2ca>
     256:	fe 41       	sbci	r31, 0x1E	; 30
     258:	30 02       	muls	r19, r16
     25a:	3f c9       	rjmp	.-3458   	; 0xfffff4da <__eeprom_end+0xff7ef4da>
     25c:	37 c9       	rjmp	.-3474   	; 0xfffff4cc <__eeprom_end+0xff7ef4cc>
     25e:	fe 61       	ori	r31, 0x1E	; 30
     260:	d8 fe       	.word	0xfed8	; ????
     262:	7b d0       	rcall	.+246    	; 0x35a <printErrSD(unsigned char, unsigned char, char const*)::__c>
     264:	e6 5f       	subi	r30, 0xF6	; 246
     266:	c9 fe       	.word	0xfec9	; ????
     268:	3a 38       	cpi	r19, 0x8A	; 138
     26a:	02 d6       	rcall	.+3076   	; 0xe70 <delay+0x62>
     26c:	07 d6       	rcall	.+3086   	; 0xe7c <millis+0xa>
     26e:	30 e6       	ldi	r19, 0x60	; 96
     270:	0f c9       	rjmp	.-3554   	; 0xfffff490 <__eeprom_end+0xff7ef490>
     272:	f5 e6       	ldi	r31, 0x65	; 101
     274:	0f c6       	rjmp	.+3102   	; 0xe94 <twi_stop+0x8>
     276:	30 fe       	sbrs	r3, 0
     278:	3a 38       	cpi	r19, 0x8A	; 138
     27a:	02 c6       	rjmp	.+3076   	; 0xe80 <millis+0xe>
     27c:	07 cd       	rjmp	.-1522   	; 0xfffffc8c <__eeprom_end+0xff7efc8c>
     27e:	69 ff       	.word	0xff69	; ????
     280:	f1 c9       	rjmp	.-3102   	; 0xfffff664 <__eeprom_end+0xff7ef664>
     282:	f5 3e       	cpi	r31, 0xE5	; 229
     284:	0d cd       	rjmp	.-1510   	; 0xfffffca0 <__eeprom_end+0xff7efca0>
     286:	69 ff       	.word	0xff69	; ????
     288:	3e 0a       	sbc	r3, r30
     28a:	cd 69       	ori	r28, 0x9D	; 157
     28c:	ff f1       	brie	.+126    	; 0x30c <printErrSD(unsigned char, unsigned char, char const*)::__c+0x5>
     28e:	c9 e5       	ldi	r28, 0x59	; 89
     290:	f5 7c       	andi	r31, 0xC5	; 197
     292:	cd 58       	subi	r28, 0x8D	; 141
     294:	ff 7d       	andi	r31, 0xDF	; 223
     296:	cd 58       	subi	r28, 0x8D	; 141
     298:	ff f1       	brie	.+126    	; 0x318 <printErrSD(unsigned char, unsigned char, char const*)::__c+0x6>
     29a:	e1 c9       	rjmp	.-3134   	; 0xfffff65e <__eeprom_end+0xff7ef65e>
     29c:	f5 c5       	rjmp	.+3050   	; 0xe88 <millis+0x16>
     29e:	47 0f       	add	r20, r23
     2a0:	0f 0f       	add	r16, r31
     2a2:	0f cd       	rjmp	.-1506   	; 0xfffffcc2 <__eeprom_end+0xff7efcc2>
     2a4:	2e ff       	.word	0xff2e	; ????
     2a6:	78 cd       	rjmp	.-1296   	; 0xfffffd98 <__eeprom_end+0xff7efd98>
     2a8:	2e ff       	.word	0xff2e	; ????
     2aa:	c1 f1       	breq	.+112    	; 0x31c <printErrSD(unsigned char, unsigned char, char const*)::__c+0x2>
     2ac:	c9 f5       	brne	.+114    	; 0x320 <printErrSD(unsigned char, unsigned char, char const*)::__c+0x6>
     2ae:	3e 01       	movw	r6, r28
     2b0:	d3 01       	movw	r26, r6
     2b2:	f1 d3       	rcall	.+2018   	; 0xa96 <Serial0_available()>
     2b4:	00 c9       	rjmp	.-3584   	; 0xfffff4b6 <__eeprom_end+0xff7ef4b6>
     2b6:	db 01       	movw	r26, r22
     2b8:	fe ff       	.word	0xfffe	; ????
     2ba:	ca 72       	andi	r28, 0x2A	; 42
     2bc:	ff c9       	rjmp	.-3074   	; 0xfffff6bc <__eeprom_end+0xff7ef6bc>

000002be <waitKey()::__c>:
     2be:	49 4f 53 3a 20 43 68 65 63 6b 20 53 44 20 61 6e     IOS: Check SD an
     2ce:	64 20 70 72 65 73 73 20 61 20 6b 65 79 20 74 6f     d press a key to
     2de:	20 72 65 70 65 61 74 0d 0a 00                        repeat...

000002e8 <_ZZ10printErrSDhhPKcE3__c__15_>:
     2e8:	20 2d 20 46 69 6c 65 3a 20 00                        - File: .

000002f2 <_ZZ10printErrSDhhPKcE3__c__14_>:
     2f2:	20 6f 70 65 72 61 74 69 6f 6e 00                     operation.

000002fd <_ZZ10printErrSDhhPKcE3__c__10_>:
     2fd:	52 45 41 44 00                                      READ.

00000302 <printErrSD(unsigned char, unsigned char, char const*)::__c>:
     302:	4f 50 45 4e 00                                      OPEN.

00000307 <printErrSD(unsigned char, unsigned char, char const*)::__c>:
     307:	4d 4f 55 4e 54 00                                   MOUNT.

0000030d <printErrSD(unsigned char, unsigned char, char const*)::__c>:
     30d:	20 6f 6e 20 00                                       on .

00000312 <printErrSD(unsigned char, unsigned char, char const*)::__c>:
     312:	55 4e 4b 4e 4f 57 4e 00                             UNKNOWN.

0000031a <printErrSD(unsigned char, unsigned char, char const*)::__c>:
     31a:	4e 4f 5f 46 49 4c 45 53 59 53 54 45 4d 00           NO_FILESYSTEM.

00000328 <printErrSD(unsigned char, unsigned char, char const*)::__c>:
     328:	4e 4f 54 5f 45 4e 41 42 4c 45 44 00                 NOT_ENABLED.

00000334 <printErrSD(unsigned char, unsigned char, char const*)::__c>:
     334:	4e 4f 54 5f 4f 50 45 4e 45 44 00                    NOT_OPENED.

0000033f <printErrSD(unsigned char, unsigned char, char const*)::__c>:
     33f:	4e 4f 5f 46 49 4c 45 00                             NO_FILE.

00000347 <printErrSD(unsigned char, unsigned char, char const*)::__c>:
     347:	4e 4f 54 5f 52 45 41 44 59 00                       NOT_READY.

00000351 <printErrSD(unsigned char, unsigned char, char const*)::__c>:
     351:	44 49 53 4b 5f 45 52 52 00                          DISK_ERR.

0000035a <printErrSD(unsigned char, unsigned char, char const*)::__c>:
     35a:	0d 0a 49 4f 53 3a 20 53 44 20 65 72 72 6f 72 20     ..IOS: SD error 
	...

0000036b <port_to_mode_PGM>:
     36b:	00 00 3a 00 37 00 34 00 31 00                       ..:.7.4.1.

00000375 <port_to_output_PGM>:
     375:	00 00 3b 00 38 00 35 00 32 00                       ..;.8.5.2.

0000037f <port_to_input_PGM>:
     37f:	00 00 39 00 36 00 33 00 30 00                       ..9.6.3.0.

00000389 <digital_pin_to_port_PGM>:
     389:	02 02 02 02 02 02 02 02 04 04 04 04 04 04 04 04     ................
     399:	03 03 03 03 03 03 03 03 01 01 01 01 01 01 01 01     ................

000003a9 <digital_pin_to_bit_mask_PGM>:
     3a9:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 40 80     ..... @...... @.
     3b9:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 40 80     ..... @...... @.

000003c9 <digital_pin_to_timer_PGM>:
     3c9:	00 00 00 02 00 00 00 00 00 00 00 00 05 04 00 07     ................
	...

000003e9 <autoSetRTC()::__c>:
     3e9:	49 4f 53 3a 20 52 54 43 20 73 65 74 20 61 74 20     IOS: RTC set at 
     3f9:	63 6f 6d 70 69 6c 65 20 74 69 6d 65 20 2d 20 4e     compile time - N
     409:	6f 77 3a 20 00                                      ow: .

0000040e <autoSetRTC()::__c>:
     40e:	29 3f 20 5b 59 2f 4e 5d 20 3e 00                    )? [Y/N] >.

00000419 <autoSetRTC()::__c>:
     419:	0a 44 6f 20 79 6f 75 20 77 61 6e 74 20 73 65 74     .Do you want set
     429:	20 52 54 43 20 61 74 20 49 4f 53 20 63 6f 6d 70      RTC at IOS comp
     439:	69 6c 65 20 74 69 6d 65 20 28 00                    ile time (.

00000444 <autoSetRTC()::__c>:
     444:	49 4f 53 3a 20 52 54 43 20 63 6c 6f 63 6b 20 66     IOS: RTC clock f
     454:	61 69 6c 75 72 65 21 00                             ailure!.

0000045c <autoSetRTC()::__c>:
     45c:	49 4f 53 3a 20 52 54 43 20 44 53 33 32 33 31 20     IOS: RTC DS3231 
     46c:	74 65 6d 70 65 72 61 74 75 72 65 20 73 65 6e 73     temperature sens
     47c:	6f 72 3a 20 00                                      or: .

00000481 <autoSetRTC()::__c>:
     481:	49 4f 53 3a 20 46 6f 75 6e 64 20 52 54 43 20 44     IOS: Found RTC D
     491:	53 33 32 33 31 20 4d 6f 64 75 6c 65 20 28 00        S3231 Module (.

000004a0 <printMsg1()::__c>:
     4a0:	0d 0a 50 72 65 73 73 20 43 52 20 74 6f 20 61 63     ..Press CR to ac
     4b0:	63 65 70 74 2c 20 45 53 43 20 74 6f 20 65 78 69     cept, ESC to exi
     4c0:	74 20 6f 72 20 61 6e 79 20 6f 74 68 65 72 20 6b     t or any other k
     4d0:	65 79 20 74 6f 20 63 68 61 6e 67 65 00              ey to change.

000004dd <_ZZ9ChangeRTCvE3__c__10_>:
     4dd:	49 4f 53 3a 20 52 54 43 20 64 61 74 65 2f 74 69     IOS: RTC date/ti
     4ed:	6d 65 20 75 70 64 61 74 65 64 20 28 00              me updated (.

000004fa <ChangeRTC()::__c>:
     4fa:	20 2e 2e 2e 64 6f 6e 65 20 20 20 20 20 20 0a 00      ...done      ..

0000050a <ChangeRTC()::__c>:
     50a:	53 65 63 6f 6e 64 73 20 2d 3e 20 00                 Seconds -> .

00000516 <ChangeRTC()::__c>:
     516:	4d 69 6e 75 74 65 73 20 2d 3e 20 00                 Minutes -> .

00000522 <ChangeRTC()::__c>:
     522:	48 6f 75 72 73 20 2d 3e 20 00                       Hours -> .

0000052c <ChangeRTC()::__c>:
     52c:	20 44 61 79 20 2d 3e 20 00                           Day -> .

00000535 <ChangeRTC()::__c>:
     535:	20 20 20 20 20 20 20 20 20 20 20 20 20 00                        .

00000543 <ChangeRTC()::__c>:
     543:	4d 6f 6e 74 68 20 2d 3e 20 00                       Month -> .

0000054d <ChangeRTC()::__c>:
     54d:	59 65 61 72 20 2d 3e 20 00                          Year -> .

00000556 <ChangeRTC()::__c>:
     556:	20 00                                                .

00000558 <ChangeRTC()::__c>:
     558:	0a 50 72 65 73 73 20 54 2f 55 20 74 6f 20 69 6e     .Press T/U to in
     568:	63 72 65 6d 65 6e 74 20 2b 31 30 2f 2b 31 20 6f     crement +10/+1 o
     578:	72 20 43 52 20 74 6f 20 61 63 63 65 70 74 00        r CR to accept.

00000587 <ChangeRTC()::__c>:
     587:	0a 49 4f 53 3a 20 52 54 43 20 6d 61 6e 75 61 6c     .IOS: RTC manual
     597:	20 73 65 74 74 69 6e 67 3a 00                        setting:.

000005a1 <_ZZ5setupE3__c__35_>:
     5a1:	49 4f 53 3a 20 5a 38 30 20 69 73 20 72 75 6e 6e     IOS: Z80 is runn
     5b1:	69 6e 67 20 66 72 6f 6d 20 6e 6f 77 00              ing from now.

000005be <_ZZ5setupE3__c__34_>:
     5be:	20 44 6f 6e 65 00                                    Done.

000005c4 <_ZZ5setupE3__c__33_>:
     5c4:	49 4f 53 3a 20 4c 6f 61 64 69 6e 67 20 62 6f 6f     IOS: Loading boo
     5d4:	74 20 70 72 6f 67 72 61 6d 2e 2e 2e 00              t program....

000005e1 <_ZZ5setupE3__c__32_>:
     5e1:	29 2e 2e 2e 00                                      )....

000005e6 <_ZZ5setupE3__c__31_>:
     5e6:	49 4f 53 3a 20 4c 6f 61 64 69 6e 67 20 62 6f 6f     IOS: Loading boo
     5f6:	74 20 70 72 6f 67 72 61 6d 20 28 00                 t program (.

00000602 <flahBootTable>:
     602:	54 00                                               T.

00000604 <_ZZ5setupE3__c__27_>:
     604:	49 4f 53 3a 20 43 75 72 72 65 6e 74 20 00           IOS: Current .

00000612 <_ZZ5setupE3__c__26_>:
     612:	43 68 61 6e 67 65 64 20 73 70 65 65 64 20 77 69     Changed speed wi
     622:	6c 6c 20 62 65 20 65 66 66 65 63 74 69 76 65 20     ll be effective 
     632:	61 66 74 65 72 20 6e 65 78 74 20 72 65 62 6f 6f     after next reboo
     642:	74 21 0d 0a 0a 00                                   t!....

00000648 <_ZZ5setupE3__c__25_>:
     648:	20 20 20 0d 00                                         ..

0000064d <_ZZ5setupE3__c__24_>:
     64d:	0d 20 2d 3e 00                                      . ->.

00000652 <_ZZ5setupE3__c__23_>:
     652:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     662:	20 0d 00                                             ..

00000665 <_ZZ5setupE3__c__22_>:
     665:	0d 20 2d 3e 00                                      . ->.

0000066a <_ZZ5setupE3__c__21_>:
     66a:	20 20 4f 6b 00                                        Ok.

0000066f <_ZZ5setupE3__c__20_>:
     66f:	45 6e 74 65 72 20 79 6f 75 72 20 63 68 6f 69 63     Enter your choic
     67f:	65 20 3e 00                                         e >.

00000683 <_ZZ5setupE3__c__19_>:
     683:	20 39 3a 20 53 65 74 20 52 54 43 20 74 69 6d 65      9: Set RTC time
     693:	2f 64 61 74 65 00                                   /date.

00000699 <_ZZ5setupE3__c__18_>:
     699:	20 38 3a 20 53 65 74 20 73 65 72 69 61 6c 20 70      8: Set serial p
     6a9:	6f 72 74 20 73 70 65 65 64 20 28 00                 ort speed (.

000006b5 <_ZZ5setupE3__c__17_>:
     6b5:	4f 46 46 00                                         OFF.

000006b9 <_ZZ5setupE3__c__16_>:
     6b9:	20 37 3a 20 54 6f 67 67 6c 65 20 43 50 2f 4d 20      7: Toggle CP/M 
     6c9:	41 75 74 6f 65 78 65 63 20 28 2d 3e 00              Autoexec (->.

000006d6 <_ZZ5setupE3__c__15_>:
     6d6:	4d 48 7a 29 00                                      MHz).

000006db <_ZZ5setupE3__c__14_>:
     6db:	20 36 3a 20 43 68 61 6e 67 65 20 5a 38 30 20 63      6: Change Z80 c
     6eb:	6c 6f 63 6b 20 73 70 65 65 64 20 28 2d 3e 00        lock speed (->.

000006fa <_ZZ5setupE3__c__13_>:
     6fa:	20 35 3a 20 69 4c 6f 61 64 00                        5: iLoad.

00000704 <_ZZ5setupE3__c__12_>:
     704:	0d 0a 20 34 3a 20 41 75 74 6f 62 6f 6f 74 00        .. 4: Autoboot.

00000713 <_ZZ5setupE3__c__11_>:
     713:	20 33 3a 20 4c 6f 61 64 2f 73 65 74 20 4f 53 20      3: Load/set OS 
	...

00000724 <_ZZ5setupE3__c__10_>:
     724:	20 32 3a 20 46 6f 72 74 68 00                        2: Forth.

0000072e <setup::__c>:
     72e:	20 31 3a 20 42 61 73 69 63 00                        1: Basic.

00000738 <setup::__c>:
     738:	20 30 3a 20 4e 6f 20 63 68 61 6e 67 65 20 28 00      0: No change (.

00000748 <setup::__c>:
     748:	49 4f 53 3a 20 53 65 6c 65 63 74 20 62 6f 6f 74     IOS: Select boot
     758:	20 6d 6f 64 65 20 6f 72 20 73 79 73 74 65 6d 20      mode or system 
     768:	70 61 72 61 6d 65 74 65 72 73 3a 00                 parameters:.

00000774 <setup::__c>:
     774:	4f 46 46 00                                         OFF.

00000778 <setup::__c>:
     778:	4f 4e 00                                            ON.

0000077b <setup::__c>:
     77b:	49 4f 53 3a 20 43 50 2f 4d 20 41 75 74 6f 65 78     IOS: CP/M Autoex
     78b:	65 63 20 69 73 20 00                                ec is .

00000792 <setup::__c>:
     792:	49 4f 53 3a 20 46 6f 75 6e 64 20 47 50 45 20 4f     IOS: Found GPE O
     7a2:	70 74 69 6f 6e 00                                   ption.

000007a8 <setup::__c>:
     7a8:	4d 48 7a 00                                         MHz.

000007ac <setup::__c>:
     7ac:	49 4f 53 3a 20 5a 38 30 20 63 6c 6f 63 6b 20 73     IOS: Z80 clock s
     7bc:	65 74 20 61 74 20 00                                et at .

000007c3 <setup::__c>:
     7c3:	0d 0a 0a 5a 38 30 2d 4d 42 43 32 20 2d 20 41 30     ...Z80-MBC2 - A0
     7d3:	34 30 36 31 38 0d 0a 49 4f 53 20 2d 20 49 2f 4f     40618..IOS - I/O
     7e3:	20 53 75 62 73 79 73 74 65 6d 20 2d 20 53 32 32      Subsystem - S22
     7f3:	30 37 31 38 2d 52 32 39 30 38 32 33 0d 0a 00        0718-R290823...

00000802 <WaitAndBlink(baudRecCheck)::__c>:
     802:	0d 0a 0a 49 4f 53 3a 20 42 61 75 64 20 72 65 63     ...IOS: Baud rec
     812:	6f 76 65 72 79 20 64 6f 6e 65 20 2d 20 50 6c 65     overy done - Ple
     822:	61 73 65 20 72 65 62 6f 6f 74 20 6e 6f 77 21 00     ase reboot now!.

00000832 <__ctors_start>:
__ctors_start():
     832:	9d 16       	cp	r9, r29

00000834 <__ctors_end>:
__dtors_start():
     834:	c4 24       	eor	r12, r4

00000836 <__dtors_end>:
__dtors_end():
     836:	11 24       	eor	r1, r1
     838:	1f be       	out	0x3f, r1	; 63
     83a:	cf e5       	ldi	r28, 0x5F	; 95
     83c:	d8 e0       	ldi	r29, 0x08	; 8
     83e:	de bf       	out	0x3e, r29	; 62
     840:	cd bf       	out	0x3d, r28	; 61

00000842 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     842:	23 e0       	ldi	r18, 0x03	; 3
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     844:	a0 e7       	ldi	r26, 0x70	; 112
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     846:	b1 e0       	ldi	r27, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     848:	01 c0       	rjmp	.+2      	; 0x84c <.do_clear_bss_start>

0000084a <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     84a:	1d 92       	st	X+, r1

0000084c <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     84c:	ab 36       	cpi	r26, 0x6B	; 107
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     84e:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     850:	e1 f7       	brne	.-8      	; 0x84a <.do_clear_bss_loop>

00000852 <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
     852:	11 e0       	ldi	r17, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
     854:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
     856:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
     858:	e2 e4       	ldi	r30, 0x42	; 66
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
     85a:	ff e4       	ldi	r31, 0x4F	; 79
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
     85c:	02 c0       	rjmp	.+4      	; 0x862 <__stack+0x3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
     85e:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
     860:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
     862:	a0 37       	cpi	r26, 0x70	; 112
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
     864:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
     866:	d9 f7       	brne	.-10     	; 0x85e <__do_copy_data+0xc>

00000868 <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     868:	14 e0       	ldi	r17, 0x04	; 4
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     86a:	ca e1       	ldi	r28, 0x1A	; 26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     86c:	d4 e0       	ldi	r29, 0x04	; 4
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     86e:	04 c0       	rjmp	.+8      	; 0x878 <__do_global_ctors+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     870:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     872:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     874:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     878:	c9 31       	cpi	r28, 0x19	; 25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     87a:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     87c:	c9 f7       	brne	.-14     	; 0x870 <__do_global_ctors+0x8>
     87e:	0e 94 02 17 	call	0x2e04	; 0x2e04 <main>
     882:	0c 94 94 27 	jmp	0x4f28	; 0x4f28 <__do_global_dtors>

00000886 <__bad_interrupt>:
__vector_1():
     886:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000088a <TwoWire::endTransmission() [clone .constprop.30]>:
endTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:225
//  devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
  // transmit buffer (blocking)
  uint8_t ret = twi_writeTo(txAddress, txBuffer, txBufferLength, 1, sendStop);
     88a:	90 91 54 02 	lds	r25, 0x0254	; 0x800254 <TwoWire::txBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:269
 */
uint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)
{
  // ensure data will fit into buffer
  if(TWI_BUFFER_SIZE < length){
    return 1;
     88e:	81 e0       	ldi	r24, 0x01	; 1
twi_writeTo():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:268
 *          5 .. timeout
 */
uint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)
{
  // ensure data will fit into buffer
  if(TWI_BUFFER_SIZE < length){
     890:	91 32       	cpi	r25, 0x21	; 33
     892:	08 f0       	brcs	.+2      	; 0x896 <TwoWire::endTransmission() [clone .constprop.30]+0xc>
     894:	40 c0       	rjmp	.+128    	; 0x916 <TwoWire::endTransmission() [clone .constprop.30]+0x8c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:282
        twi_handleTimeout(twi_do_reset_on_timeout);
        return (5);
      }
    }
  #else
    while(TWI_READY != twi_state){
     896:	80 91 30 02 	lds	r24, 0x0230	; 0x800230 <twi_state>
     89a:	81 11       	cpse	r24, r1
     89c:	fc cf       	rjmp	.-8      	; 0x896 <TwoWire::endTransmission() [clone .constprop.30]+0xc>
endTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:225
     89e:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <TwoWire::txAddress>
twi_writeTo():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:287
      continue;
    }
  #endif

  twi_state = TWI_MTX;
     8a2:	22 e0       	ldi	r18, 0x02	; 2
     8a4:	20 93 30 02 	sts	0x0230, r18	; 0x800230 <twi_state>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:288
  twi_sendStop = sendStop;
     8a8:	21 e0       	ldi	r18, 0x01	; 1
     8aa:	20 93 2f 02 	sts	0x022F, r18	; 0x80022f <twi_sendStop>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:290
  // reset error state (0xFF.. no error occurred)
  twi_error = 0xFF;
     8ae:	2f ef       	ldi	r18, 0xFF	; 255
     8b0:	20 93 2e 02 	sts	0x022E, r18	; 0x80022e <twi_error>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:293

  // initialize buffer iteration vars
  twi_masterBuffer = data;
     8b4:	23 e3       	ldi	r18, 0x33	; 51
     8b6:	32 e0       	ldi	r19, 0x02	; 2
     8b8:	30 93 2d 02 	sts	0x022D, r19	; 0x80022d <twi_masterBuffer+0x1>
     8bc:	20 93 2c 02 	sts	0x022C, r18	; 0x80022c <twi_masterBuffer>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:294
  twi_masterBufferIndex = 0;
     8c0:	10 92 2b 02 	sts	0x022B, r1	; 0x80022b <twi_masterBufferIndex>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:295
  twi_masterBufferLength = length;
     8c4:	90 93 2a 02 	sts	0x022A, r25	; 0x80022a <twi_masterBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:298

  // build sla+w, slave device address + w bit
  twi_slarw = TW_WRITE;
     8c8:	10 92 29 02 	sts	0x0229, r1	; 0x800229 <twi_slarw>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:299
  twi_slarw |= address << 1;
     8cc:	90 91 29 02 	lds	r25, 0x0229	; 0x800229 <twi_slarw>
     8d0:	88 0f       	add	r24, r24
     8d2:	89 2b       	or	r24, r25
     8d4:	80 93 29 02 	sts	0x0229, r24	; 0x800229 <twi_slarw>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:304

  // if we're in a repeated start, then we've already sent the START
  // in the ISR. Don't do it again.
  //
  if (true == twi_inRepStart) {
     8d8:	80 91 28 02 	lds	r24, 0x0228	; 0x800228 <twi_inRepStart>
     8dc:	81 30       	cpi	r24, 0x01	; 1
     8de:	11 f5       	brne	.+68     	; 0x924 <TwoWire::endTransmission() [clone .constprop.30]+0x9a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:311
    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
    // We need to remove ourselves from the repeated start state before we enable interrupts,
    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
    // up. Also, don't enable the START interrupt. There may be one pending from the 
    // repeated start that we sent ourselves, and that would really confuse things.
    twi_inRepStart = false; // Remember, we're dealing with an ASYNC ISR
     8e0:	10 92 28 02 	sts	0x0228, r1	; 0x800228 <twi_inRepStart>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:322
          return (5);
        }
      } while(TWCR & _BV(TWWC));
    #else
      do {
        TWDR = twi_slarw;
     8e4:	80 91 29 02 	lds	r24, 0x0229	; 0x800229 <twi_slarw>
     8e8:	83 b9       	out	0x03, r24	; 3
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:323
      } while(TWCR & _BV(TWWC));
     8ea:	06 b6       	in	r0, 0x36	; 54
     8ec:	03 fc       	sbrc	r0, 3
     8ee:	fa cf       	rjmp	.-12     	; 0x8e4 <TwoWire::endTransmission() [clone .constprop.30]+0x5a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:325
    #endif
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);  // enable INTs, but not START
     8f0:	85 ec       	ldi	r24, 0xC5	; 197
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:329
  }
  else
    // send start condition
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA); // enable INTs
     8f2:	86 bf       	out	0x36, r24	; 54
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:341
        twi_handleTimeout(twi_do_reset_on_timeout);
        return (5);
      }
    }
  #else
    while(wait && (TWI_MTX == twi_state)){
     8f4:	80 91 30 02 	lds	r24, 0x0230	; 0x800230 <twi_state>
     8f8:	82 30       	cpi	r24, 0x02	; 2
     8fa:	e1 f3       	breq	.-8      	; 0x8f4 <TwoWire::endTransmission() [clone .constprop.30]+0x6a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:346
      continue;
    }
  #endif

  if (twi_error == 0xFF)
     8fc:	80 91 2e 02 	lds	r24, 0x022E	; 0x80022e <twi_error>
     900:	8f 3f       	cpi	r24, 0xFF	; 255
     902:	91 f0       	breq	.+36     	; 0x928 <TwoWire::endTransmission() [clone .constprop.30]+0x9e>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:348
    return 0; // success
  else if (twi_error == TW_MT_SLA_NACK)
     904:	80 91 2e 02 	lds	r24, 0x022E	; 0x80022e <twi_error>
     908:	80 32       	cpi	r24, 0x20	; 32
     90a:	81 f0       	breq	.+32     	; 0x92c <TwoWire::endTransmission() [clone .constprop.30]+0xa2>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:350
    return 2; // error: address send, nack received
  else if (twi_error == TW_MT_DATA_NACK)
     90c:	80 91 2e 02 	lds	r24, 0x022E	; 0x80022e <twi_error>
     910:	80 33       	cpi	r24, 0x30	; 48
     912:	71 f0       	breq	.+28     	; 0x930 <TwoWire::endTransmission() [clone .constprop.30]+0xa6>
endTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:353
    return 3; // error: data send, nack received
  else
    return 4; // other twi error
     914:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:227
  // reset tx buffer iterator vars
  txBufferIndex = 0;
     916:	10 92 32 02 	sts	0x0232, r1	; 0x800232 <TwoWire::txBufferIndex>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:228
  txBufferLength = 0;
     91a:	10 92 54 02 	sts	0x0254, r1	; 0x800254 <TwoWire::txBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:230
  // indicate that we are done transmitting
  transmitting = 0;
     91e:	10 92 31 02 	sts	0x0231, r1	; 0x800231 <TwoWire::transmitting>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:240
//  definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
  return endTransmission(true);
}
     922:	08 95       	ret
twi_writeTo():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:329
    #endif
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);  // enable INTs, but not START
  }
  else
    // send start condition
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA); // enable INTs
     924:	85 ee       	ldi	r24, 0xE5	; 229
     926:	e5 cf       	rjmp	.-54     	; 0x8f2 <TwoWire::endTransmission() [clone .constprop.30]+0x68>
endTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:347
      continue;
    }
  #endif

  if (twi_error == 0xFF)
    return 0; // success
     928:	80 e0       	ldi	r24, 0x00	; 0
     92a:	f5 cf       	rjmp	.-22     	; 0x916 <TwoWire::endTransmission() [clone .constprop.30]+0x8c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:349
  else if (twi_error == TW_MT_SLA_NACK)
    return 2; // error: address send, nack received
     92c:	82 e0       	ldi	r24, 0x02	; 2
     92e:	f3 cf       	rjmp	.-26     	; 0x916 <TwoWire::endTransmission() [clone .constprop.30]+0x8c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:351
  else if (twi_error == TW_MT_DATA_NACK)
    return 3; // error: data send, nack received
     930:	83 e0       	ldi	r24, 0x03	; 3
     932:	f1 cf       	rjmp	.-30     	; 0x916 <TwoWire::endTransmission() [clone .constprop.30]+0x8c>

00000934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>:
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:196
}

void TwoWire::beginTransmission(uint8_t address)
{
  // indicate that we are transmitting
  transmitting = 1;
     934:	91 e0       	ldi	r25, 0x01	; 1
     936:	90 93 31 02 	sts	0x0231, r25	; 0x800231 <TwoWire::transmitting>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:198
  // set address of targeted slave
  txAddress = address;
     93a:	80 93 53 02 	sts	0x0253, r24	; 0x800253 <TwoWire::txAddress>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:200
  // reset tx buffer iterator vars
  txBufferIndex = 0;
     93e:	10 92 32 02 	sts	0x0232, r1	; 0x800232 <TwoWire::txBufferIndex>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:201
  txBufferLength = 0;
     942:	10 92 54 02 	sts	0x0254, r1	; 0x800254 <TwoWire::txBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:202
}
     946:	08 95       	ret

00000948 <TwoWire::read()>:
read():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:301
int TwoWire::read(void)
{
  int value = -1;

  // get each successive byte on each call
  if(rxBufferIndex < rxBufferLength){
     948:	90 91 24 02 	lds	r25, 0x0224	; 0x800224 <TwoWire::rxBufferIndex>
     94c:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <TwoWire::rxBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:298
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  int value = -1;
     950:	2f ef       	ldi	r18, 0xFF	; 255
     952:	3f ef       	ldi	r19, 0xFF	; 255
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:301

  // get each successive byte on each call
  if(rxBufferIndex < rxBufferLength){
     954:	98 17       	cp	r25, r24
     956:	48 f4       	brcc	.+18     	; 0x96a <TwoWire::read()+0x22>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:302
    value = rxBuffer[rxBufferIndex];
     958:	e9 2f       	mov	r30, r25
     95a:	f0 e0       	ldi	r31, 0x00	; 0
     95c:	ed 5f       	subi	r30, 0xFD	; 253
     95e:	fd 4f       	sbci	r31, 0xFD	; 253
     960:	20 81       	ld	r18, Z
     962:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:303
    ++rxBufferIndex;
     964:	9f 5f       	subi	r25, 0xFF	; 255
     966:	90 93 24 02 	sts	0x0224, r25	; 0x800224 <TwoWire::rxBufferIndex>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:307
  }

  return value;
}
     96a:	c9 01       	movw	r24, r18
     96c:	08 95       	ret

0000096e <TwoWire::read() [clone .constprop.26]>:
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:301
int TwoWire::read(void)
{
  int value = -1;

  // get each successive byte on each call
  if(rxBufferIndex < rxBufferLength){
     96e:	90 91 24 02 	lds	r25, 0x0224	; 0x800224 <TwoWire::rxBufferIndex>
     972:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <TwoWire::rxBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:298
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  int value = -1;
     976:	2f ef       	ldi	r18, 0xFF	; 255
     978:	3f ef       	ldi	r19, 0xFF	; 255
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:301

  // get each successive byte on each call
  if(rxBufferIndex < rxBufferLength){
     97a:	98 17       	cp	r25, r24
     97c:	48 f4       	brcc	.+18     	; 0x990 <TwoWire::read() [clone .constprop.26]+0x22>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:302
    value = rxBuffer[rxBufferIndex];
     97e:	e9 2f       	mov	r30, r25
     980:	f0 e0       	ldi	r31, 0x00	; 0
     982:	ed 5f       	subi	r30, 0xFD	; 253
     984:	fd 4f       	sbci	r31, 0xFD	; 253
     986:	20 81       	ld	r18, Z
     988:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:303
    ++rxBufferIndex;
     98a:	9f 5f       	subi	r25, 0xFF	; 255
     98c:	90 93 24 02 	sts	0x0224, r25	; 0x800224 <TwoWire::rxBufferIndex>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:307
  }

  return value;
}
     990:	c9 01       	movw	r24, r18
     992:	08 95       	ret

00000994 <String::operator[](unsigned int) const [clone .constprop.14]>:
operator[]():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:534
  return buffer[index];
}

char String::operator[]( unsigned int index ) const
{
  if (index >= len || !buffer) return 0;
     994:	20 91 53 03 	lds	r18, 0x0353	; 0x800353 <compDateStr+0x4>
     998:	30 91 54 03 	lds	r19, 0x0354	; 0x800354 <compDateStr+0x5>
     99c:	82 17       	cp	r24, r18
     99e:	93 07       	cpc	r25, r19
     9a0:	60 f4       	brcc	.+24     	; 0x9ba <String::operator[](unsigned int) const [clone .constprop.14]+0x26>
     9a2:	20 91 4f 03 	lds	r18, 0x034F	; 0x80034f <compDateStr>
     9a6:	30 91 50 03 	lds	r19, 0x0350	; 0x800350 <compDateStr+0x1>
     9aa:	21 15       	cp	r18, r1
     9ac:	31 05       	cpc	r19, r1
     9ae:	29 f0       	breq	.+10     	; 0x9ba <String::operator[](unsigned int) const [clone .constprop.14]+0x26>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:535
  return buffer[index];
     9b0:	28 0f       	add	r18, r24
     9b2:	39 1f       	adc	r19, r25
     9b4:	f9 01       	movw	r30, r18
     9b6:	80 81       	ld	r24, Z
     9b8:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:534
  return buffer[index];
}

char String::operator[]( unsigned int index ) const
{
  if (index >= len || !buffer) return 0;
     9ba:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:536
  return buffer[index];
}
     9bc:	08 95       	ret

000009be <TwoWire::onRequestService()>:
onRequestService():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:366
  // !!! this will kill any pending pre-master sendTo() activity
  txBufferIndex = 0;
  txBufferLength = 0;
  // alert user program
  user_onRequest();
}
     9be:	08 95       	ret

000009c0 <TwoWire::onReceiveService(unsigned char*, int)>:
onReceiveService():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:351
  // set rx iterator vars
  rxBufferIndex = 0;
  rxBufferLength = numBytes;
  // alert user program
  user_onReceive(numBytes);
}
     9c0:	08 95       	ret

000009c2 <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:35

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     9c2:	af 92       	push	r10
     9c4:	bf 92       	push	r11
     9c6:	cf 92       	push	r12
     9c8:	df 92       	push	r13
     9ca:	ef 92       	push	r14
     9cc:	ff 92       	push	r15
     9ce:	0f 93       	push	r16
     9d0:	1f 93       	push	r17
     9d2:	cf 93       	push	r28
     9d4:	df 93       	push	r29
     9d6:	6c 01       	movw	r12, r24
     9d8:	7b 01       	movw	r14, r22
     9da:	8b 01       	movw	r16, r22
     9dc:	04 0f       	add	r16, r20
     9de:	15 1f       	adc	r17, r21
     9e0:	eb 01       	movw	r28, r22
     9e2:	5e 01       	movw	r10, r28
     9e4:	ae 18       	sub	r10, r14
     9e6:	bf 08       	sbc	r11, r15
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:37
  size_t n = 0;
  while (size--) {
     9e8:	c0 17       	cp	r28, r16
     9ea:	d1 07       	cpc	r29, r17
     9ec:	59 f0       	breq	.+22     	; 0xa04 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:38
    if (write(*buffer++)) n++;
     9ee:	69 91       	ld	r22, Y+
     9f0:	d6 01       	movw	r26, r12
     9f2:	ed 91       	ld	r30, X+
     9f4:	fc 91       	ld	r31, X
     9f6:	01 90       	ld	r0, Z+
     9f8:	f0 81       	ld	r31, Z
     9fa:	e0 2d       	mov	r30, r0
     9fc:	c6 01       	movw	r24, r12
     9fe:	09 95       	icall
     a00:	89 2b       	or	r24, r25
     a02:	79 f7       	brne	.-34     	; 0x9e2 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:42
    else break;
  }
  return n;
}
     a04:	c5 01       	movw	r24, r10
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	1f 91       	pop	r17
     a0c:	0f 91       	pop	r16
     a0e:	ff 90       	pop	r15
     a10:	ef 90       	pop	r14
     a12:	df 90       	pop	r13
     a14:	cf 90       	pop	r12
     a16:	bf 90       	pop	r11
     a18:	af 90       	pop	r10
     a1a:	08 95       	ret

00000a1c <HardwareSerial::availableForWrite()>:
availableForWrite():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:195
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     a1c:	fc 01       	movw	r30, r24
     a1e:	53 8d       	ldd	r21, Z+27	; 0x1b
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:196
    tail = _tx_buffer_tail;
     a20:	44 8d       	ldd	r20, Z+28	; 0x1c
     a22:	25 2f       	mov	r18, r21
     a24:	30 e0       	ldi	r19, 0x00	; 0
     a26:	84 2f       	mov	r24, r20
     a28:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:198
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     a2a:	82 1b       	sub	r24, r18
     a2c:	93 0b       	sbc	r25, r19
     a2e:	54 17       	cp	r21, r20
     a30:	10 f0       	brcs	.+4      	; 0xa36 <HardwareSerial::availableForWrite()+0x1a>
     a32:	cf 96       	adiw	r24, 0x3f	; 63
     a34:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:199
  return tail - head - 1;
     a36:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:200
}
     a38:	08 95       	ret

00000a3a <HardwareSerial::read()>:
read():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:178
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
     a3a:	fc 01       	movw	r30, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:180
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     a3c:	91 8d       	ldd	r25, Z+25	; 0x19
     a3e:	82 8d       	ldd	r24, Z+26	; 0x1a
     a40:	98 17       	cp	r25, r24
     a42:	61 f0       	breq	.+24     	; 0xa5c <HardwareSerial::read()+0x22>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:183
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     a44:	a2 8d       	ldd	r26, Z+26	; 0x1a
     a46:	ae 0f       	add	r26, r30
     a48:	bf 2f       	mov	r27, r31
     a4a:	b1 1d       	adc	r27, r1
     a4c:	5d 96       	adiw	r26, 0x1d	; 29
     a4e:	8c 91       	ld	r24, X
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:184
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     a50:	92 8d       	ldd	r25, Z+26	; 0x1a
     a52:	9f 5f       	subi	r25, 0xFF	; 255
     a54:	9f 73       	andi	r25, 0x3F	; 63
     a56:	92 8f       	std	Z+26, r25	; 0x1a
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:185
    return c;
     a58:	90 e0       	ldi	r25, 0x00	; 0
     a5a:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:181

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     a5c:	8f ef       	ldi	r24, 0xFF	; 255
     a5e:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:187
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     a60:	08 95       	ret

00000a62 <HardwareSerial::peek()>:
peek():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:169
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
     a62:	fc 01       	movw	r30, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:170
  if (_rx_buffer_head == _rx_buffer_tail) {
     a64:	91 8d       	ldd	r25, Z+25	; 0x19
     a66:	82 8d       	ldd	r24, Z+26	; 0x1a
     a68:	98 17       	cp	r25, r24
     a6a:	31 f0       	breq	.+12     	; 0xa78 <HardwareSerial::peek()+0x16>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:173
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     a6c:	82 8d       	ldd	r24, Z+26	; 0x1a
     a6e:	e8 0f       	add	r30, r24
     a70:	f1 1d       	adc	r31, r1
     a72:	85 8d       	ldd	r24, Z+29	; 0x1d
     a74:	90 e0       	ldi	r25, 0x00	; 0
     a76:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:171
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     a78:	8f ef       	ldi	r24, 0xFF	; 255
     a7a:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:175
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     a7c:	08 95       	ret

00000a7e <HardwareSerial::available()>:
available():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:164
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     a7e:	fc 01       	movw	r30, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:165
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     a80:	91 8d       	ldd	r25, Z+25	; 0x19
     a82:	22 8d       	ldd	r18, Z+26	; 0x1a
     a84:	89 2f       	mov	r24, r25
     a86:	90 e0       	ldi	r25, 0x00	; 0
     a88:	80 5c       	subi	r24, 0xC0	; 192
     a8a:	9f 4f       	sbci	r25, 0xFF	; 255
     a8c:	82 1b       	sub	r24, r18
     a8e:	91 09       	sbc	r25, r1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:166
}
     a90:	8f 73       	andi	r24, 0x3F	; 63
     a92:	99 27       	eor	r25, r25
     a94:	08 95       	ret

00000a96 <Serial0_available()>:
Serial0_available():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial0.cpp:76
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     a96:	86 ea       	ldi	r24, 0xA6	; 166
     a98:	92 e0       	ldi	r25, 0x02	; 2
     a9a:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
     a9e:	21 e0       	ldi	r18, 0x01	; 1
     aa0:	89 2b       	or	r24, r25
     aa2:	09 f4       	brne	.+2      	; 0xaa6 <Serial0_available()+0x10>
     aa4:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial0.cpp:77
}
     aa6:	82 2f       	mov	r24, r18
     aa8:	08 95       	ret

00000aaa <HardwareSerial::_tx_udr_empty_irq()>:
_tx_udr_empty_irq():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:90
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     aaa:	fc 01       	movw	r30, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:93
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     aac:	a4 8d       	ldd	r26, Z+28	; 0x1c
     aae:	a8 0f       	add	r26, r24
     ab0:	b9 2f       	mov	r27, r25
     ab2:	b1 1d       	adc	r27, r1
     ab4:	a3 5a       	subi	r26, 0xA3	; 163
     ab6:	bf 4f       	sbci	r27, 0xFF	; 255
     ab8:	2c 91       	ld	r18, X
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:94
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     aba:	84 8d       	ldd	r24, Z+28	; 0x1c
     abc:	90 e0       	ldi	r25, 0x00	; 0
     abe:	01 96       	adiw	r24, 0x01	; 1
     ac0:	8f 73       	andi	r24, 0x3F	; 63
     ac2:	99 27       	eor	r25, r25
     ac4:	84 8f       	std	Z+28, r24	; 0x1c
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:96

  *_udr = c;
     ac6:	a6 89       	ldd	r26, Z+22	; 0x16
     ac8:	b7 89       	ldd	r27, Z+23	; 0x17
     aca:	2c 93       	st	X, r18
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:106
  // written to the rest.

  #ifdef MPCM0
    *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
  #else
    *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
     acc:	a0 89       	ldd	r26, Z+16	; 0x10
     ace:	b1 89       	ldd	r27, Z+17	; 0x11
     ad0:	8c 91       	ld	r24, X
     ad2:	82 74       	andi	r24, 0x42	; 66
     ad4:	8c 93       	st	X, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:109
  #endif

  if (_tx_buffer_head == _tx_buffer_tail) {
     ad6:	93 8d       	ldd	r25, Z+27	; 0x1b
     ad8:	84 8d       	ldd	r24, Z+28	; 0x1c
     ada:	98 13       	cpse	r25, r24
     adc:	06 c0       	rjmp	.+12     	; 0xaea <HardwareSerial::_tx_udr_empty_irq()+0x40>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:111
    // Buffer empty, so disable interrupts
    *_ucsrb &= ~_BV(UDRIE0);
     ade:	02 88       	ldd	r0, Z+18	; 0x12
     ae0:	f3 89       	ldd	r31, Z+19	; 0x13
     ae2:	e0 2d       	mov	r30, r0
     ae4:	80 81       	ld	r24, Z
     ae6:	8f 7d       	andi	r24, 0xDF	; 223
     ae8:	80 83       	st	Z, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:113
  }
}
     aea:	08 95       	ret

00000aec <HardwareSerial::write(unsigned char)>:
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:223
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
     aec:	ef 92       	push	r14
     aee:	ff 92       	push	r15
     af0:	0f 93       	push	r16
     af2:	1f 93       	push	r17
     af4:	cf 93       	push	r28
     af6:	df 93       	push	r29
     af8:	ec 01       	movw	r28, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:224
  _written = true;
     afa:	81 e0       	ldi	r24, 0x01	; 1
     afc:	88 8f       	std	Y+24, r24	; 0x18
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:229
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     afe:	9b 8d       	ldd	r25, Y+27	; 0x1b
     b00:	8c 8d       	ldd	r24, Y+28	; 0x1c
     b02:	98 13       	cpse	r25, r24
     b04:	19 c0       	rjmp	.+50     	; 0xb38 <HardwareSerial::write(unsigned char)+0x4c>
     b06:	e8 89       	ldd	r30, Y+16	; 0x10
     b08:	f9 89       	ldd	r31, Y+17	; 0x11
     b0a:	80 81       	ld	r24, Z
     b0c:	85 ff       	sbrs	r24, 5
     b0e:	14 c0       	rjmp	.+40     	; 0xb38 <HardwareSerial::write(unsigned char)+0x4c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:238
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     b10:	9f b7       	in	r25, 0x3f	; 63
__iCliRetVal():
c:\users\anthony\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/atomic.h:50
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     b12:	f8 94       	cli
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:239
      *_udr = c;
     b14:	ee 89       	ldd	r30, Y+22	; 0x16
     b16:	ff 89       	ldd	r31, Y+23	; 0x17
     b18:	60 83       	st	Z, r22
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:243
      #ifdef MPCM0
        *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
      #else
        *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
     b1a:	e8 89       	ldd	r30, Y+16	; 0x10
     b1c:	f9 89       	ldd	r31, Y+17	; 0x11
     b1e:	80 81       	ld	r24, Z
     b20:	82 74       	andi	r24, 0x42	; 66
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:271
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    *_ucsrb |= _BV(UDRIE0);
     b22:	80 83       	st	Z, r24
__iRestore():
c:\users\anthony\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/atomic.h:70
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     b24:	9f bf       	out	0x3f, r25	; 63
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:275
  }
  
  return 1;
}
     b26:	81 e0       	ldi	r24, 0x01	; 1
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	df 91       	pop	r29
     b2c:	cf 91       	pop	r28
     b2e:	1f 91       	pop	r17
     b30:	0f 91       	pop	r16
     b32:	ff 90       	pop	r15
     b34:	ef 90       	pop	r14
     b36:	08 95       	ret
     b38:	f6 2e       	mov	r15, r22
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:248
        *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
      #endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     b3a:	0b 8d       	ldd	r16, Y+27	; 0x1b
     b3c:	10 e0       	ldi	r17, 0x00	; 0
     b3e:	0f 5f       	subi	r16, 0xFF	; 255
     b40:	1f 4f       	sbci	r17, 0xFF	; 255
     b42:	0f 73       	andi	r16, 0x3F	; 63
     b44:	11 27       	eor	r17, r17
     b46:	e0 2e       	mov	r14, r16
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:252

  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     b48:	8c 8d       	ldd	r24, Y+28	; 0x1c
     b4a:	8e 11       	cpse	r24, r14
     b4c:	0c c0       	rjmp	.+24     	; 0xb66 <HardwareSerial::write(unsigned char)+0x7a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:253
    if (bit_is_clear(SREG, SREG_I)) {
     b4e:	0f b6       	in	r0, 0x3f	; 63
     b50:	07 fc       	sbrc	r0, 7
     b52:	fa cf       	rjmp	.-12     	; 0xb48 <HardwareSerial::write(unsigned char)+0x5c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:258
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     b54:	e8 89       	ldd	r30, Y+16	; 0x10
     b56:	f9 89       	ldd	r31, Y+17	; 0x11
     b58:	80 81       	ld	r24, Z
     b5a:	85 ff       	sbrs	r24, 5
     b5c:	f5 cf       	rjmp	.-22     	; 0xb48 <HardwareSerial::write(unsigned char)+0x5c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:259
        _tx_udr_empty_irq();
     b5e:	ce 01       	movw	r24, r28
     b60:	0e 94 55 05 	call	0xaaa	; 0xaaa <HardwareSerial::_tx_udr_empty_irq()>
     b64:	f1 cf       	rjmp	.-30     	; 0xb48 <HardwareSerial::write(unsigned char)+0x5c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:265
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     b66:	eb 8d       	ldd	r30, Y+27	; 0x1b
     b68:	ec 0f       	add	r30, r28
     b6a:	fd 2f       	mov	r31, r29
     b6c:	f1 1d       	adc	r31, r1
     b6e:	e3 5a       	subi	r30, 0xA3	; 163
     b70:	ff 4f       	sbci	r31, 0xFF	; 255
     b72:	f0 82       	st	Z, r15
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:269
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     b74:	9f b7       	in	r25, 0x3f	; 63
__iCliRetVal():
c:\users\anthony\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/atomic.h:50
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     b76:	f8 94       	cli
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:270
    _tx_buffer_head = i;
     b78:	0b 8f       	std	Y+27, r16	; 0x1b
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:271
    *_ucsrb |= _BV(UDRIE0);
     b7a:	ea 89       	ldd	r30, Y+18	; 0x12
     b7c:	fb 89       	ldd	r31, Y+19	; 0x13
     b7e:	80 81       	ld	r24, Z
     b80:	80 62       	ori	r24, 0x20	; 32
     b82:	cf cf       	rjmp	.-98     	; 0xb22 <HardwareSerial::write(unsigned char)+0x36>

00000b84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>:
print():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:44

size_t Print::print(const __FlashStringHelper *ifsh)
     b84:	0f 93       	push	r16
     b86:	1f 93       	push	r17
     b88:	cf 93       	push	r28
     b8a:	df 93       	push	r29
     b8c:	8c 01       	movw	r16, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:47
{
  PGM_P p = reinterpret_cast<PGM_P>(ifsh);
  size_t n = 0;
     b8e:	d0 e0       	ldi	r29, 0x00	; 0
     b90:	c0 e0       	ldi	r28, 0x00	; 0
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:49
  while (1) {
    unsigned char c = pgm_read_byte(p++);
     b92:	f8 01       	movw	r30, r16
     b94:	ec 0f       	add	r30, r28
     b96:	fd 1f       	adc	r31, r29
     b98:	64 91       	lpm	r22, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:50
    if (c == 0) break;
     b9a:	66 23       	and	r22, r22
     b9c:	41 f0       	breq	.+16     	; 0xbae <Print::print(__FlashStringHelper const*) [clone .constprop.54]+0x2a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:51
    if (write(c)) n++;
     b9e:	86 ea       	ldi	r24, 0xA6	; 166
     ba0:	92 e0       	ldi	r25, 0x02	; 2
     ba2:	0e 94 76 05 	call	0xaec	; 0xaec <HardwareSerial::write(unsigned char)>
     ba6:	89 2b       	or	r24, r25
     ba8:	11 f0       	breq	.+4      	; 0xbae <Print::print(__FlashStringHelper const*) [clone .constprop.54]+0x2a>
     baa:	21 96       	adiw	r28, 0x01	; 1
     bac:	f2 cf       	rjmp	.-28     	; 0xb92 <Print::print(__FlashStringHelper const*) [clone .constprop.54]+0xe>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:55
    else break;
  }
  return n;
}
     bae:	ce 01       	movw	r24, r28
     bb0:	df 91       	pop	r29
     bb2:	cf 91       	pop	r28
     bb4:	1f 91       	pop	r17
     bb6:	0f 91       	pop	r16
     bb8:	08 95       	ret

00000bba <HardwareSerial::flush()>:
flush():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:203
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     bba:	cf 93       	push	r28
     bbc:	df 93       	push	r29
     bbe:	ec 01       	movw	r28, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:207
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     bc0:	88 8d       	ldd	r24, Y+24	; 0x18
     bc2:	88 23       	and	r24, r24
     bc4:	b9 f0       	breq	.+46     	; 0xbf4 <HardwareSerial::flush()+0x3a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:210
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     bc6:	aa 89       	ldd	r26, Y+18	; 0x12
     bc8:	bb 89       	ldd	r27, Y+19	; 0x13
     bca:	e8 89       	ldd	r30, Y+16	; 0x10
     bcc:	f9 89       	ldd	r31, Y+17	; 0x11
     bce:	8c 91       	ld	r24, X
     bd0:	85 fd       	sbrc	r24, 5
     bd2:	03 c0       	rjmp	.+6      	; 0xbda <HardwareSerial::flush()+0x20>
     bd4:	80 81       	ld	r24, Z
     bd6:	86 fd       	sbrc	r24, 6
     bd8:	0d c0       	rjmp	.+26     	; 0xbf4 <HardwareSerial::flush()+0x3a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:211
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     bda:	0f b6       	in	r0, 0x3f	; 63
     bdc:	07 fc       	sbrc	r0, 7
     bde:	f7 cf       	rjmp	.-18     	; 0xbce <HardwareSerial::flush()+0x14>
     be0:	8c 91       	ld	r24, X
     be2:	85 ff       	sbrs	r24, 5
     be4:	f2 cf       	rjmp	.-28     	; 0xbca <HardwareSerial::flush()+0x10>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:215
      // Interrupts are globally disabled, but the DR empty
      // interrupt should be enabled, so poll the DR empty flag to
      // prevent deadlock
      if (bit_is_set(*_ucsra, UDRE0))
     be6:	80 81       	ld	r24, Z
     be8:	85 ff       	sbrs	r24, 5
     bea:	ed cf       	rjmp	.-38     	; 0xbc6 <HardwareSerial::flush()+0xc>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:216
        _tx_udr_empty_irq();
     bec:	ce 01       	movw	r24, r28
     bee:	0e 94 55 05 	call	0xaaa	; 0xaaa <HardwareSerial::_tx_udr_empty_irq()>
     bf2:	e9 cf       	rjmp	.-46     	; 0xbc6 <HardwareSerial::flush()+0xc>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:220
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     bf4:	df 91       	pop	r29
     bf6:	cf 91       	pop	r28
     bf8:	08 95       	ret

00000bfa <turnOffPWM>:
turnOffPWM():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:77
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
  switch (timer)
     bfa:	84 30       	cpi	r24, 0x04	; 4
     bfc:	59 f0       	breq	.+22     	; 0xc14 <turnOffPWM+0x1a>
     bfe:	28 f4       	brcc	.+10     	; 0xc0a <turnOffPWM+0x10>
     c00:	81 30       	cpi	r24, 0x01	; 1
     c02:	99 f0       	breq	.+38     	; 0xc2a <turnOffPWM+0x30>
     c04:	82 30       	cpi	r24, 0x02	; 2
     c06:	89 f0       	breq	.+34     	; 0xc2a <turnOffPWM+0x30>
     c08:	08 95       	ret
     c0a:	85 30       	cpi	r24, 0x05	; 5
     c0c:	39 f0       	breq	.+14     	; 0xc1c <turnOffPWM+0x22>
     c0e:	87 30       	cpi	r24, 0x07	; 7
     c10:	41 f0       	breq	.+16     	; 0xc22 <turnOffPWM+0x28>
     c12:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:82
  {
    // Timer1
    #if defined(TCCR1A) && defined(COM1A1)
      case TIMER1A:
        TCCR1A &= ~_BV(COM1A1);
     c14:	8f b5       	in	r24, 0x2f	; 47
     c16:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:87
        break;
    #endif
    #if defined(TCCR1A) && defined(COM1B1)
      case TIMER1B:
        TCCR1A &= ~_BV(COM1B1);
     c18:	8f bd       	out	0x2f, r24	; 47
     c1a:	08 95       	ret
     c1c:	8f b5       	in	r24, 0x2f	; 47
     c1e:	8f 7d       	andi	r24, 0xDF	; 223
     c20:	fb cf       	rjmp	.-10     	; 0xc18 <turnOffPWM+0x1e>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:99
    #endif
    
    // Timer2
    #if defined(TCCR2) && defined(COM21)
      case TIMER2:
        TCCR2 &= ~_BV(COM21);
     c22:	85 b5       	in	r24, 0x25	; 37
     c24:	8f 7d       	andi	r24, 0xDF	; 223
     c26:	85 bd       	out	0x25, r24	; 37
     c28:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:171
    #if defined(TCCR0) && defined(COM01)
      case TIMER0:
        TCCR0 &= ~_BV(COM01);
        break;
      case TIMER0A:
        TCCR0 &= ~_BV(COM01);
     c2a:	83 b7       	in	r24, 0x33	; 51
     c2c:	8f 7d       	andi	r24, 0xDF	; 223
     c2e:	83 bf       	out	0x33, r24	; 51
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:185
      case TIMER0B:
        TCCR0A &= ~_BV(COM0B1);
        break;
    #endif
  }
}
     c30:	08 95       	ret

00000c32 <digitalRead>:
digitalRead():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:215

  SREG = oldSREG;
}

int digitalRead(uint8_t pin)
{
     c32:	cf 93       	push	r28
     c34:	df 93       	push	r29
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:216
  uint8_t timer = digitalPinToTimer(pin);
     c36:	28 2f       	mov	r18, r24
     c38:	30 e0       	ldi	r19, 0x00	; 0
     c3a:	f9 01       	movw	r30, r18
     c3c:	e7 53       	subi	r30, 0x37	; 55
     c3e:	fc 4f       	sbci	r31, 0xFC	; 252
     c40:	84 91       	lpm	r24, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:217
  uint8_t bit = digitalPinToBitMask(pin);
     c42:	f9 01       	movw	r30, r18
     c44:	e7 55       	subi	r30, 0x57	; 87
     c46:	fc 4f       	sbci	r31, 0xFC	; 252
     c48:	d4 91       	lpm	r29, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:218
  uint8_t port = digitalPinToPort(pin);
     c4a:	f9 01       	movw	r30, r18
     c4c:	e7 57       	subi	r30, 0x77	; 119
     c4e:	fc 4f       	sbci	r31, 0xFC	; 252
     c50:	c4 91       	lpm	r28, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:220

  if (port == NOT_A_PIN) return LOW;
     c52:	cc 23       	and	r28, r28
     c54:	a1 f0       	breq	.+40     	; 0xc7e <digitalRead+0x4c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:224

  // If the pin that support PWM output, we need to turn it off
  // before getting a digital reading.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     c56:	81 11       	cpse	r24, r1
     c58:	0e 94 fd 05 	call	0xbfa	; 0xbfa <turnOffPWM>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:226

  if (*portInputRegister(port) & bit) return HIGH;
     c5c:	ec 2f       	mov	r30, r28
     c5e:	f0 e0       	ldi	r31, 0x00	; 0
     c60:	ee 0f       	add	r30, r30
     c62:	ff 1f       	adc	r31, r31
     c64:	e1 58       	subi	r30, 0x81	; 129
     c66:	fc 4f       	sbci	r31, 0xFC	; 252
     c68:	a5 91       	lpm	r26, Z+
     c6a:	b4 91       	lpm	r27, Z
     c6c:	ec 91       	ld	r30, X
     c6e:	ed 23       	and	r30, r29
     c70:	81 e0       	ldi	r24, 0x01	; 1
     c72:	90 e0       	ldi	r25, 0x00	; 0
     c74:	09 f4       	brne	.+2      	; 0xc78 <digitalRead+0x46>
     c76:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:228
  return LOW;
}
     c78:	df 91       	pop	r29
     c7a:	cf 91       	pop	r28
     c7c:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:220
{
  uint8_t timer = digitalPinToTimer(pin);
  uint8_t bit = digitalPinToBitMask(pin);
  uint8_t port = digitalPinToPort(pin);

  if (port == NOT_A_PIN) return LOW;
     c7e:	80 e0       	ldi	r24, 0x00	; 0
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	fa cf       	rjmp	.-12     	; 0xc78 <digitalRead+0x46>

00000c84 <digitalWrite>:
digitalWrite():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:188
    #endif
  }
}

void digitalWrite(uint8_t pin, uint8_t val)
{
     c84:	1f 93       	push	r17
     c86:	cf 93       	push	r28
     c88:	df 93       	push	r29
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:189
  uint8_t timer = digitalPinToTimer(pin);
     c8a:	28 2f       	mov	r18, r24
     c8c:	30 e0       	ldi	r19, 0x00	; 0
     c8e:	f9 01       	movw	r30, r18
     c90:	e7 53       	subi	r30, 0x37	; 55
     c92:	fc 4f       	sbci	r31, 0xFC	; 252
     c94:	84 91       	lpm	r24, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:190
  uint8_t bit = digitalPinToBitMask(pin);
     c96:	f9 01       	movw	r30, r18
     c98:	e7 55       	subi	r30, 0x57	; 87
     c9a:	fc 4f       	sbci	r31, 0xFC	; 252
     c9c:	d4 91       	lpm	r29, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:191
  uint8_t port = digitalPinToPort(pin);
     c9e:	f9 01       	movw	r30, r18
     ca0:	e7 57       	subi	r30, 0x77	; 119
     ca2:	fc 4f       	sbci	r31, 0xFC	; 252
     ca4:	c4 91       	lpm	r28, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:194
  volatile uint8_t *out;

  if (port == NOT_A_PIN) return;
     ca6:	cc 23       	and	r28, r28
     ca8:	a9 f0       	breq	.+42     	; 0xcd4 <digitalWrite+0x50>
     caa:	16 2f       	mov	r17, r22
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:198

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     cac:	81 11       	cpse	r24, r1
     cae:	0e 94 fd 05 	call	0xbfa	; 0xbfa <turnOffPWM>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:200

  out = portOutputRegister(port);
     cb2:	ec 2f       	mov	r30, r28
     cb4:	f0 e0       	ldi	r31, 0x00	; 0
     cb6:	ee 0f       	add	r30, r30
     cb8:	ff 1f       	adc	r31, r31
     cba:	eb 58       	subi	r30, 0x8B	; 139
     cbc:	fc 4f       	sbci	r31, 0xFC	; 252
     cbe:	a5 91       	lpm	r26, Z+
     cc0:	b4 91       	lpm	r27, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:202

  uint8_t oldSREG = SREG;
     cc2:	8f b7       	in	r24, 0x3f	; 63
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:203
  cli();
     cc4:	f8 94       	cli
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:206

  if (val == LOW) {
    *out &= ~bit;
     cc6:	ec 91       	ld	r30, X
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:205
  out = portOutputRegister(port);

  uint8_t oldSREG = SREG;
  cli();

  if (val == LOW) {
     cc8:	11 11       	cpse	r17, r1
     cca:	08 c0       	rjmp	.+16     	; 0xcdc <digitalWrite+0x58>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:206
    *out &= ~bit;
     ccc:	d0 95       	com	r29
     cce:	de 23       	and	r29, r30
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:208
  } else {
    *out |= bit;
     cd0:	dc 93       	st	X, r29
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:211
  }

  SREG = oldSREG;
     cd2:	8f bf       	out	0x3f, r24	; 63
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:212
}
     cd4:	df 91       	pop	r29
     cd6:	cf 91       	pop	r28
     cd8:	1f 91       	pop	r17
     cda:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:208
  cli();

  if (val == LOW) {
    *out &= ~bit;
  } else {
    *out |= bit;
     cdc:	de 2b       	or	r29, r30
     cde:	f8 cf       	rjmp	.-16     	; 0xcd0 <digitalWrite+0x4c>

00000ce0 <TwoWire::begin() [clone .constprop.6]>:
begin():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:61

// Public Methods //////////////////////////////////////////////////////////////

void TwoWire::begin(void)
{
  rxBufferIndex = 0;
     ce0:	10 92 24 02 	sts	0x0224, r1	; 0x800224 <TwoWire::rxBufferIndex>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:62
  rxBufferLength = 0;
     ce4:	10 92 23 02 	sts	0x0223, r1	; 0x800223 <TwoWire::rxBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:64

  txBufferIndex = 0;
     ce8:	10 92 32 02 	sts	0x0232, r1	; 0x800232 <TwoWire::txBufferIndex>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:65
  txBufferLength = 0;
     cec:	10 92 54 02 	sts	0x0254, r1	; 0x800254 <TwoWire::txBufferLength>
twi_init():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:84
 * Output   none
 */
void twi_init(void)
{
  // initialize state
  twi_state = TWI_READY;
     cf0:	10 92 30 02 	sts	0x0230, r1	; 0x800230 <twi_state>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:85
  twi_sendStop = true; // default value
     cf4:	81 e0       	ldi	r24, 0x01	; 1
     cf6:	80 93 2f 02 	sts	0x022F, r24	; 0x80022f <twi_sendStop>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:86
  twi_inRepStart = false;
     cfa:	10 92 28 02 	sts	0x0228, r1	; 0x800228 <twi_inRepStart>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:89

  // activate internal pullups for twi.
  digitalWrite(SDA, 1);
     cfe:	61 e0       	ldi	r22, 0x01	; 1
     d00:	81 e1       	ldi	r24, 0x11	; 17
     d02:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:90
  digitalWrite(SCL, 1);
     d06:	61 e0       	ldi	r22, 0x01	; 1
     d08:	80 e1       	ldi	r24, 0x10	; 16
     d0a:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:93

  // initialize twi prescaler and bit rate
  cbi(TWSR, TWPS0);
     d0e:	08 98       	cbi	0x01, 0	; 1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:94
  cbi(TWSR, TWPS1);
     d10:	09 98       	cbi	0x01, 1	; 1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:95
  TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;
     d12:	88 e4       	ldi	r24, 0x48	; 72
     d14:	80 b9       	out	0x00, r24	; 0
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:103
  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))
  note: TWBR should be 10 or higher for master mode
  It is 72 for a 16mhz Wiring board with 100kHz TWI */

  // enable twi module, acks, and twi interrupt
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);
     d16:	85 e4       	ldi	r24, 0x45	; 69
     d18:	86 bf       	out	0x36, r24	; 54
twi_attachSlaveTxEvent():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:408
 * Input    function: callback function to use
 * Output   none
 */
void twi_attachSlaveTxEvent( void (*function)(void) )
{
  twi_onSlaveTransmit = function;
     d1a:	8f ed       	ldi	r24, 0xDF	; 223
     d1c:	94 e0       	ldi	r25, 0x04	; 4
     d1e:	90 93 fe 01 	sts	0x01FE, r25	; 0x8001fe <twi_onSlaveTransmit+0x1>
     d22:	80 93 fd 01 	sts	0x01FD, r24	; 0x8001fd <twi_onSlaveTransmit>
twi_attachSlaveRxEvent():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:397
 * Input    function: callback function to use
 * Output   none
 */
void twi_attachSlaveRxEvent( void (*function)(uint8_t*, int) )
{
  twi_onSlaveReceive = function;
     d26:	80 ee       	ldi	r24, 0xE0	; 224
     d28:	94 e0       	ldi	r25, 0x04	; 4
     d2a:	90 93 fc 01 	sts	0x01FC, r25	; 0x8001fc <twi_onSlaveReceive+0x1>
     d2e:	80 93 fb 01 	sts	0x01FB, r24	; 0x8001fb <twi_onSlaveReceive>
begin():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:70

  twi_init();
  twi_attachSlaveTxEvent(onRequestService); // default callback must exist
  twi_attachSlaveRxEvent(onReceiveService); // default callback must exist
}
     d32:	08 95       	ret

00000d34 <pinMode>:
pinMode():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:30
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
     d34:	cf 93       	push	r28
     d36:	df 93       	push	r29
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:31
  uint8_t bit = digitalPinToBitMask(pin);
     d38:	90 e0       	ldi	r25, 0x00	; 0
     d3a:	fc 01       	movw	r30, r24
     d3c:	e7 55       	subi	r30, 0x57	; 87
     d3e:	fc 4f       	sbci	r31, 0xFC	; 252
     d40:	24 91       	lpm	r18, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:32
  uint8_t port = digitalPinToPort(pin);
     d42:	87 57       	subi	r24, 0x77	; 119
     d44:	9c 4f       	sbci	r25, 0xFC	; 252
     d46:	fc 01       	movw	r30, r24
     d48:	84 91       	lpm	r24, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:35
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
     d4a:	88 23       	and	r24, r24
     d4c:	c9 f0       	breq	.+50     	; 0xd80 <pinMode+0x4c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:38

  // JWS: can I let the optimizer do this?
  reg = portModeRegister(port);
     d4e:	90 e0       	ldi	r25, 0x00	; 0
     d50:	88 0f       	add	r24, r24
     d52:	99 1f       	adc	r25, r25
     d54:	fc 01       	movw	r30, r24
     d56:	e5 59       	subi	r30, 0x95	; 149
     d58:	fc 4f       	sbci	r31, 0xFC	; 252
     d5a:	a5 91       	lpm	r26, Z+
     d5c:	b4 91       	lpm	r27, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:39
  out = portOutputRegister(port);
     d5e:	fc 01       	movw	r30, r24
     d60:	eb 58       	subi	r30, 0x8B	; 139
     d62:	fc 4f       	sbci	r31, 0xFC	; 252
     d64:	c5 91       	lpm	r28, Z+
     d66:	d4 91       	lpm	r29, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:41

  if (mode == INPUT) { 
     d68:	61 11       	cpse	r22, r1
     d6a:	0d c0       	rjmp	.+26     	; 0xd86 <pinMode+0x52>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:42
    uint8_t oldSREG = SREG;
     d6c:	9f b7       	in	r25, 0x3f	; 63
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:43
    cli();
     d6e:	f8 94       	cli
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:44
    *reg &= ~bit;
     d70:	8c 91       	ld	r24, X
     d72:	20 95       	com	r18
     d74:	82 23       	and	r24, r18
     d76:	8c 93       	st	X, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:45
    *out &= ~bit;
     d78:	88 81       	ld	r24, Y
     d7a:	28 23       	and	r18, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:51
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
    uint8_t oldSREG = SREG;
    cli();
    *reg &= ~bit;
    *out |= bit;
     d7c:	28 83       	st	Y, r18
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:52
    SREG = oldSREG;
     d7e:	9f bf       	out	0x3f, r25	; 63
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:59
    uint8_t oldSREG = SREG;
    cli();
    *reg |= bit;
    SREG = oldSREG;
  }
}
     d80:	df 91       	pop	r29
     d82:	cf 91       	pop	r28
     d84:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:47
    uint8_t oldSREG = SREG;
    cli();
    *reg &= ~bit;
    *out &= ~bit;
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
     d86:	62 30       	cpi	r22, 0x02	; 2
     d88:	51 f4       	brne	.+20     	; 0xd9e <pinMode+0x6a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:48
    uint8_t oldSREG = SREG;
     d8a:	9f b7       	in	r25, 0x3f	; 63
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:49
    cli();
     d8c:	f8 94       	cli
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:50
    *reg &= ~bit;
     d8e:	3c 91       	ld	r19, X
     d90:	82 2f       	mov	r24, r18
     d92:	80 95       	com	r24
     d94:	83 23       	and	r24, r19
     d96:	8c 93       	st	X, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:51
    *out |= bit;
     d98:	e8 81       	ld	r30, Y
     d9a:	2e 2b       	or	r18, r30
     d9c:	ef cf       	rjmp	.-34     	; 0xd7c <pinMode+0x48>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:54
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
     d9e:	8f b7       	in	r24, 0x3f	; 63
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:55
    cli();
     da0:	f8 94       	cli
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:56
    *reg |= bit;
     da2:	ec 91       	ld	r30, X
     da4:	2e 2b       	or	r18, r30
     da6:	2c 93       	st	X, r18
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring_digital.c:57
    SREG = oldSREG;
     da8:	8f bf       	out	0x3f, r24	; 63
     daa:	ea cf       	rjmp	.-44     	; 0xd80 <pinMode+0x4c>

00000dac <delayMicroseconds>:
delayMicroseconds():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:619
  us -= 7; // = 2 cycles

#elif F_CPU >= 16000000L
  // for a one-microsecond delay, simply return.  the overhead
  // of the function call takes 14 (16) cycles, which is 1 us
  if (us <= 1) return; //  = 3 cycles, (4 when true)
     dac:	81 30       	cpi	r24, 0x01	; 1
     dae:	91 05       	cpc	r25, r1
     db0:	39 f0       	breq	.+14     	; 0xdc0 <delayMicroseconds+0x14>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:624

  // the following loop takes 1/4 of a microsecond (4 cycles)
  // per iteration, so execute it four times for each microsecond of
  // delay requested.
  us <<= 2; // x4 us, = 4 cycles
     db2:	88 0f       	add	r24, r24
     db4:	99 1f       	adc	r25, r25
     db6:	88 0f       	add	r24, r24
     db8:	99 1f       	adc	r25, r25
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:629

  // account for the time taken in the preceeding commands.
  // we just burned 19 (21) cycles above, remove 5, (5*4=20)
  // to 2nd us is at least 8 so we can substract 5
  us -= 5; // = 2 cycles,
     dba:	05 97       	sbiw	r24, 0x05	; 5
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:929
  us >>= 2; // us div 4, = 4 cycles

#endif

  // busy wait
  __asm__ __volatile__ (
     dbc:	01 97       	sbiw	r24, 0x01	; 1
     dbe:	f1 f7       	brne	.-4      	; 0xdbc <delayMicroseconds+0x10>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:939
    "   brne 1b"                     // 2 cycles
    : /* no outputs */
    : "w" (us)
  );
  // return = 4 cycles
}
     dc0:	08 95       	ret

00000dc2 <micros>:
micros():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:237
  unsigned char f; // temporary storage for millis fraction counter
  unsigned char q = 0; // record whether an overflow is flagged
#endif
  // t will be the number where the timer0 counter stopped
  uint8_t t;
  uint8_t oldSREG = SREG;
     dc2:	3f b7       	in	r19, 0x3f	; 63
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:240

  // Stop all interrupts
  cli();
     dc4:	f8 94       	cli
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:247
#ifdef CORRECT_EXACT_MICROS
  // combine exact millisec and 8usec counters
  m = timer0_millis;
  f = timer0_fract;
#else
  m = timer0_overflow_count;
     dc6:	80 91 be 01 	lds	r24, 0x01BE	; 0x8001be <timer0_overflow_count>
     dca:	90 91 bf 01 	lds	r25, 0x01BF	; 0x8001bf <timer0_overflow_count+0x1>
     dce:	a0 91 c0 01 	lds	r26, 0x01C0	; 0x8001c0 <timer0_overflow_count+0x2>
     dd2:	b0 91 c1 01 	lds	r27, 0x01C1	; 0x8001c1 <timer0_overflow_count+0x3>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:252
#endif

  // TCNT0 : The Timer Counter Register
#if defined(TCNT0)
  t = TCNT0;
     dd6:	22 b7       	in	r18, 0x32	; 50
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:268
    m++;
#else
    q = 1;
#endif
#else
  if ((TIFR & _BV(TOV0)) && (t < 255))
     dd8:	08 b6       	in	r0, 0x38	; 56
     dda:	00 fe       	sbrs	r0, 0
     ddc:	05 c0       	rjmp	.+10     	; 0xde8 <micros+0x26>
     dde:	2f 3f       	cpi	r18, 0xFF	; 255
     de0:	19 f0       	breq	.+6      	; 0xde8 <micros+0x26>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:270
#ifndef CORRECT_EXACT_MICROS
    m++;
     de2:	01 96       	adiw	r24, 0x01	; 1
     de4:	a1 1d       	adc	r26, r1
     de6:	b1 1d       	adc	r27, r1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:276
#else
    q = 1;
#endif
#endif
  // Restore SREG
  SREG = oldSREG;
     de8:	3f bf       	out	0x3f, r19	; 63
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:292
      ((t * MICROSECONDS_PER_TIMER0_OVERFLOW) >> 8);
  return q ? m + MICROSECONDS_PER_TIMER0_OVERFLOW : m;
#elif 1
  /* All power-of-two Megahertz frequencies enter here, as well as 12.8 MHz.
     We only end up here if right shift before multiplication is exact. */
  return ((m << 8) + t) * (MICROSECONDS_PER_TIMER0_OVERFLOW >> 8);
     dea:	ba 2f       	mov	r27, r26
     dec:	a9 2f       	mov	r26, r25
     dee:	98 2f       	mov	r25, r24
     df0:	88 27       	eor	r24, r24
     df2:	bc 01       	movw	r22, r24
     df4:	cd 01       	movw	r24, r26
     df6:	62 0f       	add	r22, r18
     df8:	71 1d       	adc	r23, r1
     dfa:	81 1d       	adc	r24, r1
     dfc:	91 1d       	adc	r25, r1
     dfe:	42 e0       	ldi	r20, 0x02	; 2
     e00:	66 0f       	add	r22, r22
     e02:	77 1f       	adc	r23, r23
     e04:	88 1f       	adc	r24, r24
     e06:	99 1f       	adc	r25, r25
     e08:	4a 95       	dec	r20
     e0a:	d1 f7       	brne	.-12     	; 0xe00 <micros+0x3e>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:393
  // m & t are multiplied by 4 (since it was already multiplied by 256)
  // t is multiplied by 4
  return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
#endif
#endif // 0
}
     e0c:	08 95       	ret

00000e0e <delay>:
delay():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:396

void delay(unsigned long ms)
{
     e0e:	8f 92       	push	r8
     e10:	9f 92       	push	r9
     e12:	af 92       	push	r10
     e14:	bf 92       	push	r11
     e16:	cf 92       	push	r12
     e18:	df 92       	push	r13
     e1a:	ef 92       	push	r14
     e1c:	ff 92       	push	r15
     e1e:	4b 01       	movw	r8, r22
     e20:	5c 01       	movw	r10, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:397
  unsigned long start = micros();
     e22:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <micros>
     e26:	6b 01       	movw	r12, r22
     e28:	7c 01       	movw	r14, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:401

  while (ms > 0UL) {
    yield();
    while (ms > 0UL && (micros() - start) >= 1000UL) {
     e2a:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <micros>
     e2e:	6c 19       	sub	r22, r12
     e30:	7d 09       	sbc	r23, r13
     e32:	8e 09       	sbc	r24, r14
     e34:	9f 09       	sbc	r25, r15
     e36:	68 3e       	cpi	r22, 0xE8	; 232
     e38:	73 40       	sbci	r23, 0x03	; 3
     e3a:	81 05       	cpc	r24, r1
     e3c:	91 05       	cpc	r25, r1
     e3e:	a8 f3       	brcs	.-22     	; 0xe2a <delay+0x1c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:402
      ms--;
     e40:	21 e0       	ldi	r18, 0x01	; 1
     e42:	82 1a       	sub	r8, r18
     e44:	91 08       	sbc	r9, r1
     e46:	a1 08       	sbc	r10, r1
     e48:	b1 08       	sbc	r11, r1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:403
      start += 1000UL;
     e4a:	88 ee       	ldi	r24, 0xE8	; 232
     e4c:	c8 0e       	add	r12, r24
     e4e:	83 e0       	ldi	r24, 0x03	; 3
     e50:	d8 1e       	adc	r13, r24
     e52:	e1 1c       	adc	r14, r1
     e54:	f1 1c       	adc	r15, r1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:401
{
  unsigned long start = micros();

  while (ms > 0UL) {
    yield();
    while (ms > 0UL && (micros() - start) >= 1000UL) {
     e56:	81 14       	cp	r8, r1
     e58:	91 04       	cpc	r9, r1
     e5a:	a1 04       	cpc	r10, r1
     e5c:	b1 04       	cpc	r11, r1
     e5e:	29 f7       	brne	.-54     	; 0xe2a <delay+0x1c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:406
      ms--;
      start += 1000UL;
    }
  }
}
     e60:	ff 90       	pop	r15
     e62:	ef 90       	pop	r14
     e64:	df 90       	pop	r13
     e66:	cf 90       	pop	r12
     e68:	bf 90       	pop	r11
     e6a:	af 90       	pop	r10
     e6c:	9f 90       	pop	r9
     e6e:	8f 90       	pop	r8
     e70:	08 95       	ret

00000e72 <millis>:
millis():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:218
}

unsigned long millis()
{
  unsigned long m;
  uint8_t oldSREG = SREG;
     e72:	2f b7       	in	r18, 0x3f	; 63
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:222

  // disable interrupts while we read timer0_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to timer0_millis)
  cli();
     e74:	f8 94       	cli
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:223
  m = timer0_millis;
     e76:	60 91 ba 01 	lds	r22, 0x01BA	; 0x8001ba <timer0_millis>
     e7a:	70 91 bb 01 	lds	r23, 0x01BB	; 0x8001bb <timer0_millis+0x1>
     e7e:	80 91 bc 01 	lds	r24, 0x01BC	; 0x8001bc <timer0_millis+0x2>
     e82:	90 91 bd 01 	lds	r25, 0x01BD	; 0x8001bd <timer0_millis+0x3>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:224
  SREG = oldSREG;
     e86:	2f bf       	out	0x3f, r18	; 63
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:227

  return m;
}
     e88:	08 95       	ret

00000e8a <Print::flush()>:
flush():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.h:65

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }

    virtual void flush() { /* Empty implementation for backward compatibility */ }
     e8a:	08 95       	ret

00000e8c <twi_stop>:
twi_stop():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:436
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
     e8c:	85 ed       	ldi	r24, 0xD5	; 213
     e8e:	86 bf       	out	0x36, r24	; 54
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:456
          return;
        }
      }
    }
  #else
    while(TWCR & _BV(TWSTO)){
     e90:	06 b6       	in	r0, 0x36	; 54
     e92:	04 fc       	sbrc	r0, 4
     e94:	fd cf       	rjmp	.-6      	; 0xe90 <twi_stop+0x4>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:462
      continue;
    }
  #endif

  // update twi state
  twi_state = TWI_READY;
     e96:	10 92 30 02 	sts	0x0230, r1	; 0x800230 <twi_state>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:463
}
     e9a:	08 95       	ret

00000e9c <twi_transmit>:
twi_transmit():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:371
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_SIZE < (twi_txBufferLength+length)){
     e9c:	20 91 96 01 	lds	r18, 0x0196	; 0x800196 <twi_txBufferLength>
     ea0:	26 0f       	add	r18, r22
     ea2:	33 27       	eor	r19, r19
     ea4:	33 1f       	adc	r19, r19
     ea6:	21 32       	cpi	r18, 0x21	; 33
     ea8:	31 05       	cpc	r19, r1
     eaa:	ec f4       	brge	.+58     	; 0xee6 <twi_transmit+0x4a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:376
    return 1;
  }

  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
     eac:	20 91 30 02 	lds	r18, 0x0230	; 0x800230 <twi_state>
     eb0:	fc 01       	movw	r30, r24
     eb2:	90 e0       	ldi	r25, 0x00	; 0
     eb4:	80 e0       	ldi	r24, 0x00	; 0
     eb6:	24 30       	cpi	r18, 0x04	; 4
     eb8:	69 f0       	breq	.+26     	; 0xed4 <twi_transmit+0x38>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:377
    return 2;
     eba:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:387
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;

  return 0;
}
     ebc:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:382
    return 2;
  }

  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
    twi_txBuffer[twi_txBufferLength+i] = data[i];
     ebe:	a0 91 96 01 	lds	r26, 0x0196	; 0x800196 <twi_txBufferLength>
     ec2:	21 91       	ld	r18, Z+
     ec4:	ac 01       	movw	r20, r24
     ec6:	4a 58       	subi	r20, 0x8A	; 138
     ec8:	5e 4f       	sbci	r21, 0xFE	; 254
     eca:	a4 0f       	add	r26, r20
     ecc:	b5 2f       	mov	r27, r21
     ece:	b1 1d       	adc	r27, r1
     ed0:	2c 93       	st	X, r18
     ed2:	01 96       	adiw	r24, 0x01	; 1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:381
  if(TWI_STX != twi_state){
    return 2;
  }

  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
     ed4:	86 17       	cp	r24, r22
     ed6:	98 f3       	brcs	.-26     	; 0xebe <twi_transmit+0x22>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:384
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;
     ed8:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <twi_txBufferLength>
     edc:	68 0f       	add	r22, r24
     ede:	60 93 96 01 	sts	0x0196, r22	; 0x800196 <twi_txBufferLength>
     ee2:	80 e0       	ldi	r24, 0x00	; 0
     ee4:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:372
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_SIZE < (twi_txBufferLength+length)){
    return 1;
     ee6:	81 e0       	ldi	r24, 0x01	; 1
     ee8:	08 95       	ret

00000eea <TwoWire::flush()>:
flush():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:326
}

void TwoWire::flush(void)
{
  // XXX: to be implemented.
}
     eea:	08 95       	ret

00000eec <TwoWire::peek()>:
peek():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:316
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  int value = -1;

  if(rxBufferIndex < rxBufferLength){
     eec:	e0 91 24 02 	lds	r30, 0x0224	; 0x800224 <TwoWire::rxBufferIndex>
     ef0:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <TwoWire::rxBufferLength>
     ef4:	e8 17       	cp	r30, r24
     ef6:	30 f4       	brcc	.+12     	; 0xf04 <TwoWire::peek()+0x18>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:317
    value = rxBuffer[rxBufferIndex];
     ef8:	f0 e0       	ldi	r31, 0x00	; 0
     efa:	ed 5f       	subi	r30, 0xFD	; 253
     efc:	fd 4f       	sbci	r31, 0xFD	; 253
     efe:	80 81       	ld	r24, Z
     f00:	90 e0       	ldi	r25, 0x00	; 0
     f02:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:314
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  int value = -1;
     f04:	8f ef       	ldi	r24, 0xFF	; 255
     f06:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:321
  if(rxBufferIndex < rxBufferLength){
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
     f08:	08 95       	ret

00000f0a <TwoWire::available()>:
available():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:290
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return rxBufferLength - rxBufferIndex;
     f0a:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <TwoWire::rxBufferLength>
     f0e:	90 91 24 02 	lds	r25, 0x0224	; 0x800224 <TwoWire::rxBufferIndex>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:291
}
     f12:	89 1b       	sub	r24, r25
     f14:	99 0b       	sbc	r25, r25
     f16:	08 95       	ret

00000f18 <TwoWire::write(unsigned char const*, unsigned int)>:
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:271

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
     f18:	cf 92       	push	r12
     f1a:	df 92       	push	r13
     f1c:	ef 92       	push	r14
     f1e:	ff 92       	push	r15
     f20:	0f 93       	push	r16
     f22:	1f 93       	push	r17
     f24:	cf 93       	push	r28
     f26:	df 93       	push	r29
     f28:	7c 01       	movw	r14, r24
     f2a:	cb 01       	movw	r24, r22
     f2c:	8a 01       	movw	r16, r20
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:272
  if(transmitting){
     f2e:	20 91 31 02 	lds	r18, 0x0231	; 0x800231 <TwoWire::transmitting>
     f32:	22 23       	and	r18, r18
     f34:	89 f0       	breq	.+34     	; 0xf58 <TwoWire::write(unsigned char const*, unsigned int)+0x40>
     f36:	eb 01       	movw	r28, r22
     f38:	6b 01       	movw	r12, r22
     f3a:	c4 0e       	add	r12, r20
     f3c:	d5 1e       	adc	r13, r21
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:274
  // in master transmitter mode
    for(size_t i = 0; i < quantity; ++i){
     f3e:	cc 15       	cp	r28, r12
     f40:	dd 05       	cpc	r29, r13
     f42:	69 f0       	breq	.+26     	; 0xf5e <TwoWire::write(unsigned char const*, unsigned int)+0x46>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:275
      write(data[i]);
     f44:	69 91       	ld	r22, Y+
     f46:	d7 01       	movw	r26, r14
     f48:	ed 91       	ld	r30, X+
     f4a:	fc 91       	ld	r31, X
     f4c:	01 90       	ld	r0, Z+
     f4e:	f0 81       	ld	r31, Z
     f50:	e0 2d       	mov	r30, r0
     f52:	c7 01       	movw	r24, r14
     f54:	09 95       	icall
     f56:	f3 cf       	rjmp	.-26     	; 0xf3e <TwoWire::write(unsigned char const*, unsigned int)+0x26>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:280
    }
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(data, quantity);
     f58:	64 2f       	mov	r22, r20
     f5a:	0e 94 4e 07 	call	0xe9c	; 0xe9c <twi_transmit>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:283
  }
  return quantity;
}
     f5e:	c8 01       	movw	r24, r16
     f60:	df 91       	pop	r29
     f62:	cf 91       	pop	r28
     f64:	1f 91       	pop	r17
     f66:	0f 91       	pop	r16
     f68:	ff 90       	pop	r15
     f6a:	ef 90       	pop	r14
     f6c:	df 90       	pop	r13
     f6e:	cf 90       	pop	r12
     f70:	08 95       	ret

00000f72 <TwoWire::write(unsigned char)>:
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:246

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
     f72:	cf 93       	push	r28
     f74:	df 93       	push	r29
     f76:	1f 92       	push	r1
     f78:	cd b7       	in	r28, 0x3d	; 61
     f7a:	de b7       	in	r29, 0x3e	; 62
     f7c:	69 83       	std	Y+1, r22	; 0x01
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:247
  if(transmitting){
     f7e:	20 91 31 02 	lds	r18, 0x0231	; 0x800231 <TwoWire::transmitting>
     f82:	22 23       	and	r18, r18
     f84:	f9 f0       	breq	.+62     	; 0xfc4 <TwoWire::write(unsigned char)+0x52>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:250
  // in master transmitter mode
    // don't bother if buffer is full
    if(txBufferLength >= TWI_BUFFER_SIZE){
     f86:	20 91 54 02 	lds	r18, 0x0254	; 0x800254 <TwoWire::txBufferLength>
     f8a:	20 32       	cpi	r18, 0x20	; 32
     f8c:	58 f0       	brcs	.+22     	; 0xfa4 <TwoWire::write(unsigned char)+0x32>
_ZN5Print13setWriteErrorEi():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.h:44
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
     f8e:	21 e0       	ldi	r18, 0x01	; 1
     f90:	30 e0       	ldi	r19, 0x00	; 0
     f92:	fc 01       	movw	r30, r24
     f94:	33 83       	std	Z+3, r19	; 0x03
     f96:	22 83       	std	Z+2, r18	; 0x02
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:252
      setWriteError();
      return 0;
     f98:	90 e0       	ldi	r25, 0x00	; 0
     f9a:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:265
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
  }
  return 1;
}
     f9c:	0f 90       	pop	r0
     f9e:	df 91       	pop	r29
     fa0:	cf 91       	pop	r28
     fa2:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:255
    if(txBufferLength >= TWI_BUFFER_SIZE){
      setWriteError();
      return 0;
    }
    // put byte in tx buffer
    txBuffer[txBufferIndex] = data;
     fa4:	80 91 32 02 	lds	r24, 0x0232	; 0x800232 <TwoWire::txBufferIndex>
     fa8:	e8 2f       	mov	r30, r24
     faa:	f0 e0       	ldi	r31, 0x00	; 0
     fac:	ed 5c       	subi	r30, 0xCD	; 205
     fae:	fd 4f       	sbci	r31, 0xFD	; 253
     fb0:	99 81       	ldd	r25, Y+1	; 0x01
     fb2:	90 83       	st	Z, r25
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:256
    ++txBufferIndex;
     fb4:	8f 5f       	subi	r24, 0xFF	; 255
     fb6:	80 93 32 02 	sts	0x0232, r24	; 0x800232 <TwoWire::txBufferIndex>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:258
    // update amount in buffer
    txBufferLength = txBufferIndex;
     fba:	80 93 54 02 	sts	0x0254, r24	; 0x800254 <TwoWire::txBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:264
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
  }
  return 1;
     fbe:	81 e0       	ldi	r24, 0x01	; 1
     fc0:	90 e0       	ldi	r25, 0x00	; 0
     fc2:	ec cf       	rjmp	.-40     	; 0xf9c <TwoWire::write(unsigned char)+0x2a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:262
    // update amount in buffer
    txBufferLength = txBufferIndex;
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
     fc4:	61 e0       	ldi	r22, 0x01	; 1
     fc6:	ce 01       	movw	r24, r28
     fc8:	01 96       	adiw	r24, 0x01	; 1
     fca:	0e 94 4e 07 	call	0xe9c	; 0xe9c <twi_transmit>
     fce:	f7 cf       	rjmp	.-18     	; 0xfbe <TwoWire::write(unsigned char)+0x4c>

00000fd0 <TwoWire::write(int) [clone .constprop.44]>:
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.h:86
    void onRequest( void (*)(void) );

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     fd0:	68 2f       	mov	r22, r24
     fd2:	83 e4       	ldi	r24, 0x43	; 67
     fd4:	93 e0       	ldi	r25, 0x03	; 3
     fd6:	0c 94 b9 07 	jmp	0xf72	; 0xf72 <TwoWire::write(unsigned char)>

00000fda <LiquidCrystal_I2C::expanderWrite(unsigned char)>:
expanderWrite():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:223
void LiquidCrystal_I2C::write4bits(uint8_t value) {
	expanderWrite(value);
	pulseEnable(value);
}

void LiquidCrystal_I2C::expanderWrite(uint8_t _data){                                        
     fda:	0f 93       	push	r16
     fdc:	1f 93       	push	r17
     fde:	cf 93       	push	r28
     fe0:	8c 01       	movw	r16, r24
     fe2:	c6 2f       	mov	r28, r22
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:224
	Wire.beginTransmission(_addr);
     fe4:	fc 01       	movw	r30, r24
     fe6:	84 81       	ldd	r24, Z+4	; 0x04
     fe8:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:225
	Wire.write((int)(_data) | _backlightval);
     fec:	f8 01       	movw	r30, r16
     fee:	83 85       	ldd	r24, Z+11	; 0x0b
     ff0:	8c 2b       	or	r24, r28
     ff2:	90 e0       	ldi	r25, 0x00	; 0
     ff4:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:227
	Wire.endTransmission();   
}
     ff8:	cf 91       	pop	r28
     ffa:	1f 91       	pop	r17
     ffc:	0f 91       	pop	r16
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:226
}

void LiquidCrystal_I2C::expanderWrite(uint8_t _data){                                        
	Wire.beginTransmission(_addr);
	Wire.write((int)(_data) | _backlightval);
	Wire.endTransmission();   
     ffe:	0c 94 45 04 	jmp	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>

00001002 <LiquidCrystal_I2C::write4bits(unsigned char)>:
write4bits():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:218
	uint8_t lownib=(value<<4)&0xf0;
	write4bits((highnib)|mode);
	write4bits((lownib)|mode); 
}

void LiquidCrystal_I2C::write4bits(uint8_t value) {
    1002:	0f 93       	push	r16
    1004:	1f 93       	push	r17
    1006:	cf 93       	push	r28
    1008:	8c 01       	movw	r16, r24
    100a:	c6 2f       	mov	r28, r22
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:219
	expanderWrite(value);
    100c:	0e 94 ed 07 	call	0xfda	; 0xfda <LiquidCrystal_I2C::expanderWrite(unsigned char)>
pulseEnable():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:230
	Wire.write((int)(_data) | _backlightval);
	Wire.endTransmission();   
}

void LiquidCrystal_I2C::pulseEnable(uint8_t _data){
	expanderWrite(_data | En);	// En high
    1010:	6c 2f       	mov	r22, r28
    1012:	64 60       	ori	r22, 0x04	; 4
    1014:	c8 01       	movw	r24, r16
    1016:	0e 94 ed 07 	call	0xfda	; 0xfda <LiquidCrystal_I2C::expanderWrite(unsigned char)>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:231
	delayMicroseconds(1);		// enable pulse must be >450ns
    101a:	81 e0       	ldi	r24, 0x01	; 1
    101c:	90 e0       	ldi	r25, 0x00	; 0
    101e:	0e 94 d6 06 	call	0xdac	; 0xdac <delayMicroseconds>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:233
	
	expanderWrite(_data & ~En);	// En low
    1022:	6c 2f       	mov	r22, r28
    1024:	6b 7f       	andi	r22, 0xFB	; 251
    1026:	c8 01       	movw	r24, r16
    1028:	0e 94 ed 07 	call	0xfda	; 0xfda <LiquidCrystal_I2C::expanderWrite(unsigned char)>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:234
	delayMicroseconds(50);		// commands need > 37us to settle
    102c:	82 e3       	ldi	r24, 0x32	; 50
    102e:	90 e0       	ldi	r25, 0x00	; 0
write4bits():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:221
}

void LiquidCrystal_I2C::write4bits(uint8_t value) {
	expanderWrite(value);
	pulseEnable(value);
}
    1030:	cf 91       	pop	r28
    1032:	1f 91       	pop	r17
    1034:	0f 91       	pop	r16
pulseEnable():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:234
void LiquidCrystal_I2C::pulseEnable(uint8_t _data){
	expanderWrite(_data | En);	// En high
	delayMicroseconds(1);		// enable pulse must be >450ns
	
	expanderWrite(_data & ~En);	// En low
	delayMicroseconds(50);		// commands need > 37us to settle
    1036:	0c 94 d6 06 	jmp	0xdac	; 0xdac <delayMicroseconds>

0000103a <LiquidCrystal_I2C::send(unsigned char, unsigned char)>:
send():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:211


/************ low level data pushing commands **********/

// write either command or data
void LiquidCrystal_I2C::send(uint8_t value, uint8_t mode) {
    103a:	0f 93       	push	r16
    103c:	1f 93       	push	r17
    103e:	cf 93       	push	r28
    1040:	df 93       	push	r29
    1042:	8c 01       	movw	r16, r24
    1044:	d6 2f       	mov	r29, r22
    1046:	c4 2f       	mov	r28, r20
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:212
	uint8_t highnib=value&0xf0;
    1048:	60 7f       	andi	r22, 0xF0	; 240
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:214
	uint8_t lownib=(value<<4)&0xf0;
	write4bits((highnib)|mode);
    104a:	64 2b       	or	r22, r20
    104c:	0e 94 01 08 	call	0x1002	; 0x1002 <LiquidCrystal_I2C::write4bits(unsigned char)>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:213
/************ low level data pushing commands **********/

// write either command or data
void LiquidCrystal_I2C::send(uint8_t value, uint8_t mode) {
	uint8_t highnib=value&0xf0;
	uint8_t lownib=(value<<4)&0xf0;
    1050:	80 e1       	ldi	r24, 0x10	; 16
    1052:	d8 9f       	mul	r29, r24
    1054:	b0 01       	movw	r22, r0
    1056:	11 24       	eor	r1, r1
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:215
	write4bits((highnib)|mode);
	write4bits((lownib)|mode); 
    1058:	6c 2b       	or	r22, r28
    105a:	c8 01       	movw	r24, r16
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:216
}
    105c:	df 91       	pop	r29
    105e:	cf 91       	pop	r28
    1060:	1f 91       	pop	r17
    1062:	0f 91       	pop	r16
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:215
// write either command or data
void LiquidCrystal_I2C::send(uint8_t value, uint8_t mode) {
	uint8_t highnib=value&0xf0;
	uint8_t lownib=(value<<4)&0xf0;
	write4bits((highnib)|mode);
	write4bits((lownib)|mode); 
    1064:	0c 94 01 08 	jmp	0x1002	; 0x1002 <LiquidCrystal_I2C::write4bits(unsigned char)>

00001068 <LiquidCrystal_I2C::write(unsigned char)>:
write():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:203
inline void LiquidCrystal_I2C::command(uint8_t value) {
	send(value, 0);
}

inline size_t LiquidCrystal_I2C::write(uint8_t value) {
	send(value, Rs);
    1068:	41 e0       	ldi	r20, 0x01	; 1
    106a:	0e 94 1d 08 	call	0x103a	; 0x103a <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:205
	return 1;
}
    106e:	81 e0       	ldi	r24, 0x01	; 1
    1070:	90 e0       	ldi	r25, 0x00	; 0
    1072:	08 95       	ret

00001074 <writeRTC(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char) [clone .constprop.27]>:
writeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2241
  *tempC = Wire.read();
}

// ------------------------------------------------------------------------------

void writeRTC(byte second, byte minute, byte hour, byte day, byte month, byte year)
    1074:	0f 93       	push	r16
    1076:	1f 93       	push	r17
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	08 2f       	mov	r16, r24
    107e:	16 2f       	mov	r17, r22
    1080:	d4 2f       	mov	r29, r20
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
  txBufferLength = 0;
}

void TwoWire::beginTransmission(int address)
{
  beginTransmission((uint8_t)address);
    1082:	88 e6       	ldi	r24, 0x68	; 104
    1084:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
writeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2245
// Write given date/time binary values to the DS3231 RTC
{
  Wire.beginTransmission(DS3231_RTC);
  Wire.write(DS3231_SECRG);                       // Set the DS3231 Seconds Register
    1088:	90 e0       	ldi	r25, 0x00	; 0
    108a:	80 e0       	ldi	r24, 0x00	; 0
    108c:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2246
  Wire.write(decToBcd(seconds));
    1090:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <seconds>
decToBcd():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2206


byte decToBcd(byte val)
// Convert a binary byte to a two digits BCD byte
{
  return ( (val / 10 * 16) + (val % 10) );
    1094:	ca e0       	ldi	r28, 0x0A	; 10
    1096:	6c 2f       	mov	r22, r28
    1098:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    109c:	82 95       	swap	r24
    109e:	80 7f       	andi	r24, 0xF0	; 240
    10a0:	68 2f       	mov	r22, r24
    10a2:	69 0f       	add	r22, r25
writeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2246
void writeRTC(byte second, byte minute, byte hour, byte day, byte month, byte year)
// Write given date/time binary values to the DS3231 RTC
{
  Wire.beginTransmission(DS3231_RTC);
  Wire.write(DS3231_SECRG);                       // Set the DS3231 Seconds Register
  Wire.write(decToBcd(seconds));
    10a4:	83 e4       	ldi	r24, 0x43	; 67
    10a6:	93 e0       	ldi	r25, 0x03	; 3
    10a8:	0e 94 b9 07 	call	0xf72	; 0xf72 <TwoWire::write(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2247
  Wire.write(decToBcd(minutes));
    10ac:	80 91 26 02 	lds	r24, 0x0226	; 0x800226 <minutes>
decToBcd():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2206


byte decToBcd(byte val)
// Convert a binary byte to a two digits BCD byte
{
  return ( (val / 10 * 16) + (val % 10) );
    10b0:	6c 2f       	mov	r22, r28
    10b2:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    10b6:	82 95       	swap	r24
    10b8:	80 7f       	andi	r24, 0xF0	; 240
    10ba:	68 2f       	mov	r22, r24
    10bc:	69 0f       	add	r22, r25
writeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2247
// Write given date/time binary values to the DS3231 RTC
{
  Wire.beginTransmission(DS3231_RTC);
  Wire.write(DS3231_SECRG);                       // Set the DS3231 Seconds Register
  Wire.write(decToBcd(seconds));
  Wire.write(decToBcd(minutes));
    10be:	83 e4       	ldi	r24, 0x43	; 67
    10c0:	93 e0       	ldi	r25, 0x03	; 3
    10c2:	0e 94 b9 07 	call	0xf72	; 0xf72 <TwoWire::write(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2248
  Wire.write(decToBcd(hours));
    10c6:	80 91 25 02 	lds	r24, 0x0225	; 0x800225 <hours>
decToBcd():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2206


byte decToBcd(byte val)
// Convert a binary byte to a two digits BCD byte
{
  return ( (val / 10 * 16) + (val % 10) );
    10ca:	6c 2f       	mov	r22, r28
    10cc:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    10d0:	82 95       	swap	r24
    10d2:	80 7f       	andi	r24, 0xF0	; 240
    10d4:	68 2f       	mov	r22, r24
    10d6:	69 0f       	add	r22, r25
writeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2248
{
  Wire.beginTransmission(DS3231_RTC);
  Wire.write(DS3231_SECRG);                       // Set the DS3231 Seconds Register
  Wire.write(decToBcd(seconds));
  Wire.write(decToBcd(minutes));
  Wire.write(decToBcd(hours));
    10d8:	83 e4       	ldi	r24, 0x43	; 67
    10da:	93 e0       	ldi	r25, 0x03	; 3
    10dc:	0e 94 b9 07 	call	0xf72	; 0xf72 <TwoWire::write(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2249
  Wire.write(1);                                  // Day of week not used (always set to 1 = Sunday)
    10e0:	81 e0       	ldi	r24, 0x01	; 1
    10e2:	90 e0       	ldi	r25, 0x00	; 0
    10e4:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
decToBcd():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2206


byte decToBcd(byte val)
// Convert a binary byte to a two digits BCD byte
{
  return ( (val / 10 * 16) + (val % 10) );
    10e8:	80 2f       	mov	r24, r16
    10ea:	6c 2f       	mov	r22, r28
    10ec:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    10f0:	82 95       	swap	r24
    10f2:	80 7f       	andi	r24, 0xF0	; 240
    10f4:	68 2f       	mov	r22, r24
    10f6:	69 0f       	add	r22, r25
writeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2250
  Wire.write(DS3231_SECRG);                       // Set the DS3231 Seconds Register
  Wire.write(decToBcd(seconds));
  Wire.write(decToBcd(minutes));
  Wire.write(decToBcd(hours));
  Wire.write(1);                                  // Day of week not used (always set to 1 = Sunday)
  Wire.write(decToBcd(day));
    10f8:	83 e4       	ldi	r24, 0x43	; 67
    10fa:	93 e0       	ldi	r25, 0x03	; 3
    10fc:	0e 94 b9 07 	call	0xf72	; 0xf72 <TwoWire::write(unsigned char)>
decToBcd():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2206


byte decToBcd(byte val)
// Convert a binary byte to a two digits BCD byte
{
  return ( (val / 10 * 16) + (val % 10) );
    1100:	81 2f       	mov	r24, r17
    1102:	6c 2f       	mov	r22, r28
    1104:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    1108:	82 95       	swap	r24
    110a:	80 7f       	andi	r24, 0xF0	; 240
    110c:	68 2f       	mov	r22, r24
    110e:	69 0f       	add	r22, r25
writeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2251
  Wire.write(decToBcd(seconds));
  Wire.write(decToBcd(minutes));
  Wire.write(decToBcd(hours));
  Wire.write(1);                                  // Day of week not used (always set to 1 = Sunday)
  Wire.write(decToBcd(day));
  Wire.write(decToBcd(month));
    1110:	83 e4       	ldi	r24, 0x43	; 67
    1112:	93 e0       	ldi	r25, 0x03	; 3
    1114:	0e 94 b9 07 	call	0xf72	; 0xf72 <TwoWire::write(unsigned char)>
decToBcd():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2206


byte decToBcd(byte val)
// Convert a binary byte to a two digits BCD byte
{
  return ( (val / 10 * 16) + (val % 10) );
    1118:	8d 2f       	mov	r24, r29
    111a:	6c 2f       	mov	r22, r28
    111c:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    1120:	82 95       	swap	r24
    1122:	80 7f       	andi	r24, 0xF0	; 240
    1124:	68 2f       	mov	r22, r24
    1126:	69 0f       	add	r22, r25
writeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2252
  Wire.write(decToBcd(minutes));
  Wire.write(decToBcd(hours));
  Wire.write(1);                                  // Day of week not used (always set to 1 = Sunday)
  Wire.write(decToBcd(day));
  Wire.write(decToBcd(month));
  Wire.write(decToBcd(year));
    1128:	83 e4       	ldi	r24, 0x43	; 67
    112a:	93 e0       	ldi	r25, 0x03	; 3
    112c:	0e 94 b9 07 	call	0xf72	; 0xf72 <TwoWire::write(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2254
  Wire.endTransmission();
}
    1130:	df 91       	pop	r29
    1132:	cf 91       	pop	r28
    1134:	1f 91       	pop	r17
    1136:	0f 91       	pop	r16
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2253
  Wire.write(decToBcd(hours));
  Wire.write(1);                                  // Day of week not used (always set to 1 = Sunday)
  Wire.write(decToBcd(day));
  Wire.write(decToBcd(month));
  Wire.write(decToBcd(year));
  Wire.endTransmission();
    1138:	0c 94 45 04 	jmp	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>

0000113c <Print::availableForWrite()>:
availableForWrite():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.h:63
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
    113c:	90 e0       	ldi	r25, 0x00	; 0
    113e:	80 e0       	ldi	r24, 0x00	; 0
    1140:	08 95       	ret

00001142 <clust2sect(unsigned long)>:
clust2sect():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:402

static
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	CLUST clst		/* Cluster# to be converted */
)
{
    1142:	0f 93       	push	r16
    1144:	1f 93       	push	r17
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:403
	FATFS *fs = FatFs;
    1146:	e0 91 a4 02 	lds	r30, 0x02A4	; 0x8002a4 <FatFs>
    114a:	f0 91 a5 02 	lds	r31, 0x02A5	; 0x8002a5 <FatFs+0x1>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:406


	clst -= 2;
    114e:	9b 01       	movw	r18, r22
    1150:	ac 01       	movw	r20, r24
    1152:	22 50       	subi	r18, 0x02	; 2
    1154:	31 09       	sbc	r19, r1
    1156:	41 09       	sbc	r20, r1
    1158:	51 09       	sbc	r21, r1
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:407
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    115a:	86 81       	ldd	r24, Z+6	; 0x06
    115c:	97 81       	ldd	r25, Z+7	; 0x07
    115e:	a0 85       	ldd	r26, Z+8	; 0x08
    1160:	b1 85       	ldd	r27, Z+9	; 0x09
    1162:	02 97       	sbiw	r24, 0x02	; 2
    1164:	a1 09       	sbc	r26, r1
    1166:	b1 09       	sbc	r27, r1
    1168:	28 17       	cp	r18, r24
    116a:	39 07       	cpc	r19, r25
    116c:	4a 07       	cpc	r20, r26
    116e:	5b 07       	cpc	r21, r27
    1170:	78 f4       	brcc	.+30     	; 0x1190 <clust2sect(unsigned long)+0x4e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:408
	return (DWORD)clst * fs->csize + fs->database;
    1172:	a2 81       	ldd	r26, Z+2	; 0x02
    1174:	b0 e0       	ldi	r27, 0x00	; 0
    1176:	0e 94 1d 25 	call	0x4a3a	; 0x4a3a <__muluhisi3>
    117a:	02 89       	ldd	r16, Z+18	; 0x12
    117c:	13 89       	ldd	r17, Z+19	; 0x13
    117e:	24 89       	ldd	r18, Z+20	; 0x14
    1180:	35 89       	ldd	r19, Z+21	; 0x15
    1182:	60 0f       	add	r22, r16
    1184:	71 1f       	adc	r23, r17
    1186:	82 1f       	adc	r24, r18
    1188:	93 1f       	adc	r25, r19
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:409
}
    118a:	1f 91       	pop	r17
    118c:	0f 91       	pop	r16
    118e:	08 95       	ret
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:407
{
	FATFS *fs = FatFs;


	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    1190:	60 e0       	ldi	r22, 0x00	; 0
    1192:	70 e0       	ldi	r23, 0x00	; 0
    1194:	cb 01       	movw	r24, r22
    1196:	f9 cf       	rjmp	.-14     	; 0x118a <clust2sect(unsigned long)+0x48>

00001198 <dir_rewind(DIR*)>:
dir_rewind():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:439

static
FRESULT dir_rewind (
	DIR *dj			/* Pointer to directory object */
)
{
    1198:	0f 93       	push	r16
    119a:	1f 93       	push	r17
    119c:	cf 93       	push	r28
    119e:	df 93       	push	r29
    11a0:	ec 01       	movw	r28, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:441
	CLUST clst;
	FATFS *fs = FatFs;
    11a2:	e0 91 a4 02 	lds	r30, 0x02A4	; 0x8002a4 <FatFs>
    11a6:	f0 91 a5 02 	lds	r31, 0x02A5	; 0x8002a5 <FatFs+0x1>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:444


	dj->index = 0;
    11aa:	19 82       	std	Y+1, r1	; 0x01
    11ac:	18 82       	st	Y, r1
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:445
	clst = dj->sclust;
    11ae:	6c 81       	ldd	r22, Y+4	; 0x04
    11b0:	7d 81       	ldd	r23, Y+5	; 0x05
    11b2:	8e 81       	ldd	r24, Y+6	; 0x06
    11b4:	9f 81       	ldd	r25, Y+7	; 0x07
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:446
	if (clst == 1 || clst >= fs->n_fatent)	/* Check start cluster range */
    11b6:	61 30       	cpi	r22, 0x01	; 1
    11b8:	71 05       	cpc	r23, r1
    11ba:	81 05       	cpc	r24, r1
    11bc:	91 05       	cpc	r25, r1
    11be:	81 f1       	breq	.+96     	; 0x1220 <dir_rewind(DIR*)+0x88>
    11c0:	06 81       	ldd	r16, Z+6	; 0x06
    11c2:	17 81       	ldd	r17, Z+7	; 0x07
    11c4:	20 85       	ldd	r18, Z+8	; 0x08
    11c6:	31 85       	ldd	r19, Z+9	; 0x09
    11c8:	60 17       	cp	r22, r16
    11ca:	71 07       	cpc	r23, r17
    11cc:	82 07       	cpc	r24, r18
    11ce:	93 07       	cpc	r25, r19
    11d0:	38 f5       	brcc	.+78     	; 0x1220 <dir_rewind(DIR*)+0x88>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:448
		return FR_DISK_ERR;
	if (_FS_FAT32 && !clst && (_FS_32ONLY || fs->fs_type == FS_FAT32))	/* Replace cluster# 0 with root cluster# if in FAT32 */
    11d2:	61 15       	cp	r22, r1
    11d4:	71 05       	cpc	r23, r1
    11d6:	81 05       	cpc	r24, r1
    11d8:	91 05       	cpc	r25, r1
    11da:	39 f4       	brne	.+14     	; 0x11ea <dir_rewind(DIR*)+0x52>
    11dc:	20 81       	ld	r18, Z
    11de:	23 30       	cpi	r18, 0x03	; 3
    11e0:	21 f4       	brne	.+8      	; 0x11ea <dir_rewind(DIR*)+0x52>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:449
		clst = (CLUST)fs->dirbase;
    11e2:	66 85       	ldd	r22, Z+14	; 0x0e
    11e4:	77 85       	ldd	r23, Z+15	; 0x0f
    11e6:	80 89       	ldd	r24, Z+16	; 0x10
    11e8:	91 89       	ldd	r25, Z+17	; 0x11
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:450
	dj->clust = clst;						/* Current cluster */
    11ea:	68 87       	std	Y+8, r22	; 0x08
    11ec:	79 87       	std	Y+9, r23	; 0x09
    11ee:	8a 87       	std	Y+10, r24	; 0x0a
    11f0:	9b 87       	std	Y+11, r25	; 0x0b
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:451
	dj->sect = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase;	/* Current sector */
    11f2:	61 15       	cp	r22, r1
    11f4:	71 05       	cpc	r23, r1
    11f6:	81 05       	cpc	r24, r1
    11f8:	91 05       	cpc	r25, r1
    11fa:	69 f0       	breq	.+26     	; 0x1216 <dir_rewind(DIR*)+0x7e>
    11fc:	0e 94 a1 08 	call	0x1142	; 0x1142 <clust2sect(unsigned long)>
    1200:	6c 87       	std	Y+12, r22	; 0x0c
    1202:	7d 87       	std	Y+13, r23	; 0x0d
    1204:	8e 87       	std	Y+14, r24	; 0x0e
    1206:	9f 87       	std	Y+15, r25	; 0x0f
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:453

	return FR_OK;	/* Seek succeeded */
    1208:	90 e0       	ldi	r25, 0x00	; 0
    120a:	80 e0       	ldi	r24, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:454
}
    120c:	df 91       	pop	r29
    120e:	cf 91       	pop	r28
    1210:	1f 91       	pop	r17
    1212:	0f 91       	pop	r16
    1214:	08 95       	ret
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:451
	if (clst == 1 || clst >= fs->n_fatent)	/* Check start cluster range */
		return FR_DISK_ERR;
	if (_FS_FAT32 && !clst && (_FS_32ONLY || fs->fs_type == FS_FAT32))	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = (CLUST)fs->dirbase;
	dj->clust = clst;						/* Current cluster */
	dj->sect = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase;	/* Current sector */
    1216:	66 85       	ldd	r22, Z+14	; 0x0e
    1218:	77 85       	ldd	r23, Z+15	; 0x0f
    121a:	80 89       	ldd	r24, Z+16	; 0x10
    121c:	91 89       	ldd	r25, Z+17	; 0x11
    121e:	f0 cf       	rjmp	.-32     	; 0x1200 <dir_rewind(DIR*)+0x68>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:447


	dj->index = 0;
	clst = dj->sclust;
	if (clst == 1 || clst >= fs->n_fatent)	/* Check start cluster range */
		return FR_DISK_ERR;
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	90 e0       	ldi	r25, 0x00	; 0
    1224:	f3 cf       	rjmp	.-26     	; 0x120c <dir_rewind(DIR*)+0x74>

00001226 <xmit_spi(unsigned char)>:
xmit_spi():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:29
    SPSR = SPI_FCPU_DIV_2 ? 1 << SPI2X : 0;
  }
}
//------------------------------------------------------------------------------
/** Send a byte to the card */
inline void xmit_spi(BYTE d) {SPDR = d; while(!(SPSR & (1 << SPIF)));}
    1226:	8f b9       	out	0x0f, r24	; 15
    1228:	77 9b       	sbis	0x0e, 7	; 14
    122a:	fe cf       	rjmp	.-4      	; 0x1228 <xmit_spi(unsigned char)+0x2>
    122c:	08 95       	ret

0000122e <rcv_spi()>:
rcv_spi():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:32
//------------------------------------------------------------------------------
/** Receive a byte from the card */
inline BYTE rcv_spi (void) {xmit_spi(0XFF); return SPDR;}
    122e:	8f ef       	ldi	r24, 0xFF	; 255
    1230:	0e 94 13 09 	call	0x1226	; 0x1226 <xmit_spi(unsigned char)>
    1234:	8f b1       	in	r24, 0x0f	; 15
    1236:	08 95       	ret

00001238 <disk_writep.part.1>:
disk_writep.part.1():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:222
/*-----------------------------------------------------------------------*/
/* Write partial sector                                                  */
/*-----------------------------------------------------------------------*/

#if _USE_WRITE
DRESULT disk_writep (
    1238:	0f 93       	push	r16
    123a:	1f 93       	push	r17
    123c:	cf 93       	push	r28
    123e:	df 93       	push	r29
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:249
				xmit_spi(0xFF); xmit_spi(0xFE);		/* Data block header */
				wc = 512;							/* Set byte counter */
				res = RES_OK;
			}
		} else {	/* Finalize sector write process */
			bc = wc + 2;
    1240:	c0 91 cf 01 	lds	r28, 0x01CF	; 0x8001cf <disk_writep::wc>
    1244:	d0 91 d0 01 	lds	r29, 0x01D0	; 0x8001d0 <disk_writep::wc+0x1>
    1248:	21 97       	sbiw	r28, 0x01	; 1
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:250
			while (bc--) xmit_spi(0);	/* Fill left bytes and CRC with zeros */
    124a:	cd 3f       	cpi	r28, 0xFD	; 253
    124c:	8f ef       	ldi	r24, 0xFF	; 255
    124e:	d8 07       	cpc	r29, r24
    1250:	21 f0       	breq	.+8      	; 0x125a <disk_writep.part.1+0x22>
    1252:	80 e0       	ldi	r24, 0x00	; 0
    1254:	0e 94 13 09 	call	0x1226	; 0x1226 <xmit_spi(unsigned char)>
    1258:	f7 cf       	rjmp	.-18     	; 0x1248 <disk_writep.part.1+0x10>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:251
			if ((rcv_spi() & 0x1F) == 0x05) {	/* Receive data resp and wait for end of write process in timeout of 500ms */
    125a:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
    125e:	8f 71       	andi	r24, 0x1F	; 31
    1260:	85 30       	cpi	r24, 0x05	; 5
    1262:	79 f0       	breq	.+30     	; 0x1282 <disk_writep.part.1+0x4a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:231
{
	DRESULT res;
	UINT bc;
	static UINT wc;	/* Sector write counter */

	res = RES_ERROR;
    1264:	d1 e0       	ldi	r29, 0x01	; 1
    1266:	c0 e0       	ldi	r28, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:256
			if ((rcv_spi() & 0x1F) == 0x05) {	/* Receive data resp and wait for end of write process in timeout of 500ms */
				for (bc = 5000; rcv_spi() != 0xFF && bc; bc--)	/* Wait for ready */
					dly_100us();
				if (bc) res = RES_OK;
			}
			DESELECT();
    1268:	61 e0       	ldi	r22, 0x01	; 1
    126a:	84 e0       	ldi	r24, 0x04	; 4
    126c:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:257
			rcv_spi();
    1270:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:262
		}
	}

	return res;
}
    1274:	8d 2f       	mov	r24, r29
    1276:	9c 2f       	mov	r25, r28
    1278:	df 91       	pop	r29
    127a:	cf 91       	pop	r28
    127c:	1f 91       	pop	r17
    127e:	0f 91       	pop	r16
    1280:	08 95       	ret
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:252
			}
		} else {	/* Finalize sector write process */
			bc = wc + 2;
			while (bc--) xmit_spi(0);	/* Fill left bytes and CRC with zeros */
			if ((rcv_spi() & 0x1F) == 0x05) {	/* Receive data resp and wait for end of write process in timeout of 500ms */
				for (bc = 5000; rcv_spi() != 0xFF && bc; bc--)	/* Wait for ready */
    1282:	08 e8       	ldi	r16, 0x88	; 136
    1284:	13 e1       	ldi	r17, 0x13	; 19
_delay_loop_2():
c:\users\anthony\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    1286:	c0 e9       	ldi	r28, 0x90	; 144
    1288:	d1 e0       	ldi	r29, 0x01	; 1
disk_writep.part.1():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:252
    128a:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
    128e:	8f 3f       	cpi	r24, 0xFF	; 255
    1290:	49 f0       	breq	.+18     	; 0x12a4 <disk_writep.part.1+0x6c>
    1292:	01 15       	cp	r16, r1
    1294:	11 05       	cpc	r17, r1
    1296:	31 f3       	breq	.-52     	; 0x1264 <disk_writep.part.1+0x2c>
_delay_loop_2():
c:\users\anthony\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
    1298:	ce 01       	movw	r24, r28
    129a:	01 97       	sbiw	r24, 0x01	; 1
    129c:	f1 f7       	brne	.-4      	; 0x129a <disk_writep.part.1+0x62>
disk_writep.part.1():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:252
    129e:	01 50       	subi	r16, 0x01	; 1
    12a0:	11 09       	sbc	r17, r1
    12a2:	f3 cf       	rjmp	.-26     	; 0x128a <disk_writep.part.1+0x52>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:254
					dly_100us();
				if (bc) res = RES_OK;
    12a4:	d1 e0       	ldi	r29, 0x01	; 1
    12a6:	c0 e0       	ldi	r28, 0x00	; 0
    12a8:	01 2b       	or	r16, r17
    12aa:	f1 f2       	breq	.-68     	; 0x1268 <disk_writep.part.1+0x30>
    12ac:	d0 e0       	ldi	r29, 0x00	; 0
    12ae:	dc cf       	rjmp	.-72     	; 0x1268 <disk_writep.part.1+0x30>

000012b0 <send_cmd(unsigned char, unsigned long)>:
send_cmd():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:66
static
BYTE send_cmd (
	BYTE cmd,		/* 1st byte (Start + Index) */
	DWORD arg		/* Argument (32 bits) */
)
{
    12b0:	ff 92       	push	r15
    12b2:	0f 93       	push	r16
    12b4:	1f 93       	push	r17
    12b6:	cf 93       	push	r28
    12b8:	df 93       	push	r29
    12ba:	c8 2f       	mov	r28, r24
    12bc:	d4 2f       	mov	r29, r20
    12be:	15 2f       	mov	r17, r21
    12c0:	06 2f       	mov	r16, r22
    12c2:	f7 2e       	mov	r15, r23
spi_set_divisor():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:17
//------------------------------------------------------------------------------
#define	FORWARD(d)	xmit(d)				/* Data forwarding function (console out) */
static void xmit(char d) {}  // Dummy write console
//------------------------------------------------------------------------------
static void spi_set_divisor(BYTE cardType) {
  if (!cardType) {
    12c4:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <CardType>
    12c8:	81 11       	cpse	r24, r1
    12ca:	3f c0       	rjmp	.+126    	; 0x134a <send_cmd(unsigned char, unsigned long)+0x9a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:19
    // Set slow speed for initialization.
    SPCR = (1 << SPE) | (1 << MSTR) | 3;
    12cc:	83 e5       	ldi	r24, 0x53	; 83
    12ce:	8d b9       	out	0x0d, r24	; 13
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:20
    SPSR = 0;
    12d0:	1e b8       	out	0x0e, r1	; 14
send_cmd():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:70
	BYTE n, res;

  spi_set_divisor(CardType);  // whg
	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
    12d2:	c7 ff       	sbrs	r28, 7
    12d4:	09 c0       	rjmp	.+18     	; 0x12e8 <send_cmd(unsigned char, unsigned long)+0x38>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:72
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
    12d6:	40 e0       	ldi	r20, 0x00	; 0
    12d8:	50 e0       	ldi	r21, 0x00	; 0
    12da:	ba 01       	movw	r22, r20
    12dc:	87 e7       	ldi	r24, 0x77	; 119
    12de:	0e 94 58 09 	call	0x12b0	; 0x12b0 <send_cmd(unsigned char, unsigned long)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:73
		if (res > 1) return res;
    12e2:	82 30       	cpi	r24, 0x02	; 2
    12e4:	60 f5       	brcc	.+88     	; 0x133e <send_cmd(unsigned char, unsigned long)+0x8e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:71
{
	BYTE n, res;

  spi_set_divisor(CardType);  // whg
	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
    12e6:	cf 77       	andi	r28, 0x7F	; 127
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:77
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
	}

	/* Select the card */
	DESELECT();
    12e8:	61 e0       	ldi	r22, 0x01	; 1
    12ea:	84 e0       	ldi	r24, 0x04	; 4
    12ec:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:78
	rcv_spi();
    12f0:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:79
	SELECT();
    12f4:	60 e0       	ldi	r22, 0x00	; 0
    12f6:	84 e0       	ldi	r24, 0x04	; 4
    12f8:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:80
	rcv_spi();
    12fc:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:83

	/* Send a command packet */
	xmit_spi(cmd);						/* Start + Command index */
    1300:	8c 2f       	mov	r24, r28
    1302:	0e 94 13 09 	call	0x1226	; 0x1226 <xmit_spi(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:84
	xmit_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
    1306:	8f 2d       	mov	r24, r15
    1308:	0e 94 13 09 	call	0x1226	; 0x1226 <xmit_spi(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:85
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
    130c:	80 2f       	mov	r24, r16
    130e:	0e 94 13 09 	call	0x1226	; 0x1226 <xmit_spi(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:86
	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
    1312:	81 2f       	mov	r24, r17
    1314:	0e 94 13 09 	call	0x1226	; 0x1226 <xmit_spi(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:87
	xmit_spi((BYTE)arg);				/* Argument[7..0] */
    1318:	8d 2f       	mov	r24, r29
    131a:	0e 94 13 09 	call	0x1226	; 0x1226 <xmit_spi(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:89
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
    131e:	85 e9       	ldi	r24, 0x95	; 149
    1320:	c0 34       	cpi	r28, 0x40	; 64
    1322:	21 f0       	breq	.+8      	; 0x132c <send_cmd(unsigned char, unsigned long)+0x7c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:90
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
    1324:	87 e8       	ldi	r24, 0x87	; 135
    1326:	c8 34       	cpi	r28, 0x48	; 72
    1328:	09 f0       	breq	.+2      	; 0x132c <send_cmd(unsigned char, unsigned long)+0x7c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:88
	xmit_spi(cmd);						/* Start + Command index */
	xmit_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xmit_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
    132a:	81 e0       	ldi	r24, 0x01	; 1
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:91
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
	xmit_spi(n);
    132c:	0e 94 13 09 	call	0x1226	; 0x1226 <xmit_spi(unsigned char)>
    1330:	ca e0       	ldi	r28, 0x0A	; 10
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:96

	/* Receive a command response */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do {
		res = rcv_spi();
    1332:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:97
	} while ((res & 0x80) && --n);
    1336:	87 ff       	sbrs	r24, 7
    1338:	02 c0       	rjmp	.+4      	; 0x133e <send_cmd(unsigned char, unsigned long)+0x8e>
    133a:	c1 50       	subi	r28, 0x01	; 1
    133c:	d1 f7       	brne	.-12     	; 0x1332 <send_cmd(unsigned char, unsigned long)+0x82>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:100

	return res;			/* Return with the response value */
}
    133e:	df 91       	pop	r29
    1340:	cf 91       	pop	r28
    1342:	1f 91       	pop	r17
    1344:	0f 91       	pop	r16
    1346:	ff 90       	pop	r15
    1348:	08 95       	ret
spi_set_divisor():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:23
  }  else {
    // Set high speed.
    SPCR = (1 << SPE) | (1 << MSTR);
    134a:	80 e5       	ldi	r24, 0x50	; 80
    134c:	8d b9       	out	0x0d, r24	; 13
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:24
    SPSR = SPI_FCPU_DIV_2 ? 1 << SPI2X : 0;
    134e:	81 e0       	ldi	r24, 0x01	; 1
    1350:	8e b9       	out	0x0e, r24	; 14
    1352:	bf cf       	rjmp	.-130    	; 0x12d2 <send_cmd(unsigned char, unsigned long)+0x22>

00001354 <disk_readp>:
disk_readp():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:168
	BYTE *buff,		/* Pointer to the read buffer (NULL:Forward to the stream) */
	DWORD sector,	/* Sector number (LBA) */
	UINT offset,	/* Byte offset to read from (0..511) */
	UINT count		/* Number of bytes to read (ofs + cnt mus be <= 512) */
)
{
    1354:	cf 92       	push	r12
    1356:	df 92       	push	r13
    1358:	ef 92       	push	r14
    135a:	ff 92       	push	r15
    135c:	0f 93       	push	r16
    135e:	1f 93       	push	r17
    1360:	cf 93       	push	r28
    1362:	df 93       	push	r29
    1364:	7c 01       	movw	r14, r24
    1366:	69 01       	movw	r12, r18
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:174
	DRESULT res;
	BYTE rc;
	UINT bc;


	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
    1368:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <CardType>
    136c:	83 fd       	sbrc	r24, 3
    136e:	07 c0       	rjmp	.+14     	; 0x137e <disk_readp+0x2a>
    1370:	89 e0       	ldi	r24, 0x09	; 9
    1372:	44 0f       	add	r20, r20
    1374:	55 1f       	adc	r21, r21
    1376:	66 1f       	adc	r22, r22
    1378:	77 1f       	adc	r23, r23
    137a:	8a 95       	dec	r24
    137c:	d1 f7       	brne	.-12     	; 0x1372 <disk_readp+0x1e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:177

	res = RES_ERROR;
	if (send_cmd(CMD17, sector) == 0) {	/* READ_SINGLE_BLOCK */
    137e:	81 e5       	ldi	r24, 0x51	; 81
    1380:	0e 94 58 09 	call	0x12b0	; 0x12b0 <send_cmd(unsigned char, unsigned long)>
    1384:	81 11       	cpse	r24, r1
    1386:	08 c0       	rjmp	.+16     	; 0x1398 <disk_readp+0x44>
    1388:	c0 e4       	ldi	r28, 0x40	; 64
    138a:	dc e9       	ldi	r29, 0x9C	; 156
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:181

		bc = 40000;	/* Time counter */
		do {				/* Wait for data packet */
			rc = rcv_spi();
    138c:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:182
		} while (rc == 0xFF && --bc);
    1390:	8f 3f       	cpi	r24, 0xFF	; 255
    1392:	29 f4       	brne	.+10     	; 0x139e <disk_readp+0x4a>
    1394:	21 97       	sbiw	r28, 0x01	; 1
    1396:	d1 f7       	brne	.-12     	; 0x138c <disk_readp+0x38>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:176
	UINT bc;


	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	res = RES_ERROR;
    1398:	c1 e0       	ldi	r28, 0x01	; 1
    139a:	d0 e0       	ldi	r29, 0x00	; 0
    139c:	22 c0       	rjmp	.+68     	; 0x13e2 <disk_readp+0x8e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:184
		bc = 40000;	/* Time counter */
		do {				/* Wait for data packet */
			rc = rcv_spi();
		} while (rc == 0xFF && --bc);

		if (rc == 0xFE) {	/* A data packet arrived */
    139e:	8e 3f       	cpi	r24, 0xFE	; 254
    13a0:	d9 f7       	brne	.-10     	; 0x1398 <disk_readp+0x44>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:186

			bc = 512 + 2 - offset - count;	/* Number of trailing bytes to skip */
    13a2:	c2 e0       	ldi	r28, 0x02	; 2
    13a4:	d2 e0       	ldi	r29, 0x02	; 2
    13a6:	c0 1b       	sub	r28, r16
    13a8:	d1 0b       	sbc	r29, r17
    13aa:	cc 19       	sub	r28, r12
    13ac:	dd 09       	sbc	r29, r13
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:189

			/* Skip leading bytes */
			while (offset--) rcv_spi();
    13ae:	81 e0       	ldi	r24, 0x01	; 1
    13b0:	c8 1a       	sub	r12, r24
    13b2:	d1 08       	sbc	r13, r1
    13b4:	18 f0       	brcs	.+6      	; 0x13bc <disk_readp+0x68>
    13b6:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
    13ba:	f9 cf       	rjmp	.-14     	; 0x13ae <disk_readp+0x5a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:192

			/* Receive a part of the sector */
			if (buff) {	/* Store data to the memory */
    13bc:	e1 14       	cp	r14, r1
    13be:	f1 04       	cpc	r15, r1
    13c0:	01 f1       	breq	.+64     	; 0x1402 <disk_readp+0xae>
    13c2:	0e 0d       	add	r16, r14
    13c4:	1f 1d       	adc	r17, r15
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:194
				do {
					*buff++ = rcv_spi();
    13c6:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
    13ca:	f7 01       	movw	r30, r14
    13cc:	81 93       	st	Z+, r24
    13ce:	7f 01       	movw	r14, r30
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:195
				} while (--count);
    13d0:	0e 17       	cp	r16, r30
    13d2:	1f 07       	cpc	r17, r31
    13d4:	c1 f7       	brne	.-16     	; 0x13c6 <disk_readp+0x72>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:203
					FORWARD(rcv_spi());
				} while (--count);
			}

			/* Skip trailing bytes and CRC */
			do rcv_spi(); while (--bc);
    13d6:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
    13da:	21 97       	sbiw	r28, 0x01	; 1
    13dc:	e1 f7       	brne	.-8      	; 0x13d6 <disk_readp+0x82>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:205

			res = RES_OK;
    13de:	d0 e0       	ldi	r29, 0x00	; 0
    13e0:	c0 e0       	ldi	r28, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:209
		}
	}

	DESELECT();
    13e2:	61 e0       	ldi	r22, 0x01	; 1
    13e4:	84 e0       	ldi	r24, 0x04	; 4
    13e6:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:210
	rcv_spi();
    13ea:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:213

	return res;
}
    13ee:	ce 01       	movw	r24, r28
    13f0:	df 91       	pop	r29
    13f2:	cf 91       	pop	r28
    13f4:	1f 91       	pop	r17
    13f6:	0f 91       	pop	r16
    13f8:	ff 90       	pop	r15
    13fa:	ef 90       	pop	r14
    13fc:	df 90       	pop	r13
    13fe:	cf 90       	pop	r12
    1400:	08 95       	ret
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:198
				do {
					*buff++ = rcv_spi();
				} while (--count);
			} else {	/* Forward data to the outgoing stream */
				do {
					FORWARD(rcv_spi());
    1402:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:199
				} while (--count);
    1406:	01 50       	subi	r16, 0x01	; 1
    1408:	11 09       	sbc	r17, r1
    140a:	d9 f7       	brne	.-10     	; 0x1402 <disk_readp+0xae>
    140c:	e4 cf       	rjmp	.-56     	; 0x13d6 <disk_readp+0x82>

0000140e <check_fs(unsigned char*, unsigned long)>:
check_fs():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:725
static
BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
	BYTE *buf,	/* Working buffer */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    140e:	cf 92       	push	r12
    1410:	df 92       	push	r13
    1412:	ef 92       	push	r14
    1414:	ff 92       	push	r15
    1416:	0f 93       	push	r16
    1418:	1f 93       	push	r17
    141a:	cf 93       	push	r28
    141c:	df 93       	push	r29
    141e:	ec 01       	movw	r28, r24
    1420:	6a 01       	movw	r12, r20
    1422:	7b 01       	movw	r14, r22
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:726
	if (disk_readp(buf, sect, 510, 2))		/* Read the boot record */
    1424:	02 e0       	ldi	r16, 0x02	; 2
    1426:	10 e0       	ldi	r17, 0x00	; 0
    1428:	2e ef       	ldi	r18, 0xFE	; 254
    142a:	31 e0       	ldi	r19, 0x01	; 1
    142c:	0e 94 aa 09 	call	0x1354	; 0x1354 <disk_readp>
    1430:	89 2b       	or	r24, r25
    1432:	31 f5       	brne	.+76     	; 0x1480 <check_fs(unsigned char*, unsigned long)+0x72>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:728
		return 3;
	if (LD_WORD(buf) != 0xAA55)				/* Check record signature */
    1434:	88 81       	ld	r24, Y
    1436:	99 81       	ldd	r25, Y+1	; 0x01
    1438:	85 35       	cpi	r24, 0x55	; 85
    143a:	9a 4a       	sbci	r25, 0xAA	; 170
    143c:	59 f5       	brne	.+86     	; 0x1494 <check_fs(unsigned char*, unsigned long)+0x86>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:731
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT12/16 */
    143e:	26 e3       	ldi	r18, 0x36	; 54
    1440:	30 e0       	ldi	r19, 0x00	; 0
    1442:	b7 01       	movw	r22, r14
    1444:	a6 01       	movw	r20, r12
    1446:	ce 01       	movw	r24, r28
    1448:	0e 94 aa 09 	call	0x1354	; 0x1354 <disk_readp>
    144c:	89 2b       	or	r24, r25
    144e:	29 f4       	brne	.+10     	; 0x145a <check_fs(unsigned char*, unsigned long)+0x4c>
    1450:	88 81       	ld	r24, Y
    1452:	99 81       	ldd	r25, Y+1	; 0x01
    1454:	86 34       	cpi	r24, 0x46	; 70
    1456:	91 44       	sbci	r25, 0x41	; 65
    1458:	89 f0       	breq	.+34     	; 0x147c <check_fs(unsigned char*, unsigned long)+0x6e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:733
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT32 */
    145a:	02 e0       	ldi	r16, 0x02	; 2
    145c:	10 e0       	ldi	r17, 0x00	; 0
    145e:	22 e5       	ldi	r18, 0x52	; 82
    1460:	30 e0       	ldi	r19, 0x00	; 0
    1462:	b7 01       	movw	r22, r14
    1464:	a6 01       	movw	r20, r12
    1466:	ce 01       	movw	r24, r28
    1468:	0e 94 aa 09 	call	0x1354	; 0x1354 <disk_readp>
    146c:	89 2b       	or	r24, r25
    146e:	a1 f4       	brne	.+40     	; 0x1498 <check_fs(unsigned char*, unsigned long)+0x8a>
    1470:	81 e0       	ldi	r24, 0x01	; 1
    1472:	28 81       	ld	r18, Y
    1474:	39 81       	ldd	r19, Y+1	; 0x01
    1476:	26 34       	cpi	r18, 0x46	; 70
    1478:	31 44       	sbci	r19, 0x41	; 65
    147a:	19 f4       	brne	.+6      	; 0x1482 <check_fs(unsigned char*, unsigned long)+0x74>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:732
		return 3;
	if (LD_WORD(buf) != 0xAA55)				/* Check record signature */
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT12/16 */
		return 0;
    147c:	80 e0       	ldi	r24, 0x00	; 0
    147e:	01 c0       	rjmp	.+2      	; 0x1482 <check_fs(unsigned char*, unsigned long)+0x74>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:727
	BYTE *buf,	/* Working buffer */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_readp(buf, sect, 510, 2))		/* Read the boot record */
		return 3;
    1480:	83 e0       	ldi	r24, 0x03	; 3
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:736
	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT32 */
		return 0;
	return 1;
}
    1482:	df 91       	pop	r29
    1484:	cf 91       	pop	r28
    1486:	1f 91       	pop	r17
    1488:	0f 91       	pop	r16
    148a:	ff 90       	pop	r15
    148c:	ef 90       	pop	r14
    148e:	df 90       	pop	r13
    1490:	cf 90       	pop	r12
    1492:	08 95       	ret
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:729
)
{
	if (disk_readp(buf, sect, 510, 2))		/* Read the boot record */
		return 3;
	if (LD_WORD(buf) != 0xAA55)				/* Check record signature */
		return 2;
    1494:	82 e0       	ldi	r24, 0x02	; 2
    1496:	f5 cf       	rjmp	.-22     	; 0x1482 <check_fs(unsigned char*, unsigned long)+0x74>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:735

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT32 */
		return 0;
	return 1;
    1498:	81 e0       	ldi	r24, 0x01	; 1
    149a:	f3 cf       	rjmp	.-26     	; 0x1482 <check_fs(unsigned char*, unsigned long)+0x74>

0000149c <pf_mount.constprop.41>:
pf_mount():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:753

/*-----------------------------------------------------------------------*/
/* Mount/Unmount a Locical Drive                                         */
/*-----------------------------------------------------------------------*/

FRESULT pf_mount (
    149c:	4f 92       	push	r4
    149e:	5f 92       	push	r5
    14a0:	6f 92       	push	r6
    14a2:	7f 92       	push	r7
    14a4:	8f 92       	push	r8
    14a6:	9f 92       	push	r9
    14a8:	af 92       	push	r10
    14aa:	bf 92       	push	r11
    14ac:	cf 92       	push	r12
    14ae:	df 92       	push	r13
    14b0:	ef 92       	push	r14
    14b2:	ff 92       	push	r15
    14b4:	0f 93       	push	r16
    14b6:	1f 93       	push	r17
    14b8:	cf 93       	push	r28
    14ba:	df 93       	push	r29
    14bc:	cd b7       	in	r28, 0x3d	; 61
    14be:	de b7       	in	r29, 0x3e	; 62
    14c0:	a4 97       	sbiw	r28, 0x24	; 36
    14c2:	0f b6       	in	r0, 0x3f	; 63
    14c4:	f8 94       	cli
    14c6:	de bf       	out	0x3e, r29	; 62
    14c8:	0f be       	out	0x3f, r0	; 63
    14ca:	cd bf       	out	0x3d, r28	; 61
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:761
{
	BYTE fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;


	FatFs = 0;
    14cc:	10 92 a5 02 	sts	0x02A5, r1	; 0x8002a5 <FatFs+0x1>
    14d0:	10 92 a4 02 	sts	0x02A4, r1	; 0x8002a4 <FatFs>
disk_initialize():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:121
{
	BYTE n, cmd, ty, ocr[4];
	UINT tmr;

#if _USE_WRITE
	if (CardType && SELECTING) disk_writep(0, 0);	/* Finalize write process if it is in progress */
    14d4:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <CardType>
    14d8:	88 23       	and	r24, r24
    14da:	39 f0       	breq	.+14     	; 0x14ea <pf_mount.constprop.41+0x4e>
    14dc:	84 e0       	ldi	r24, 0x04	; 4
    14de:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
    14e2:	89 2b       	or	r24, r25
    14e4:	11 f4       	brne	.+4      	; 0x14ea <pf_mount.constprop.41+0x4e>
disk_writep():
    14e6:	0e 94 1c 09 	call	0x1238	; 0x1238 <disk_writep.part.1>
init_spi():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:76
#define SELECT() digitalWrite(SD_CS_PIN, LOW)
#define DESELECT() digitalWrite(SD_CS_PIN, HIGH)
#define SELECTING !digitalRead(SD_CS_PIN)

static void init_spi (void) {
  digitalWrite(SS, HIGH);
    14ea:	61 e0       	ldi	r22, 0x01	; 1
    14ec:	84 e0       	ldi	r24, 0x04	; 4
    14ee:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:77
  pinMode(SS, OUTPUT);
    14f2:	61 e0       	ldi	r22, 0x01	; 1
    14f4:	84 e0       	ldi	r24, 0x04	; 4
    14f6:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:78
  pinMode(MOSI, OUTPUT);
    14fa:	61 e0       	ldi	r22, 0x01	; 1
    14fc:	85 e0       	ldi	r24, 0x05	; 5
    14fe:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:79
  pinMode(SCK, OUTPUT);
    1502:	61 e0       	ldi	r22, 0x01	; 1
    1504:	87 e0       	ldi	r24, 0x07	; 7
    1506:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:80
  pinMode(SD_CS_PIN, OUTPUT);
    150a:	61 e0       	ldi	r22, 0x01	; 1
    150c:	84 e0       	ldi	r24, 0x04	; 4
    150e:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
spi_set_divisor():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:19
static void xmit(char d) {}  // Dummy write console
//------------------------------------------------------------------------------
static void spi_set_divisor(BYTE cardType) {
  if (!cardType) {
    // Set slow speed for initialization.
    SPCR = (1 << SPE) | (1 << MSTR) | 3;
    1512:	83 e5       	ldi	r24, 0x53	; 83
    1514:	8d b9       	out	0x0d, r24	; 13
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pffArduino.h:20
    SPSR = 0;
    1516:	1e b8       	out	0x0e, r1	; 14
disk_initialize():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:124
#endif
	init_spi();		/* Initialize ports to control MMC */
	DESELECT();
    1518:	61 e0       	ldi	r22, 0x01	; 1
    151a:	84 e0       	ldi	r24, 0x04	; 4
    151c:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
    1520:	1a e0       	ldi	r17, 0x0A	; 10
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:125
	for (n = 10; n; n--) rcv_spi();	/* 80 dummy clocks with CS=H */
    1522:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
    1526:	11 50       	subi	r17, 0x01	; 1
    1528:	e1 f7       	brne	.-8      	; 0x1522 <pf_mount.constprop.41+0x86>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:128

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* GO_IDLE_STATE */
    152a:	40 e0       	ldi	r20, 0x00	; 0
    152c:	50 e0       	ldi	r21, 0x00	; 0
    152e:	ba 01       	movw	r22, r20
    1530:	80 e4       	ldi	r24, 0x40	; 64
    1532:	0e 94 58 09 	call	0x12b0	; 0x12b0 <send_cmd(unsigned char, unsigned long)>
    1536:	18 2f       	mov	r17, r24
    1538:	81 30       	cpi	r24, 0x01	; 1
    153a:	09 f4       	brne	.+2      	; 0x153e <pf_mount.constprop.41+0xa2>
    153c:	41 c0       	rjmp	.+130    	; 0x15c0 <pf_mount.constprop.41+0x124>
pf_mount():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:127
#endif
	init_spi();		/* Initialize ports to control MMC */
	DESELECT();
	for (n = 10; n; n--) rcv_spi();	/* 80 dummy clocks with CS=H */

	ty = 0;
    153e:	10 e0       	ldi	r17, 0x00	; 0
disk_initialize():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:149
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--) dly_100us();	/* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0)			/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
    1540:	10 93 79 02 	sts	0x0279, r17	; 0x800279 <CardType>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:150
	DESELECT();
    1544:	61 e0       	ldi	r22, 0x01	; 1
    1546:	84 e0       	ldi	r24, 0x04	; 4
    1548:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:151
	rcv_spi();
    154c:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
pf_mount():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:764

	if (disk_initialize() & STA_NOINIT)	/* Check if the drive is ready or not */
		return FR_NOT_READY;
    1550:	82 e0       	ldi	r24, 0x02	; 2
    1552:	90 e0       	ldi	r25, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:763
	DWORD bsect, fsize, tsect, mclst;


	FatFs = 0;

	if (disk_initialize() & STA_NOINIT)	/* Check if the drive is ready or not */
    1554:	11 23       	and	r17, r17
    1556:	e9 f0       	breq	.+58     	; 0x1592 <pf_mount.constprop.41+0xf6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:768
		return FR_NOT_READY;

	/* Search FAT partition on the drive */
	bsect = 0;
	fmt = check_fs(buf, bsect);			/* Check sector 0 as an SFD format */
    1558:	40 e0       	ldi	r20, 0x00	; 0
    155a:	50 e0       	ldi	r21, 0x00	; 0
    155c:	ba 01       	movw	r22, r20
    155e:	ce 01       	movw	r24, r28
    1560:	01 96       	adiw	r24, 0x01	; 1
    1562:	0e 94 07 0a 	call	0x140e	; 0x140e <check_fs(unsigned char*, unsigned long)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:767

	if (disk_initialize() & STA_NOINIT)	/* Check if the drive is ready or not */
		return FR_NOT_READY;

	/* Search FAT partition on the drive */
	bsect = 0;
    1566:	c1 2c       	mov	r12, r1
    1568:	d1 2c       	mov	r13, r1
    156a:	76 01       	movw	r14, r12
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:769
	fmt = check_fs(buf, bsect);			/* Check sector 0 as an SFD format */
	if (fmt == 1) {						/* Not an FAT boot record, it may be FDISK format */
    156c:	81 30       	cpi	r24, 0x01	; 1
    156e:	09 f0       	breq	.+2      	; 0x1572 <pf_mount.constprop.41+0xd6>
    1570:	96 c0       	rjmp	.+300    	; 0x169e <pf_mount.constprop.41+0x202>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:771
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) {	/* 1st partition entry */
    1572:	00 e1       	ldi	r16, 0x10	; 16
    1574:	10 e0       	ldi	r17, 0x00	; 0
    1576:	2e eb       	ldi	r18, 0xBE	; 190
    1578:	31 e0       	ldi	r19, 0x01	; 1
    157a:	40 e0       	ldi	r20, 0x00	; 0
    157c:	50 e0       	ldi	r21, 0x00	; 0
    157e:	ba 01       	movw	r22, r20
    1580:	ce 01       	movw	r24, r28
    1582:	01 96       	adiw	r24, 0x01	; 1
    1584:	0e 94 aa 09 	call	0x1354	; 0x1354 <disk_readp>
    1588:	89 2b       	or	r24, r25
    158a:	09 f4       	brne	.+2      	; 0x158e <pf_mount.constprop.41+0xf2>
    158c:	78 c0       	rjmp	.+240    	; 0x167e <pf_mount.constprop.41+0x1e2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:780
				bsect = LD_DWORD(&buf[8]);	/* Partition offset in LBA */
				fmt = check_fs(buf, bsect);	/* Check the partition */
			}
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    158e:	81 e0       	ldi	r24, 0x01	; 1
    1590:	90 e0       	ldi	r25, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:820

	fs->flag = 0;
	FatFs = fs;

	return FR_OK;
}
    1592:	a4 96       	adiw	r28, 0x24	; 36
    1594:	0f b6       	in	r0, 0x3f	; 63
    1596:	f8 94       	cli
    1598:	de bf       	out	0x3e, r29	; 62
    159a:	0f be       	out	0x3f, r0	; 63
    159c:	cd bf       	out	0x3d, r28	; 61
    159e:	df 91       	pop	r29
    15a0:	cf 91       	pop	r28
    15a2:	1f 91       	pop	r17
    15a4:	0f 91       	pop	r16
    15a6:	ff 90       	pop	r15
    15a8:	ef 90       	pop	r14
    15aa:	df 90       	pop	r13
    15ac:	cf 90       	pop	r12
    15ae:	bf 90       	pop	r11
    15b0:	af 90       	pop	r10
    15b2:	9f 90       	pop	r9
    15b4:	8f 90       	pop	r8
    15b6:	7f 90       	pop	r7
    15b8:	6f 90       	pop	r6
    15ba:	5f 90       	pop	r5
    15bc:	4f 90       	pop	r4
    15be:	08 95       	ret
disk_initialize():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:129
	DESELECT();
	for (n = 10; n; n--) rcv_spi();	/* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* GO_IDLE_STATE */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2 */
    15c0:	4a ea       	ldi	r20, 0xAA	; 170
    15c2:	51 e0       	ldi	r21, 0x01	; 1
    15c4:	60 e0       	ldi	r22, 0x00	; 0
    15c6:	70 e0       	ldi	r23, 0x00	; 0
    15c8:	88 e4       	ldi	r24, 0x48	; 72
    15ca:	0e 94 58 09 	call	0x12b0	; 0x12b0 <send_cmd(unsigned char, unsigned long)>
    15ce:	81 30       	cpi	r24, 0x01	; 1
    15d0:	91 f5       	brne	.+100    	; 0x1636 <pf_mount.constprop.41+0x19a>
    15d2:	ce 01       	movw	r24, r28
    15d4:	01 96       	adiw	r24, 0x01	; 1
    15d6:	7c 01       	movw	r14, r24
    15d8:	6e 01       	movw	r12, r28
    15da:	95 e0       	ldi	r25, 0x05	; 5
    15dc:	c9 0e       	add	r12, r25
    15de:	d1 1c       	adc	r13, r1
    15e0:	87 01       	movw	r16, r14
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:130
			for (n = 0; n < 4; n++) ocr[n] = rcv_spi();		/* Get trailing return value of R7 resp */
    15e2:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
    15e6:	f8 01       	movw	r30, r16
    15e8:	81 93       	st	Z+, r24
    15ea:	8f 01       	movw	r16, r30
    15ec:	ce 16       	cp	r12, r30
    15ee:	df 06       	cpc	r13, r31
    15f0:	c1 f7       	brne	.-16     	; 0x15e2 <pf_mount.constprop.41+0x146>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:131
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {			/* The card can work at vdd range of 2.7-3.6V */
    15f2:	8b 81       	ldd	r24, Y+3	; 0x03
    15f4:	81 30       	cpi	r24, 0x01	; 1
    15f6:	09 f0       	breq	.+2      	; 0x15fa <pf_mount.constprop.41+0x15e>
    15f8:	a2 cf       	rjmp	.-188    	; 0x153e <pf_mount.constprop.41+0xa2>
    15fa:	8c 81       	ldd	r24, Y+4	; 0x04
    15fc:	8a 3a       	cpi	r24, 0xAA	; 170
    15fe:	09 f0       	breq	.+2      	; 0x1602 <pf_mount.constprop.41+0x166>
    1600:	9e cf       	rjmp	.-196    	; 0x153e <pf_mount.constprop.41+0xa2>
    1602:	80 e1       	ldi	r24, 0x10	; 16
    1604:	c8 2e       	mov	r12, r24
    1606:	87 e2       	ldi	r24, 0x27	; 39
    1608:	d8 2e       	mov	r13, r24
_delay_loop_2():
c:\users\anthony\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
    160a:	90 e9       	ldi	r25, 0x90	; 144
    160c:	a9 2e       	mov	r10, r25
    160e:	bb 24       	eor	r11, r11
    1610:	b3 94       	inc	r11
disk_initialize():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:132
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--) dly_100us();	/* Wait for leaving idle state (ACMD41 with HCS bit) */
    1612:	40 e0       	ldi	r20, 0x00	; 0
    1614:	50 e0       	ldi	r21, 0x00	; 0
    1616:	60 e0       	ldi	r22, 0x00	; 0
    1618:	70 e4       	ldi	r23, 0x40	; 64
    161a:	89 ee       	ldi	r24, 0xE9	; 233
    161c:	0e 94 58 09 	call	0x12b0	; 0x12b0 <send_cmd(unsigned char, unsigned long)>
    1620:	88 23       	and	r24, r24
    1622:	09 f4       	brne	.+2      	; 0x1626 <pf_mount.constprop.41+0x18a>
    1624:	c9 c0       	rjmp	.+402    	; 0x17b8 <pf_mount.constprop.41+0x31c>
_delay_loop_2():
c:\users\anthony\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
    1626:	c5 01       	movw	r24, r10
    1628:	01 97       	sbiw	r24, 0x01	; 1
    162a:	f1 f7       	brne	.-4      	; 0x1628 <pf_mount.constprop.41+0x18c>
    162c:	f1 e0       	ldi	r31, 0x01	; 1
    162e:	cf 1a       	sub	r12, r31
    1630:	d1 08       	sbc	r13, r1
disk_initialize():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:132
    1632:	79 f7       	brne	.-34     	; 0x1612 <pf_mount.constprop.41+0x176>
    1634:	84 cf       	rjmp	.-248    	; 0x153e <pf_mount.constprop.41+0xa2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:139
					for (n = 0; n < 4; n++) ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 (HC or SC) */
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
    1636:	40 e0       	ldi	r20, 0x00	; 0
    1638:	50 e0       	ldi	r21, 0x00	; 0
    163a:	ba 01       	movw	r22, r20
    163c:	89 ee       	ldi	r24, 0xE9	; 233
    163e:	0e 94 58 09 	call	0x12b0	; 0x12b0 <send_cmd(unsigned char, unsigned long)>
pf_mount():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:142
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
    1642:	01 e4       	ldi	r16, 0x41	; 65
disk_initialize():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:139
					for (n = 0; n < 4; n++) ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 (HC or SC) */
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
    1644:	82 30       	cpi	r24, 0x02	; 2
    1646:	10 f4       	brcc	.+4      	; 0x164c <pf_mount.constprop.41+0x1b0>
pf_mount():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:140
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
    1648:	12 e0       	ldi	r17, 0x02	; 2
    164a:	09 ee       	ldi	r16, 0xE9	; 233
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:142
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
    164c:	a0 e1       	ldi	r26, 0x10	; 16
    164e:	ea 2e       	mov	r14, r26
    1650:	a7 e2       	ldi	r26, 0x27	; 39
    1652:	fa 2e       	mov	r15, r26
_delay_loop_2():
c:\users\anthony\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
    1654:	b0 e9       	ldi	r27, 0x90	; 144
    1656:	cb 2e       	mov	r12, r27
    1658:	dd 24       	eor	r13, r13
    165a:	d3 94       	inc	r13
disk_initialize():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:144
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--) dly_100us();	/* Wait for leaving idle state */
    165c:	40 e0       	ldi	r20, 0x00	; 0
    165e:	50 e0       	ldi	r21, 0x00	; 0
    1660:	ba 01       	movw	r22, r20
    1662:	80 2f       	mov	r24, r16
    1664:	0e 94 58 09 	call	0x12b0	; 0x12b0 <send_cmd(unsigned char, unsigned long)>
    1668:	88 23       	and	r24, r24
    166a:	09 f4       	brne	.+2      	; 0x166e <pf_mount.constprop.41+0x1d2>
    166c:	bb c0       	rjmp	.+374    	; 0x17e4 <pf_mount.constprop.41+0x348>
_delay_loop_2():
c:\users\anthony\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
    166e:	c6 01       	movw	r24, r12
    1670:	01 97       	sbiw	r24, 0x01	; 1
    1672:	f1 f7       	brne	.-4      	; 0x1670 <pf_mount.constprop.41+0x1d4>
    1674:	f1 e0       	ldi	r31, 0x01	; 1
    1676:	ef 1a       	sub	r14, r31
    1678:	f1 08       	sbc	r15, r1
disk_initialize():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:144
    167a:	81 f7       	brne	.-32     	; 0x165c <pf_mount.constprop.41+0x1c0>
    167c:	60 cf       	rjmp	.-320    	; 0x153e <pf_mount.constprop.41+0xa2>
pf_mount():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:774
	if (fmt == 1) {						/* Not an FAT boot record, it may be FDISK format */
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) {	/* 1st partition entry */
			fmt = 3;
		} else {
			if (buf[4]) {					/* Is the partition existing? */
    167e:	8d 81       	ldd	r24, Y+5	; 0x05
    1680:	81 11       	cpse	r24, r1
    1682:	03 c0       	rjmp	.+6      	; 0x168a <pf_mount.constprop.41+0x1ee>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:781
				fmt = check_fs(buf, bsect);	/* Check the partition */
			}
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;	/* No valid FAT patition is found */
    1684:	86 e0       	ldi	r24, 0x06	; 6
    1686:	90 e0       	ldi	r25, 0x00	; 0
    1688:	84 cf       	rjmp	.-248    	; 0x1592 <pf_mount.constprop.41+0xf6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:775
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) {	/* 1st partition entry */
			fmt = 3;
		} else {
			if (buf[4]) {					/* Is the partition existing? */
				bsect = LD_DWORD(&buf[8]);	/* Partition offset in LBA */
    168a:	c9 84       	ldd	r12, Y+9	; 0x09
    168c:	da 84       	ldd	r13, Y+10	; 0x0a
    168e:	eb 84       	ldd	r14, Y+11	; 0x0b
    1690:	fc 84       	ldd	r15, Y+12	; 0x0c
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:776
				fmt = check_fs(buf, bsect);	/* Check the partition */
    1692:	b7 01       	movw	r22, r14
    1694:	a6 01       	movw	r20, r12
    1696:	ce 01       	movw	r24, r28
    1698:	01 96       	adiw	r24, 0x01	; 1
    169a:	0e 94 07 0a 	call	0x140e	; 0x140e <check_fs(unsigned char*, unsigned long)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:780
			}
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    169e:	83 30       	cpi	r24, 0x03	; 3
    16a0:	09 f4       	brne	.+2      	; 0x16a4 <pf_mount.constprop.41+0x208>
    16a2:	75 cf       	rjmp	.-278    	; 0x158e <pf_mount.constprop.41+0xf2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:781
	if (fmt) return FR_NO_FILESYSTEM;	/* No valid FAT patition is found */
    16a4:	81 11       	cpse	r24, r1
    16a6:	ee cf       	rjmp	.-36     	; 0x1684 <pf_mount.constprop.41+0x1e8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:784

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof (buf))) return FR_DISK_ERR;
    16a8:	04 e2       	ldi	r16, 0x24	; 36
    16aa:	10 e0       	ldi	r17, 0x00	; 0
    16ac:	2d e0       	ldi	r18, 0x0D	; 13
    16ae:	30 e0       	ldi	r19, 0x00	; 0
    16b0:	b7 01       	movw	r22, r14
    16b2:	a6 01       	movw	r20, r12
    16b4:	ce 01       	movw	r24, r28
    16b6:	01 96       	adiw	r24, 0x01	; 1
    16b8:	0e 94 aa 09 	call	0x1354	; 0x1354 <disk_readp>
    16bc:	89 2b       	or	r24, r25
    16be:	09 f0       	breq	.+2      	; 0x16c2 <pf_mount.constprop.41+0x226>
    16c0:	66 cf       	rjmp	.-308    	; 0x158e <pf_mount.constprop.41+0xf2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:786

	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
    16c2:	2a 85       	ldd	r18, Y+10	; 0x0a
    16c4:	3b 85       	ldd	r19, Y+11	; 0x0b
    16c6:	50 e0       	ldi	r21, 0x00	; 0
    16c8:	40 e0       	ldi	r20, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:787
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);
    16ca:	21 15       	cp	r18, r1
    16cc:	31 05       	cpc	r19, r1
    16ce:	41 05       	cpc	r20, r1
    16d0:	51 05       	cpc	r21, r1
    16d2:	21 f4       	brne	.+8      	; 0x16dc <pf_mount.constprop.41+0x240>
    16d4:	28 8d       	ldd	r18, Y+24	; 0x18
    16d6:	39 8d       	ldd	r19, Y+25	; 0x19
    16d8:	4a 8d       	ldd	r20, Y+26	; 0x1a
    16da:	5b 8d       	ldd	r21, Y+27	; 0x1b
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:789

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
    16dc:	ac 81       	ldd	r26, Y+4	; 0x04
    16de:	b0 e0       	ldi	r27, 0x00	; 0
    16e0:	0e 94 1d 25 	call	0x4a3a	; 0x4a3a <__muluhisi3>
    16e4:	4b 01       	movw	r8, r22
    16e6:	5c 01       	movw	r10, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:790
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
    16e8:	4a 81       	ldd	r20, Y+2	; 0x02
    16ea:	5b 81       	ldd	r21, Y+3	; 0x03
    16ec:	70 e0       	ldi	r23, 0x00	; 0
    16ee:	60 e0       	ldi	r22, 0x00	; 0
    16f0:	c4 0e       	add	r12, r20
    16f2:	d5 1e       	adc	r13, r21
    16f4:	e6 1e       	adc	r14, r22
    16f6:	f7 1e       	adc	r15, r23
    16f8:	c0 92 84 02 	sts	0x0284, r12	; 0x800284 <filesysSD+0xa>
    16fc:	d0 92 85 02 	sts	0x0285, r13	; 0x800285 <filesysSD+0xb>
    1700:	e0 92 86 02 	sts	0x0286, r14	; 0x800286 <filesysSD+0xc>
    1704:	f0 92 87 02 	sts	0x0287, r15	; 0x800287 <filesysSD+0xd>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:791
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
    1708:	e9 81       	ldd	r30, Y+1	; 0x01
    170a:	e0 93 7c 02 	sts	0x027C, r30	; 0x80027c <filesysSD+0x2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:792
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
    170e:	8d 81       	ldd	r24, Y+5	; 0x05
    1710:	9e 81       	ldd	r25, Y+6	; 0x06
    1712:	90 93 7f 02 	sts	0x027F, r25	; 0x80027f <filesysSD+0x5>
    1716:	80 93 7e 02 	sts	0x027E, r24	; 0x80027e <filesysSD+0x4>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:793
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
    171a:	0f 81       	ldd	r16, Y+7	; 0x07
    171c:	18 85       	ldd	r17, Y+8	; 0x08
    171e:	30 e0       	ldi	r19, 0x00	; 0
    1720:	20 e0       	ldi	r18, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:794
	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
    1722:	01 15       	cp	r16, r1
    1724:	11 05       	cpc	r17, r1
    1726:	21 05       	cpc	r18, r1
    1728:	31 05       	cpc	r19, r1
    172a:	21 f4       	brne	.+8      	; 0x1734 <pf_mount.constprop.41+0x298>
    172c:	0c 89       	ldd	r16, Y+20	; 0x14
    172e:	1d 89       	ldd	r17, Y+21	; 0x15
    1730:	2e 89       	ldd	r18, Y+22	; 0x16
    1732:	3f 89       	ldd	r19, Y+23	; 0x17
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:796
	mclst = (tsect						/* Last cluster# + 1 */
		- LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
    1734:	f4 e0       	ldi	r31, 0x04	; 4
    1736:	96 95       	lsr	r25
    1738:	87 95       	ror	r24
    173a:	fa 95       	dec	r31
    173c:	e1 f7       	brne	.-8      	; 0x1736 <pf_mount.constprop.41+0x29a>
    173e:	2c 01       	movw	r4, r24
    1740:	71 2c       	mov	r7, r1
    1742:	61 2c       	mov	r6, r1
    1744:	04 1b       	sub	r16, r20
    1746:	15 0b       	sbc	r17, r21
    1748:	26 0b       	sbc	r18, r22
    174a:	37 0b       	sbc	r19, r23
    174c:	c9 01       	movw	r24, r18
    174e:	b8 01       	movw	r22, r16
    1750:	68 19       	sub	r22, r8
    1752:	79 09       	sbc	r23, r9
    1754:	8a 09       	sbc	r24, r10
    1756:	9b 09       	sbc	r25, r11
    1758:	64 19       	sub	r22, r4
    175a:	75 09       	sbc	r23, r5
    175c:	86 09       	sbc	r24, r6
    175e:	97 09       	sbc	r25, r7
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:797
		) / fs->csize + 2;
    1760:	2e 2f       	mov	r18, r30
    1762:	30 e0       	ldi	r19, 0x00	; 0
    1764:	50 e0       	ldi	r21, 0x00	; 0
    1766:	40 e0       	ldi	r20, 0x00	; 0
    1768:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <__udivmodsi4>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:795
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
	mclst = (tsect						/* Last cluster# + 1 */
    176c:	da 01       	movw	r26, r20
    176e:	c9 01       	movw	r24, r18
    1770:	02 96       	adiw	r24, 0x02	; 2
    1772:	a1 1d       	adc	r26, r1
    1774:	b1 1d       	adc	r27, r1
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:798
		- LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
		) / fs->csize + 2;
	fs->n_fatent = (CLUST)mclst;
    1776:	80 93 80 02 	sts	0x0280, r24	; 0x800280 <filesysSD+0x6>
    177a:	90 93 81 02 	sts	0x0281, r25	; 0x800281 <filesysSD+0x7>
    177e:	a0 93 82 02 	sts	0x0282, r26	; 0x800282 <filesysSD+0x8>
    1782:	b0 93 83 02 	sts	0x0283, r27	; 0x800283 <filesysSD+0x9>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:803

	fmt = 0;							/* Determine the FAT sub type */
	if (_FS_FAT12 && mclst < 0xFF7)
		fmt = FS_FAT12;
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
    1786:	26 5f       	subi	r18, 0xF6	; 246
    1788:	3f 40       	sbci	r19, 0x0F	; 15
    178a:	41 09       	sbc	r20, r1
    178c:	51 09       	sbc	r21, r1
    178e:	2f 3f       	cpi	r18, 0xFF	; 255
    1790:	3f 4e       	sbci	r19, 0xEF	; 239
    1792:	41 05       	cpc	r20, r1
    1794:	51 05       	cpc	r21, r1
    1796:	88 f1       	brcs	.+98     	; 0x17fa <pf_mount.constprop.41+0x35e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:805
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
    1798:	87 3f       	cpi	r24, 0xF7	; 247
    179a:	9f 4f       	sbci	r25, 0xFF	; 255
    179c:	a1 05       	cpc	r26, r1
    179e:	b1 05       	cpc	r27, r1
    17a0:	88 f5       	brcc	.+98     	; 0x1804 <pf_mount.constprop.41+0x368>
    17a2:	70 cf       	rjmp	.-288    	; 0x1684 <pf_mount.constprop.41+0x1e8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:808
		fmt = FS_FAT32;
	if (!fmt) return FR_NO_FILESYSTEM;
	fs->fs_type = fmt;
    17a4:	82 e0       	ldi	r24, 0x02	; 2
    17a6:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <filesysSD>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:813

	if (_FS_32ONLY || (_FS_FAT32 && fmt == FS_FAT32))
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
    17aa:	d5 01       	movw	r26, r10
    17ac:	c4 01       	movw	r24, r8
    17ae:	8c 0d       	add	r24, r12
    17b0:	9d 1d       	adc	r25, r13
    17b2:	ae 1d       	adc	r26, r14
    17b4:	bf 1d       	adc	r27, r15
    17b6:	2d c0       	rjmp	.+90     	; 0x1812 <pf_mount.constprop.41+0x376>
disk_initialize():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:133
	if (send_cmd(CMD0, 0) == 1) {			/* GO_IDLE_STATE */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2 */
			for (n = 0; n < 4; n++) ocr[n] = rcv_spi();		/* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {			/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--) dly_100us();	/* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
    17b8:	40 e0       	ldi	r20, 0x00	; 0
    17ba:	50 e0       	ldi	r21, 0x00	; 0
    17bc:	ba 01       	movw	r22, r20
    17be:	8a e7       	ldi	r24, 0x7A	; 122
    17c0:	0e 94 58 09 	call	0x12b0	; 0x12b0 <send_cmd(unsigned char, unsigned long)>
    17c4:	81 11       	cpse	r24, r1
    17c6:	bb ce       	rjmp	.-650    	; 0x153e <pf_mount.constprop.41+0xa2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:134
					for (n = 0; n < 4; n++) ocr[n] = rcv_spi();
    17c8:	0e 94 17 09 	call	0x122e	; 0x122e <rcv_spi()>
    17cc:	f7 01       	movw	r30, r14
    17ce:	81 93       	st	Z+, r24
    17d0:	7f 01       	movw	r14, r30
    17d2:	0e 17       	cp	r16, r30
    17d4:	1f 07       	cpc	r17, r31
    17d6:	c1 f7       	brne	.-16     	; 0x17c8 <pf_mount.constprop.41+0x32c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:135
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 (HC or SC) */
    17d8:	89 81       	ldd	r24, Y+1	; 0x01
pf_mount():
    17da:	1c e0       	ldi	r17, 0x0C	; 12
disk_initialize():
    17dc:	86 fd       	sbrc	r24, 6
    17de:	b0 ce       	rjmp	.-672    	; 0x1540 <pf_mount.constprop.41+0xa4>
pf_mount():
    17e0:	14 e0       	ldi	r17, 0x04	; 4
    17e2:	ae ce       	rjmp	.-676    	; 0x1540 <pf_mount.constprop.41+0xa4>
disk_initialize():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:145
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--) dly_100us();	/* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0)			/* Set R/W block length to 512 */
    17e4:	40 e0       	ldi	r20, 0x00	; 0
    17e6:	52 e0       	ldi	r21, 0x02	; 2
    17e8:	60 e0       	ldi	r22, 0x00	; 0
    17ea:	70 e0       	ldi	r23, 0x00	; 0
    17ec:	80 e5       	ldi	r24, 0x50	; 80
    17ee:	0e 94 58 09 	call	0x12b0	; 0x12b0 <send_cmd(unsigned char, unsigned long)>
    17f2:	88 23       	and	r24, r24
    17f4:	09 f4       	brne	.+2      	; 0x17f8 <pf_mount.constprop.41+0x35c>
    17f6:	a4 ce       	rjmp	.-696    	; 0x1540 <pf_mount.constprop.41+0xa4>
    17f8:	a2 ce       	rjmp	.-700    	; 0x153e <pf_mount.constprop.41+0xa2>
pf_mount():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:805
	fmt = 0;							/* Determine the FAT sub type */
	if (_FS_FAT12 && mclst < 0xFF7)
		fmt = FS_FAT12;
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
    17fa:	87 3f       	cpi	r24, 0xF7	; 247
    17fc:	9f 4f       	sbci	r25, 0xFF	; 255
    17fe:	a1 05       	cpc	r26, r1
    1800:	b1 05       	cpc	r27, r1
    1802:	80 f2       	brcs	.-96     	; 0x17a4 <pf_mount.constprop.41+0x308>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:808
		fmt = FS_FAT32;
	if (!fmt) return FR_NO_FILESYSTEM;
	fs->fs_type = fmt;
    1804:	83 e0       	ldi	r24, 0x03	; 3
    1806:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <filesysSD>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:811

	if (_FS_32ONLY || (_FS_FAT32 && fmt == FS_FAT32))
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
    180a:	88 a1       	ldd	r24, Y+32	; 0x20
    180c:	99 a1       	ldd	r25, Y+33	; 0x21
    180e:	aa a1       	ldd	r26, Y+34	; 0x22
    1810:	bb a1       	ldd	r27, Y+35	; 0x23
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:813
	else
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
    1812:	80 93 88 02 	sts	0x0288, r24	; 0x800288 <filesysSD+0xe>
    1816:	90 93 89 02 	sts	0x0289, r25	; 0x800289 <filesysSD+0xf>
    181a:	a0 93 8a 02 	sts	0x028A, r26	; 0x80028a <filesysSD+0x10>
    181e:	b0 93 8b 02 	sts	0x028B, r27	; 0x80028b <filesysSD+0x11>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:814
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16;	/* Data start sector (lba) */
    1822:	c4 0c       	add	r12, r4
    1824:	d5 1c       	adc	r13, r5
    1826:	e6 1c       	adc	r14, r6
    1828:	f7 1c       	adc	r15, r7
    182a:	8c 0c       	add	r8, r12
    182c:	9d 1c       	adc	r9, r13
    182e:	ae 1c       	adc	r10, r14
    1830:	bf 1c       	adc	r11, r15
    1832:	80 92 8c 02 	sts	0x028C, r8	; 0x80028c <filesysSD+0x12>
    1836:	90 92 8d 02 	sts	0x028D, r9	; 0x80028d <filesysSD+0x13>
    183a:	a0 92 8e 02 	sts	0x028E, r10	; 0x80028e <filesysSD+0x14>
    183e:	b0 92 8f 02 	sts	0x028F, r11	; 0x80028f <filesysSD+0x15>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:816

	fs->flag = 0;
    1842:	10 92 7b 02 	sts	0x027B, r1	; 0x80027b <filesysSD+0x1>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:817
	FatFs = fs;
    1846:	8a e7       	ldi	r24, 0x7A	; 122
    1848:	92 e0       	ldi	r25, 0x02	; 2
    184a:	90 93 a5 02 	sts	0x02A5, r25	; 0x8002a5 <FatFs+0x1>
    184e:	80 93 a4 02 	sts	0x02A4, r24	; 0x8002a4 <FatFs>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:819

	return FR_OK;
    1852:	90 e0       	ldi	r25, 0x00	; 0
    1854:	80 e0       	ldi	r24, 0x00	; 0
    1856:	9d ce       	rjmp	.-710    	; 0x1592 <pf_mount.constprop.41+0xf6>

00001858 <get_fat(unsigned long)>:
get_fat():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:352

static
CLUST get_fat (	/* 1:IO error, Else:Cluster status */
	CLUST clst	/* Cluster# to get the link information */
)
{
    1858:	0f 93       	push	r16
    185a:	1f 93       	push	r17
    185c:	cf 93       	push	r28
    185e:	df 93       	push	r29
    1860:	00 d0       	rcall	.+0      	; 0x1862 <get_fat(unsigned long)+0xa>
    1862:	00 d0       	rcall	.+0      	; 0x1864 <get_fat(unsigned long)+0xc>
    1864:	cd b7       	in	r28, 0x3d	; 61
    1866:	de b7       	in	r29, 0x3e	; 62
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:356
	BYTE buf[4];
	FATFS *fs = FatFs;

	if (clst < 2 || clst >= fs->n_fatent)	/* Range check */
    1868:	62 30       	cpi	r22, 0x02	; 2
    186a:	71 05       	cpc	r23, r1
    186c:	81 05       	cpc	r24, r1
    186e:	91 05       	cpc	r25, r1
    1870:	28 f4       	brcc	.+10     	; 0x187c <get_fat(unsigned long)+0x24>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:388
		if (disk_readp(buf, fs->fatbase + clst / 128, ((UINT)clst % 128) * 4, 4)) break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
#endif
	}

	return 1;	/* An error occured at the disk I/O layer */
    1872:	61 e0       	ldi	r22, 0x01	; 1
    1874:	70 e0       	ldi	r23, 0x00	; 0
    1876:	80 e0       	ldi	r24, 0x00	; 0
    1878:	90 e0       	ldi	r25, 0x00	; 0
    187a:	55 c0       	rjmp	.+170    	; 0x1926 <get_fat(unsigned long)+0xce>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:354
CLUST get_fat (	/* 1:IO error, Else:Cluster status */
	CLUST clst	/* Cluster# to get the link information */
)
{
	BYTE buf[4];
	FATFS *fs = FatFs;
    187c:	e0 91 a4 02 	lds	r30, 0x02A4	; 0x8002a4 <FatFs>
    1880:	f0 91 a5 02 	lds	r31, 0x02A5	; 0x8002a5 <FatFs+0x1>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:356

	if (clst < 2 || clst >= fs->n_fatent)	/* Range check */
    1884:	06 81       	ldd	r16, Z+6	; 0x06
    1886:	17 81       	ldd	r17, Z+7	; 0x07
    1888:	20 85       	ldd	r18, Z+8	; 0x08
    188a:	31 85       	ldd	r19, Z+9	; 0x09
    188c:	60 17       	cp	r22, r16
    188e:	71 07       	cpc	r23, r17
    1890:	82 07       	cpc	r24, r18
    1892:	93 07       	cpc	r25, r19
    1894:	70 f7       	brcc	.-36     	; 0x1872 <get_fat(unsigned long)+0x1a>
    1896:	ab 01       	movw	r20, r22
    1898:	bc 01       	movw	r22, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:359
		return 1;

	switch (fs->fs_type) {
    189a:	80 81       	ld	r24, Z
    189c:	82 30       	cpi	r24, 0x02	; 2
    189e:	31 f1       	breq	.+76     	; 0x18ec <get_fat(unsigned long)+0x94>
    18a0:	83 30       	cpi	r24, 0x03	; 3
    18a2:	39 f7       	brne	.-50     	; 0x1872 <get_fat(unsigned long)+0x1a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:383
		if (disk_readp(buf, fs->fatbase + clst / 256, ((UINT)clst % 256) * 2, 2)) break;
		return LD_WORD(buf);
#endif
#if _FS_FAT32
	case FS_FAT32 :
		if (disk_readp(buf, fs->fatbase + clst / 128, ((UINT)clst % 128) * 4, 4)) break;
    18a4:	9a 01       	movw	r18, r20
    18a6:	2f 77       	andi	r18, 0x7F	; 127
    18a8:	33 27       	eor	r19, r19
    18aa:	22 0f       	add	r18, r18
    18ac:	33 1f       	adc	r19, r19
    18ae:	22 0f       	add	r18, r18
    18b0:	33 1f       	adc	r19, r19
    18b2:	97 e0       	ldi	r25, 0x07	; 7
    18b4:	76 95       	lsr	r23
    18b6:	67 95       	ror	r22
    18b8:	57 95       	ror	r21
    18ba:	47 95       	ror	r20
    18bc:	9a 95       	dec	r25
    18be:	d1 f7       	brne	.-12     	; 0x18b4 <get_fat(unsigned long)+0x5c>
    18c0:	82 85       	ldd	r24, Z+10	; 0x0a
    18c2:	93 85       	ldd	r25, Z+11	; 0x0b
    18c4:	a4 85       	ldd	r26, Z+12	; 0x0c
    18c6:	b5 85       	ldd	r27, Z+13	; 0x0d
    18c8:	48 0f       	add	r20, r24
    18ca:	59 1f       	adc	r21, r25
    18cc:	6a 1f       	adc	r22, r26
    18ce:	7b 1f       	adc	r23, r27
    18d0:	04 e0       	ldi	r16, 0x04	; 4
    18d2:	10 e0       	ldi	r17, 0x00	; 0
    18d4:	ce 01       	movw	r24, r28
    18d6:	01 96       	adiw	r24, 0x01	; 1
    18d8:	0e 94 aa 09 	call	0x1354	; 0x1354 <disk_readp>
    18dc:	89 2b       	or	r24, r25
    18de:	49 f6       	brne	.-110    	; 0x1872 <get_fat(unsigned long)+0x1a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:384
		return LD_DWORD(buf) & 0x0FFFFFFF;
    18e0:	69 81       	ldd	r22, Y+1	; 0x01
    18e2:	7a 81       	ldd	r23, Y+2	; 0x02
    18e4:	8b 81       	ldd	r24, Y+3	; 0x03
    18e6:	9c 81       	ldd	r25, Y+4	; 0x04
    18e8:	9f 70       	andi	r25, 0x0F	; 15
    18ea:	1d c0       	rjmp	.+58     	; 0x1926 <get_fat(unsigned long)+0xce>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:378
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
	}
#endif
#if _FS_FAT16
	case FS_FAT16 :
		if (disk_readp(buf, fs->fatbase + clst / 256, ((UINT)clst % 256) * 2, 2)) break;
    18ec:	9a 01       	movw	r18, r20
    18ee:	33 27       	eor	r19, r19
    18f0:	22 0f       	add	r18, r18
    18f2:	33 1f       	adc	r19, r19
    18f4:	45 2f       	mov	r20, r21
    18f6:	56 2f       	mov	r21, r22
    18f8:	67 2f       	mov	r22, r23
    18fa:	77 27       	eor	r23, r23
    18fc:	82 85       	ldd	r24, Z+10	; 0x0a
    18fe:	93 85       	ldd	r25, Z+11	; 0x0b
    1900:	a4 85       	ldd	r26, Z+12	; 0x0c
    1902:	b5 85       	ldd	r27, Z+13	; 0x0d
    1904:	48 0f       	add	r20, r24
    1906:	59 1f       	adc	r21, r25
    1908:	6a 1f       	adc	r22, r26
    190a:	7b 1f       	adc	r23, r27
    190c:	02 e0       	ldi	r16, 0x02	; 2
    190e:	10 e0       	ldi	r17, 0x00	; 0
    1910:	ce 01       	movw	r24, r28
    1912:	01 96       	adiw	r24, 0x01	; 1
    1914:	0e 94 aa 09 	call	0x1354	; 0x1354 <disk_readp>
    1918:	89 2b       	or	r24, r25
    191a:	09 f0       	breq	.+2      	; 0x191e <get_fat(unsigned long)+0xc6>
    191c:	aa cf       	rjmp	.-172    	; 0x1872 <get_fat(unsigned long)+0x1a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:379
		return LD_WORD(buf);
    191e:	69 81       	ldd	r22, Y+1	; 0x01
    1920:	7a 81       	ldd	r23, Y+2	; 0x02
    1922:	90 e0       	ldi	r25, 0x00	; 0
    1924:	80 e0       	ldi	r24, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:389
		return LD_DWORD(buf) & 0x0FFFFFFF;
#endif
	}

	return 1;	/* An error occured at the disk I/O layer */
}
    1926:	0f 90       	pop	r0
    1928:	0f 90       	pop	r0
    192a:	0f 90       	pop	r0
    192c:	0f 90       	pop	r0
    192e:	df 91       	pop	r29
    1930:	cf 91       	pop	r28
    1932:	1f 91       	pop	r17
    1934:	0f 91       	pop	r16
    1936:	08 95       	ret

00001938 <pf_read.constprop.36>:
pf_read():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:864
/*-----------------------------------------------------------------------*/
/* Read File                                                             */
/*-----------------------------------------------------------------------*/
#if _USE_READ

FRESULT pf_read (
    1938:	6f 92       	push	r6
    193a:	7f 92       	push	r7
    193c:	8f 92       	push	r8
    193e:	9f 92       	push	r9
    1940:	af 92       	push	r10
    1942:	bf 92       	push	r11
    1944:	cf 92       	push	r12
    1946:	df 92       	push	r13
    1948:	ef 92       	push	r14
    194a:	ff 92       	push	r15
    194c:	0f 93       	push	r16
    194e:	1f 93       	push	r17
    1950:	cf 93       	push	r28
    1952:	df 93       	push	r29
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:875
	DRESULT dr;
	CLUST clst;
	DWORD sect, remain;
	UINT rcnt;
	BYTE cs, *rbuff = (BYTE*)buff;  // whg
	FATFS *fs = FatFs;
    1954:	c0 91 a4 02 	lds	r28, 0x02A4	; 0x8002a4 <FatFs>
    1958:	d0 91 a5 02 	lds	r29, 0x02A5	; 0x8002a5 <FatFs+0x1>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:878


	*br = 0;
    195c:	fc 01       	movw	r30, r24
    195e:	11 82       	std	Z+1, r1	; 0x01
    1960:	10 82       	st	Z, r1
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:879
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    1962:	20 97       	sbiw	r28, 0x00	; 0
    1964:	09 f4       	brne	.+2      	; 0x1968 <pf_read.constprop.36+0x30>
    1966:	af c0       	rjmp	.+350    	; 0x1ac6 <pf_read.constprop.36+0x18e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:880
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
    1968:	29 81       	ldd	r18, Y+1	; 0x01
    196a:	20 ff       	sbrs	r18, 0
    196c:	af c0       	rjmp	.+350    	; 0x1acc <pf_read.constprop.36+0x194>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:883
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
    196e:	0a 8d       	ldd	r16, Y+26	; 0x1a
    1970:	1b 8d       	ldd	r17, Y+27	; 0x1b
    1972:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1974:	3d 8d       	ldd	r19, Y+29	; 0x1d
    1976:	4e 89       	ldd	r20, Y+22	; 0x16
    1978:	5f 89       	ldd	r21, Y+23	; 0x17
    197a:	68 8d       	ldd	r22, Y+24	; 0x18
    197c:	79 8d       	ldd	r23, Y+25	; 0x19
    197e:	68 01       	movw	r12, r16
    1980:	79 01       	movw	r14, r18
    1982:	c4 1a       	sub	r12, r20
    1984:	d5 0a       	sbc	r13, r21
    1986:	e6 0a       	sbc	r14, r22
    1988:	f7 0a       	sbc	r15, r23
    198a:	b7 01       	movw	r22, r14
    198c:	a6 01       	movw	r20, r12
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:884
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
    198e:	40 32       	cpi	r20, 0x20	; 32
    1990:	51 05       	cpc	r21, r1
    1992:	61 05       	cpc	r22, r1
    1994:	71 05       	cpc	r23, r1
    1996:	20 f0       	brcs	.+8      	; 0x19a0 <pf_read.constprop.36+0x68>
    1998:	40 e2       	ldi	r20, 0x20	; 32
    199a:	50 e0       	ldi	r21, 0x00	; 0
    199c:	60 e0       	ldi	r22, 0x00	; 0
    199e:	70 e0       	ldi	r23, 0x00	; 0
    19a0:	5c 01       	movw	r10, r24
    19a2:	7a 01       	movw	r14, r20
    19a4:	39 e5       	ldi	r19, 0x59	; 89
    19a6:	83 2e       	mov	r8, r19
    19a8:	32 e0       	ldi	r19, 0x02	; 2
    19aa:	93 2e       	mov	r9, r19
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:901
			}
			sect = clust2sect(fs->curr_clust);		/* Get current sector */
			if (!sect) ABORT(FR_DISK_ERR);
			fs->dsect = sect + cs;
		}
		rcnt = 512 - (UINT)fs->fptr % 512;			/* Get partial sector data from sector buffer */
    19ac:	61 2c       	mov	r6, r1
    19ae:	42 e0       	ldi	r20, 0x02	; 2
    19b0:	74 2e       	mov	r7, r20
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:886
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	while (btr)	{									/* Repeat until all data transferred */
    19b2:	e1 14       	cp	r14, r1
    19b4:	f1 04       	cpc	r15, r1
    19b6:	09 f4       	brne	.+2      	; 0x19ba <pf_read.constprop.36+0x82>
    19b8:	8c c0       	rjmp	.+280    	; 0x1ad2 <pf_read.constprop.36+0x19a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:887
		if ((fs->fptr % 512) == 0) {				/* On the sector boundary? */
    19ba:	8e 89       	ldd	r24, Y+22	; 0x16
    19bc:	9f 89       	ldd	r25, Y+23	; 0x17
    19be:	a8 8d       	ldd	r26, Y+24	; 0x18
    19c0:	b9 8d       	ldd	r27, Y+25	; 0x19
    19c2:	ac 01       	movw	r20, r24
    19c4:	bd 01       	movw	r22, r26
    19c6:	51 70       	andi	r21, 0x01	; 1
    19c8:	66 27       	eor	r22, r22
    19ca:	77 27       	eor	r23, r23
    19cc:	45 2b       	or	r20, r21
    19ce:	46 2b       	or	r20, r22
    19d0:	47 2b       	or	r20, r23
    19d2:	09 f0       	breq	.+2      	; 0x19d6 <pf_read.constprop.36+0x9e>
    19d4:	4a c0       	rjmp	.+148    	; 0x1a6a <pf_read.constprop.36+0x132>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:888
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1));	/* Sector offset in the cluster */
    19d6:	da 80       	ldd	r13, Y+2	; 0x02
    19d8:	da 94       	dec	r13
    19da:	ac 01       	movw	r20, r24
    19dc:	bd 01       	movw	r22, r26
    19de:	29 e0       	ldi	r18, 0x09	; 9
    19e0:	76 95       	lsr	r23
    19e2:	67 95       	ror	r22
    19e4:	57 95       	ror	r21
    19e6:	47 95       	ror	r20
    19e8:	2a 95       	dec	r18
    19ea:	d1 f7       	brne	.-12     	; 0x19e0 <pf_read.constprop.36+0xa8>
    19ec:	d4 22       	and	r13, r20
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:889
			if (!cs) {								/* On the cluster boundary? */
    19ee:	51 f5       	brne	.+84     	; 0x1a44 <pf_read.constprop.36+0x10c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:890
				if (fs->fptr == 0)					/* On the top of the file? */
    19f0:	89 2b       	or	r24, r25
    19f2:	8a 2b       	or	r24, r26
    19f4:	8b 2b       	or	r24, r27
    19f6:	d9 f4       	brne	.+54     	; 0x1a2e <pf_read.constprop.36+0xf6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:891
					clst = fs->org_clust;
    19f8:	6e 8d       	ldd	r22, Y+30	; 0x1e
    19fa:	7f 8d       	ldd	r23, Y+31	; 0x1f
    19fc:	88 a1       	ldd	r24, Y+32	; 0x20
    19fe:	99 a1       	ldd	r25, Y+33	; 0x21
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:894
				else
					clst = get_fat(fs->curr_clust);
				if (clst <= 1) ABORT(FR_DISK_ERR);
    1a00:	62 30       	cpi	r22, 0x02	; 2
    1a02:	71 05       	cpc	r23, r1
    1a04:	81 05       	cpc	r24, r1
    1a06:	91 05       	cpc	r25, r1
    1a08:	c8 f4       	brcc	.+50     	; 0x1a3c <pf_read.constprop.36+0x104>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:904
			fs->dsect = sect + cs;
		}
		rcnt = 512 - (UINT)fs->fptr % 512;			/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
		if (dr) ABORT(FR_DISK_ERR);
    1a0a:	19 82       	std	Y+1, r1	; 0x01
    1a0c:	81 e0       	ldi	r24, 0x01	; 1
    1a0e:	90 e0       	ldi	r25, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:910
		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
		btr -= rcnt; *br += rcnt;
	}

	return FR_OK;
}
    1a10:	df 91       	pop	r29
    1a12:	cf 91       	pop	r28
    1a14:	1f 91       	pop	r17
    1a16:	0f 91       	pop	r16
    1a18:	ff 90       	pop	r15
    1a1a:	ef 90       	pop	r14
    1a1c:	df 90       	pop	r13
    1a1e:	cf 90       	pop	r12
    1a20:	bf 90       	pop	r11
    1a22:	af 90       	pop	r10
    1a24:	9f 90       	pop	r9
    1a26:	8f 90       	pop	r8
    1a28:	7f 90       	pop	r7
    1a2a:	6f 90       	pop	r6
    1a2c:	08 95       	ret
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:893
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1));	/* Sector offset in the cluster */
			if (!cs) {								/* On the cluster boundary? */
				if (fs->fptr == 0)					/* On the top of the file? */
					clst = fs->org_clust;
				else
					clst = get_fat(fs->curr_clust);
    1a2e:	6a a1       	ldd	r22, Y+34	; 0x22
    1a30:	7b a1       	ldd	r23, Y+35	; 0x23
    1a32:	8c a1       	ldd	r24, Y+36	; 0x24
    1a34:	9d a1       	ldd	r25, Y+37	; 0x25
    1a36:	0e 94 2c 0c 	call	0x1858	; 0x1858 <get_fat(unsigned long)>
    1a3a:	e2 cf       	rjmp	.-60     	; 0x1a00 <pf_read.constprop.36+0xc8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:895
				if (clst <= 1) ABORT(FR_DISK_ERR);
				fs->curr_clust = clst;				/* Update current cluster */
    1a3c:	6a a3       	std	Y+34, r22	; 0x22
    1a3e:	7b a3       	std	Y+35, r23	; 0x23
    1a40:	8c a3       	std	Y+36, r24	; 0x24
    1a42:	9d a3       	std	Y+37, r25	; 0x25
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:897
			}
			sect = clust2sect(fs->curr_clust);		/* Get current sector */
    1a44:	6a a1       	ldd	r22, Y+34	; 0x22
    1a46:	7b a1       	ldd	r23, Y+35	; 0x23
    1a48:	8c a1       	ldd	r24, Y+36	; 0x24
    1a4a:	9d a1       	ldd	r25, Y+37	; 0x25
    1a4c:	0e 94 a1 08 	call	0x1142	; 0x1142 <clust2sect(unsigned long)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:898
			if (!sect) ABORT(FR_DISK_ERR);
    1a50:	61 15       	cp	r22, r1
    1a52:	71 05       	cpc	r23, r1
    1a54:	81 05       	cpc	r24, r1
    1a56:	91 05       	cpc	r25, r1
    1a58:	c1 f2       	breq	.-80     	; 0x1a0a <pf_read.constprop.36+0xd2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:899
			fs->dsect = sect + cs;
    1a5a:	6d 0d       	add	r22, r13
    1a5c:	71 1d       	adc	r23, r1
    1a5e:	81 1d       	adc	r24, r1
    1a60:	91 1d       	adc	r25, r1
    1a62:	6e a3       	std	Y+38, r22	; 0x26
    1a64:	7f a3       	std	Y+39, r23	; 0x27
    1a66:	88 a7       	std	Y+40, r24	; 0x28
    1a68:	99 a7       	std	Y+41, r25	; 0x29
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:901
		}
		rcnt = 512 - (UINT)fs->fptr % 512;			/* Get partial sector data from sector buffer */
    1a6a:	2e 89       	ldd	r18, Y+22	; 0x16
    1a6c:	3f 89       	ldd	r19, Y+23	; 0x17
    1a6e:	31 70       	andi	r19, 0x01	; 1
    1a70:	c3 01       	movw	r24, r6
    1a72:	82 1b       	sub	r24, r18
    1a74:	93 0b       	sbc	r25, r19
    1a76:	67 01       	movw	r12, r14
    1a78:	8e 15       	cp	r24, r14
    1a7a:	9f 05       	cpc	r25, r15
    1a7c:	08 f4       	brcc	.+2      	; 0x1a80 <pf_read.constprop.36+0x148>
    1a7e:	6c 01       	movw	r12, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:903
		if (rcnt > btr) rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    1a80:	4e a1       	ldd	r20, Y+38	; 0x26
    1a82:	5f a1       	ldd	r21, Y+39	; 0x27
    1a84:	68 a5       	ldd	r22, Y+40	; 0x28
    1a86:	79 a5       	ldd	r23, Y+41	; 0x29
    1a88:	86 01       	movw	r16, r12
    1a8a:	c4 01       	movw	r24, r8
    1a8c:	0e 94 aa 09 	call	0x1354	; 0x1354 <disk_readp>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:904
		if (dr) ABORT(FR_DISK_ERR);
    1a90:	89 2b       	or	r24, r25
    1a92:	09 f0       	breq	.+2      	; 0x1a96 <pf_read.constprop.36+0x15e>
    1a94:	ba cf       	rjmp	.-140    	; 0x1a0a <pf_read.constprop.36+0xd2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:905
		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
    1a96:	8e 89       	ldd	r24, Y+22	; 0x16
    1a98:	9f 89       	ldd	r25, Y+23	; 0x17
    1a9a:	a8 8d       	ldd	r26, Y+24	; 0x18
    1a9c:	b9 8d       	ldd	r27, Y+25	; 0x19
    1a9e:	8c 0d       	add	r24, r12
    1aa0:	9d 1d       	adc	r25, r13
    1aa2:	a1 1d       	adc	r26, r1
    1aa4:	b1 1d       	adc	r27, r1
    1aa6:	8e 8b       	std	Y+22, r24	; 0x16
    1aa8:	9f 8b       	std	Y+23, r25	; 0x17
    1aaa:	a8 8f       	std	Y+24, r26	; 0x18
    1aac:	b9 8f       	std	Y+25, r27	; 0x19
    1aae:	8c 0c       	add	r8, r12
    1ab0:	9d 1c       	adc	r9, r13
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:906
		btr -= rcnt; *br += rcnt;
    1ab2:	ec 18       	sub	r14, r12
    1ab4:	fd 08       	sbc	r15, r13
    1ab6:	f5 01       	movw	r30, r10
    1ab8:	80 81       	ld	r24, Z
    1aba:	91 81       	ldd	r25, Z+1	; 0x01
    1abc:	c8 0e       	add	r12, r24
    1abe:	d9 1e       	adc	r13, r25
    1ac0:	d1 82       	std	Z+1, r13	; 0x01
    1ac2:	c0 82       	st	Z, r12
    1ac4:	76 cf       	rjmp	.-276    	; 0x19b2 <pf_read.constprop.36+0x7a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:879
	BYTE cs, *rbuff = (BYTE*)buff;  // whg
	FATFS *fs = FatFs;


	*br = 0;
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    1ac6:	85 e0       	ldi	r24, 0x05	; 5
    1ac8:	90 e0       	ldi	r25, 0x00	; 0
    1aca:	a2 cf       	rjmp	.-188    	; 0x1a10 <pf_read.constprop.36+0xd8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:881
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
		return FR_NOT_OPENED;
    1acc:	84 e0       	ldi	r24, 0x04	; 4
    1ace:	90 e0       	ldi	r25, 0x00	; 0
    1ad0:	9f cf       	rjmp	.-194    	; 0x1a10 <pf_read.constprop.36+0xd8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:909
		if (dr) ABORT(FR_DISK_ERR);
		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
		btr -= rcnt; *br += rcnt;
	}

	return FR_OK;
    1ad2:	90 e0       	ldi	r25, 0x00	; 0
    1ad4:	80 e0       	ldi	r24, 0x00	; 0
    1ad6:	9c cf       	rjmp	.-200    	; 0x1a10 <pf_read.constprop.36+0xd8>

00001ad8 <pf_lseek>:
pf_lseek():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:992
#if _USE_LSEEK

FRESULT pf_lseek (
	DWORD ofs		/* File pointer from top of file */
)
{
    1ad8:	4f 92       	push	r4
    1ada:	5f 92       	push	r5
    1adc:	6f 92       	push	r6
    1ade:	7f 92       	push	r7
    1ae0:	8f 92       	push	r8
    1ae2:	9f 92       	push	r9
    1ae4:	af 92       	push	r10
    1ae6:	bf 92       	push	r11
    1ae8:	cf 92       	push	r12
    1aea:	df 92       	push	r13
    1aec:	ef 92       	push	r14
    1aee:	ff 92       	push	r15
    1af0:	cf 93       	push	r28
    1af2:	df 93       	push	r29
    1af4:	00 d0       	rcall	.+0      	; 0x1af6 <pf_lseek+0x1e>
    1af6:	00 d0       	rcall	.+0      	; 0x1af8 <pf_lseek+0x20>
    1af8:	00 d0       	rcall	.+0      	; 0x1afa <pf_lseek+0x22>
    1afa:	cd b7       	in	r28, 0x3d	; 61
    1afc:	de b7       	in	r29, 0x3e	; 62
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:995
	CLUST clst;
	DWORD bcs, sect, ifptr;
	FATFS *fs = FatFs;
    1afe:	20 91 a4 02 	lds	r18, 0x02A4	; 0x8002a4 <FatFs>
    1b02:	30 91 a5 02 	lds	r19, 0x02A5	; 0x8002a5 <FatFs+0x1>
    1b06:	3e 83       	std	Y+6, r19	; 0x06
    1b08:	2d 83       	std	Y+5, r18	; 0x05
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:998


	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    1b0a:	21 15       	cp	r18, r1
    1b0c:	31 05       	cpc	r19, r1
    1b0e:	09 f4       	brne	.+2      	; 0x1b12 <pf_lseek+0x3a>
    1b10:	0c c1       	rjmp	.+536    	; 0x1d2a <pf_lseek+0x252>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:999
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
    1b12:	d9 01       	movw	r26, r18
    1b14:	11 96       	adiw	r26, 0x01	; 1
    1b16:	2c 91       	ld	r18, X
    1b18:	11 97       	sbiw	r26, 0x01	; 1
    1b1a:	20 ff       	sbrs	r18, 0
    1b1c:	09 c1       	rjmp	.+530    	; 0x1d30 <pf_lseek+0x258>
    1b1e:	5a 96       	adiw	r26, 0x1a	; 26
    1b20:	cd 90       	ld	r12, X+
    1b22:	dd 90       	ld	r13, X+
    1b24:	ed 90       	ld	r14, X+
    1b26:	fc 90       	ld	r15, X
    1b28:	5d 97       	sbiw	r26, 0x1d	; 29
    1b2a:	6c 15       	cp	r22, r12
    1b2c:	7d 05       	cpc	r23, r13
    1b2e:	8e 05       	cpc	r24, r14
    1b30:	9f 05       	cpc	r25, r15
    1b32:	10 f4       	brcc	.+4      	; 0x1b38 <pf_lseek+0x60>
    1b34:	6b 01       	movw	r12, r22
    1b36:	7c 01       	movw	r14, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1003
			return FR_NOT_OPENED;

	if (ofs > fs->fsize) ofs = fs->fsize;	/* Clip offset with the file size */
	ifptr = fs->fptr;
    1b38:	ed 81       	ldd	r30, Y+5	; 0x05
    1b3a:	fe 81       	ldd	r31, Y+6	; 0x06
    1b3c:	46 88       	ldd	r4, Z+22	; 0x16
    1b3e:	57 88       	ldd	r5, Z+23	; 0x17
    1b40:	60 8c       	ldd	r6, Z+24	; 0x18
    1b42:	71 8c       	ldd	r7, Z+25	; 0x19
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1004
	fs->fptr = 0;
    1b44:	16 8a       	std	Z+22, r1	; 0x16
    1b46:	17 8a       	std	Z+23, r1	; 0x17
    1b48:	10 8e       	std	Z+24, r1	; 0x18
    1b4a:	11 8e       	std	Z+25, r1	; 0x19
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1005
	if (ofs > 0) {
    1b4c:	c1 14       	cp	r12, r1
    1b4e:	d1 04       	cpc	r13, r1
    1b50:	e1 04       	cpc	r14, r1
    1b52:	f1 04       	cpc	r15, r1
    1b54:	09 f4       	brne	.+2      	; 0x1b58 <pf_lseek+0x80>
    1b56:	e6 c0       	rjmp	.+460    	; 0x1d24 <pf_lseek+0x24c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1006
		bcs = (DWORD)fs->csize * 512;	/* Cluster size (byte) */
    1b58:	82 80       	ldd	r8, Z+2	; 0x02
    1b5a:	91 2c       	mov	r9, r1
    1b5c:	b1 2c       	mov	r11, r1
    1b5e:	a1 2c       	mov	r10, r1
    1b60:	39 e0       	ldi	r19, 0x09	; 9
    1b62:	88 0c       	add	r8, r8
    1b64:	99 1c       	adc	r9, r9
    1b66:	aa 1c       	adc	r10, r10
    1b68:	bb 1c       	adc	r11, r11
    1b6a:	3a 95       	dec	r19
    1b6c:	d1 f7       	brne	.-12     	; 0x1b62 <pf_lseek+0x8a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1007
		if (ifptr > 0 &&
    1b6e:	41 14       	cp	r4, r1
    1b70:	51 04       	cpc	r5, r1
    1b72:	61 04       	cpc	r6, r1
    1b74:	71 04       	cpc	r7, r1
    1b76:	09 f4       	brne	.+2      	; 0x1b7a <pf_lseek+0xa2>
    1b78:	70 c0       	rjmp	.+224    	; 0x1c5a <pf_lseek+0x182>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1008
			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    1b7a:	b1 e0       	ldi	r27, 0x01	; 1
    1b7c:	4b 1a       	sub	r4, r27
    1b7e:	51 08       	sbc	r5, r1
    1b80:	61 08       	sbc	r6, r1
    1b82:	71 08       	sbc	r7, r1
    1b84:	c7 01       	movw	r24, r14
    1b86:	b6 01       	movw	r22, r12
    1b88:	61 50       	subi	r22, 0x01	; 1
    1b8a:	71 09       	sbc	r23, r1
    1b8c:	81 09       	sbc	r24, r1
    1b8e:	91 09       	sbc	r25, r1
    1b90:	a5 01       	movw	r20, r10
    1b92:	94 01       	movw	r18, r8
    1b94:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <__udivmodsi4>
    1b98:	29 83       	std	Y+1, r18	; 0x01
    1b9a:	3a 83       	std	Y+2, r19	; 0x02
    1b9c:	4b 83       	std	Y+3, r20	; 0x03
    1b9e:	5c 83       	std	Y+4, r21	; 0x04
    1ba0:	c3 01       	movw	r24, r6
    1ba2:	b2 01       	movw	r22, r4
    1ba4:	a5 01       	movw	r20, r10
    1ba6:	94 01       	movw	r18, r8
    1ba8:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <__udivmodsi4>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1007
	if (ofs > fs->fsize) ofs = fs->fsize;	/* Clip offset with the file size */
	ifptr = fs->fptr;
	fs->fptr = 0;
	if (ofs > 0) {
		bcs = (DWORD)fs->csize * 512;	/* Cluster size (byte) */
		if (ifptr > 0 &&
    1bac:	89 81       	ldd	r24, Y+1	; 0x01
    1bae:	9a 81       	ldd	r25, Y+2	; 0x02
    1bb0:	ab 81       	ldd	r26, Y+3	; 0x03
    1bb2:	bc 81       	ldd	r27, Y+4	; 0x04
    1bb4:	82 17       	cp	r24, r18
    1bb6:	93 07       	cpc	r25, r19
    1bb8:	a4 07       	cpc	r26, r20
    1bba:	b5 07       	cpc	r27, r21
    1bbc:	08 f4       	brcc	.+2      	; 0x1bc0 <pf_lseek+0xe8>
    1bbe:	4d c0       	rjmp	.+154    	; 0x1c5a <pf_lseek+0x182>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1009
			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
			fs->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    1bc0:	88 27       	eor	r24, r24
    1bc2:	99 27       	eor	r25, r25
    1bc4:	dc 01       	movw	r26, r24
    1bc6:	88 19       	sub	r24, r8
    1bc8:	99 09       	sbc	r25, r9
    1bca:	aa 09       	sbc	r26, r10
    1bcc:	bb 09       	sbc	r27, r11
    1bce:	84 21       	and	r24, r4
    1bd0:	95 21       	and	r25, r5
    1bd2:	a6 21       	and	r26, r6
    1bd4:	b7 21       	and	r27, r7
    1bd6:	ed 81       	ldd	r30, Y+5	; 0x05
    1bd8:	fe 81       	ldd	r31, Y+6	; 0x06
    1bda:	86 8b       	std	Z+22, r24	; 0x16
    1bdc:	97 8b       	std	Z+23, r25	; 0x17
    1bde:	a0 8f       	std	Z+24, r26	; 0x18
    1be0:	b1 8f       	std	Z+25, r27	; 0x19
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1010
			ofs -= fs->fptr;
    1be2:	c8 1a       	sub	r12, r24
    1be4:	d9 0a       	sbc	r13, r25
    1be6:	ea 0a       	sbc	r14, r26
    1be8:	fb 0a       	sbc	r15, r27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1011
			clst = fs->curr_clust;
    1bea:	62 a1       	ldd	r22, Z+34	; 0x22
    1bec:	73 a1       	ldd	r23, Z+35	; 0x23
    1bee:	84 a1       	ldd	r24, Z+36	; 0x24
    1bf0:	95 a1       	ldd	r25, Z+37	; 0x25
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1016
		} else {							/* When seek to back cluster, */
			clst = fs->org_clust;			/* start from the first cluster */
			fs->curr_clust = clst;
		}
		while (ofs > bcs) {				/* Cluster following loop */
    1bf2:	8c 14       	cp	r8, r12
    1bf4:	9d 04       	cpc	r9, r13
    1bf6:	ae 04       	cpc	r10, r14
    1bf8:	bf 04       	cpc	r11, r15
    1bfa:	08 f0       	brcs	.+2      	; 0x1bfe <pf_lseek+0x126>
    1bfc:	58 c0       	rjmp	.+176    	; 0x1cae <pf_lseek+0x1d6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1017
			clst = get_fat(clst);		/* Follow cluster chain */
    1bfe:	0e 94 2c 0c 	call	0x1858	; 0x1858 <get_fat(unsigned long)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1018
			if (clst <= 1 || clst >= fs->n_fatent) ABORT(FR_DISK_ERR);
    1c02:	62 30       	cpi	r22, 0x02	; 2
    1c04:	71 05       	cpc	r23, r1
    1c06:	81 05       	cpc	r24, r1
    1c08:	91 05       	cpc	r25, r1
    1c0a:	68 f0       	brcs	.+26     	; 0x1c26 <pf_lseek+0x14e>
    1c0c:	ad 81       	ldd	r26, Y+5	; 0x05
    1c0e:	be 81       	ldd	r27, Y+6	; 0x06
    1c10:	16 96       	adiw	r26, 0x06	; 6
    1c12:	4d 90       	ld	r4, X+
    1c14:	5d 90       	ld	r5, X+
    1c16:	6d 90       	ld	r6, X+
    1c18:	7c 90       	ld	r7, X
    1c1a:	19 97       	sbiw	r26, 0x09	; 9
    1c1c:	64 15       	cp	r22, r4
    1c1e:	75 05       	cpc	r23, r5
    1c20:	86 05       	cpc	r24, r6
    1c22:	97 05       	cpc	r25, r7
    1c24:	40 f1       	brcs	.+80     	; 0x1c76 <pf_lseek+0x19e>
    1c26:	ed 81       	ldd	r30, Y+5	; 0x05
    1c28:	fe 81       	ldd	r31, Y+6	; 0x06
    1c2a:	11 82       	std	Z+1, r1	; 0x01
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1025
			fs->fptr += bcs;
			ofs -= bcs;
		}
		fs->fptr += ofs;
		sect = clust2sect(clst);		/* Current sector */
		if (!sect) ABORT(FR_DISK_ERR);
    1c2c:	81 e0       	ldi	r24, 0x01	; 1
    1c2e:	90 e0       	ldi	r25, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1030
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
	}

	return FR_OK;
}
    1c30:	26 96       	adiw	r28, 0x06	; 6
    1c32:	0f b6       	in	r0, 0x3f	; 63
    1c34:	f8 94       	cli
    1c36:	de bf       	out	0x3e, r29	; 62
    1c38:	0f be       	out	0x3f, r0	; 63
    1c3a:	cd bf       	out	0x3d, r28	; 61
    1c3c:	df 91       	pop	r29
    1c3e:	cf 91       	pop	r28
    1c40:	ff 90       	pop	r15
    1c42:	ef 90       	pop	r14
    1c44:	df 90       	pop	r13
    1c46:	cf 90       	pop	r12
    1c48:	bf 90       	pop	r11
    1c4a:	af 90       	pop	r10
    1c4c:	9f 90       	pop	r9
    1c4e:	8f 90       	pop	r8
    1c50:	7f 90       	pop	r7
    1c52:	6f 90       	pop	r6
    1c54:	5f 90       	pop	r5
    1c56:	4f 90       	pop	r4
    1c58:	08 95       	ret
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1013
			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
			fs->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
			ofs -= fs->fptr;
			clst = fs->curr_clust;
		} else {							/* When seek to back cluster, */
			clst = fs->org_clust;			/* start from the first cluster */
    1c5a:	ad 81       	ldd	r26, Y+5	; 0x05
    1c5c:	be 81       	ldd	r27, Y+6	; 0x06
    1c5e:	5e 96       	adiw	r26, 0x1e	; 30
    1c60:	6d 91       	ld	r22, X+
    1c62:	7d 91       	ld	r23, X+
    1c64:	8d 91       	ld	r24, X+
    1c66:	9c 91       	ld	r25, X
    1c68:	91 97       	sbiw	r26, 0x21	; 33
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1014
			fs->curr_clust = clst;
    1c6a:	fd 01       	movw	r30, r26
    1c6c:	62 a3       	std	Z+34, r22	; 0x22
    1c6e:	73 a3       	std	Z+35, r23	; 0x23
    1c70:	84 a3       	std	Z+36, r24	; 0x24
    1c72:	95 a3       	std	Z+37, r25	; 0x25
    1c74:	be cf       	rjmp	.-132    	; 0x1bf2 <pf_lseek+0x11a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1019
		}
		while (ofs > bcs) {				/* Cluster following loop */
			clst = get_fat(clst);		/* Follow cluster chain */
			if (clst <= 1 || clst >= fs->n_fatent) ABORT(FR_DISK_ERR);
			fs->curr_clust = clst;
    1c76:	ad 81       	ldd	r26, Y+5	; 0x05
    1c78:	be 81       	ldd	r27, Y+6	; 0x06
    1c7a:	92 96       	adiw	r26, 0x22	; 34
    1c7c:	6d 93       	st	X+, r22
    1c7e:	7d 93       	st	X+, r23
    1c80:	8d 93       	st	X+, r24
    1c82:	9c 93       	st	X, r25
    1c84:	95 97       	sbiw	r26, 0x25	; 37
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1020
			fs->fptr += bcs;
    1c86:	56 96       	adiw	r26, 0x16	; 22
    1c88:	4d 90       	ld	r4, X+
    1c8a:	5d 90       	ld	r5, X+
    1c8c:	6d 90       	ld	r6, X+
    1c8e:	7c 90       	ld	r7, X
    1c90:	59 97       	sbiw	r26, 0x19	; 25
    1c92:	48 0c       	add	r4, r8
    1c94:	59 1c       	adc	r5, r9
    1c96:	6a 1c       	adc	r6, r10
    1c98:	7b 1c       	adc	r7, r11
    1c9a:	fd 01       	movw	r30, r26
    1c9c:	46 8a       	std	Z+22, r4	; 0x16
    1c9e:	57 8a       	std	Z+23, r5	; 0x17
    1ca0:	60 8e       	std	Z+24, r6	; 0x18
    1ca2:	71 8e       	std	Z+25, r7	; 0x19
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1021
			ofs -= bcs;
    1ca4:	c8 18       	sub	r12, r8
    1ca6:	d9 08       	sbc	r13, r9
    1ca8:	ea 08       	sbc	r14, r10
    1caa:	fb 08       	sbc	r15, r11
    1cac:	a2 cf       	rjmp	.-188    	; 0x1bf2 <pf_lseek+0x11a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1023
		}
		fs->fptr += ofs;
    1cae:	ad 81       	ldd	r26, Y+5	; 0x05
    1cb0:	be 81       	ldd	r27, Y+6	; 0x06
    1cb2:	56 96       	adiw	r26, 0x16	; 22
    1cb4:	8d 90       	ld	r8, X+
    1cb6:	9d 90       	ld	r9, X+
    1cb8:	ad 90       	ld	r10, X+
    1cba:	bc 90       	ld	r11, X
    1cbc:	59 97       	sbiw	r26, 0x19	; 25
    1cbe:	c8 0c       	add	r12, r8
    1cc0:	d9 1c       	adc	r13, r9
    1cc2:	ea 1c       	adc	r14, r10
    1cc4:	fb 1c       	adc	r15, r11
    1cc6:	fd 01       	movw	r30, r26
    1cc8:	c6 8a       	std	Z+22, r12	; 0x16
    1cca:	d7 8a       	std	Z+23, r13	; 0x17
    1ccc:	e0 8e       	std	Z+24, r14	; 0x18
    1cce:	f1 8e       	std	Z+25, r15	; 0x19
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1024
		sect = clust2sect(clst);		/* Current sector */
    1cd0:	0e 94 a1 08 	call	0x1142	; 0x1142 <clust2sect(unsigned long)>
    1cd4:	ab 01       	movw	r20, r22
    1cd6:	bc 01       	movw	r22, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1025
		if (!sect) ABORT(FR_DISK_ERR);
    1cd8:	41 15       	cp	r20, r1
    1cda:	51 05       	cpc	r21, r1
    1cdc:	61 05       	cpc	r22, r1
    1cde:	71 05       	cpc	r23, r1
    1ce0:	29 f4       	brne	.+10     	; 0x1cec <pf_lseek+0x214>
    1ce2:	ad 81       	ldd	r26, Y+5	; 0x05
    1ce4:	be 81       	ldd	r27, Y+6	; 0x06
    1ce6:	11 96       	adiw	r26, 0x01	; 1
    1ce8:	1c 92       	st	X, r1
    1cea:	a0 cf       	rjmp	.-192    	; 0x1c2c <pf_lseek+0x154>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1026
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
    1cec:	ed 81       	ldd	r30, Y+5	; 0x05
    1cee:	fe 81       	ldd	r31, Y+6	; 0x06
    1cf0:	82 81       	ldd	r24, Z+2	; 0x02
    1cf2:	81 50       	subi	r24, 0x01	; 1
    1cf4:	99 0b       	sbc	r25, r25
    1cf6:	09 2e       	mov	r0, r25
    1cf8:	00 0c       	add	r0, r0
    1cfa:	aa 0b       	sbc	r26, r26
    1cfc:	bb 0b       	sbc	r27, r27
    1cfe:	29 e0       	ldi	r18, 0x09	; 9
    1d00:	f6 94       	lsr	r15
    1d02:	e7 94       	ror	r14
    1d04:	d7 94       	ror	r13
    1d06:	c7 94       	ror	r12
    1d08:	2a 95       	dec	r18
    1d0a:	d1 f7       	brne	.-12     	; 0x1d00 <pf_lseek+0x228>
    1d0c:	8c 21       	and	r24, r12
    1d0e:	9d 21       	and	r25, r13
    1d10:	ae 21       	and	r26, r14
    1d12:	bf 21       	and	r27, r15
    1d14:	48 0f       	add	r20, r24
    1d16:	59 1f       	adc	r21, r25
    1d18:	6a 1f       	adc	r22, r26
    1d1a:	7b 1f       	adc	r23, r27
    1d1c:	46 a3       	std	Z+38, r20	; 0x26
    1d1e:	57 a3       	std	Z+39, r21	; 0x27
    1d20:	60 a7       	std	Z+40, r22	; 0x28
    1d22:	71 a7       	std	Z+41, r23	; 0x29
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1029
	}

	return FR_OK;
    1d24:	90 e0       	ldi	r25, 0x00	; 0
    1d26:	80 e0       	ldi	r24, 0x00	; 0
    1d28:	83 cf       	rjmp	.-250    	; 0x1c30 <pf_lseek+0x158>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:998
	CLUST clst;
	DWORD bcs, sect, ifptr;
	FATFS *fs = FatFs;


	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    1d2a:	85 e0       	ldi	r24, 0x05	; 5
    1d2c:	90 e0       	ldi	r25, 0x00	; 0
    1d2e:	80 cf       	rjmp	.-256    	; 0x1c30 <pf_lseek+0x158>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:1000
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
			return FR_NOT_OPENED;
    1d30:	84 e0       	ldi	r24, 0x04	; 4
    1d32:	90 e0       	ldi	r25, 0x00	; 0
    1d34:	7d cf       	rjmp	.-262    	; 0x1c30 <pf_lseek+0x158>

00001d36 <pf_open>:
pf_open():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:832
/*-----------------------------------------------------------------------*/

FRESULT pf_open (
	const char *path	/* Pointer to the file name */
)
{
    1d36:	4f 92       	push	r4
    1d38:	5f 92       	push	r5
    1d3a:	6f 92       	push	r6
    1d3c:	7f 92       	push	r7
    1d3e:	bf 92       	push	r11
    1d40:	cf 92       	push	r12
    1d42:	df 92       	push	r13
    1d44:	ef 92       	push	r14
    1d46:	ff 92       	push	r15
    1d48:	0f 93       	push	r16
    1d4a:	1f 93       	push	r17
    1d4c:	cf 93       	push	r28
    1d4e:	df 93       	push	r29
    1d50:	cd b7       	in	r28, 0x3d	; 61
    1d52:	de b7       	in	r29, 0x3e	; 62
    1d54:	ec 97       	sbiw	r28, 0x3c	; 60
    1d56:	0f b6       	in	r0, 0x3f	; 63
    1d58:	f8 94       	cli
    1d5a:	de bf       	out	0x3e, r29	; 62
    1d5c:	0f be       	out	0x3f, r0	; 63
    1d5e:	cd bf       	out	0x3d, r28	; 61
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:836
	FRESULT res;
	DIR dj;
	BYTE sp[12], dir[32];
	FATFS *fs = FatFs;
    1d60:	e0 90 a4 02 	lds	r14, 0x02A4	; 0x8002a4 <FatFs>
    1d64:	f0 90 a5 02 	lds	r15, 0x02A5	; 0x8002a5 <FatFs+0x1>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:839


	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    1d68:	e1 14       	cp	r14, r1
    1d6a:	f1 04       	cpc	r15, r1
    1d6c:	09 f4       	brne	.+2      	; 0x1d70 <pf_open+0x3a>
    1d6e:	04 c1       	rjmp	.+520    	; 0x1f78 <pf_open+0x242>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:841

	fs->flag = 0;
    1d70:	f7 01       	movw	r30, r14
    1d72:	11 82       	std	Z+1, r1	; 0x01
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:842
	dj.fn = sp;
    1d74:	9e 01       	movw	r18, r28
    1d76:	2f 5c       	subi	r18, 0xCF	; 207
    1d78:	3f 4f       	sbci	r19, 0xFF	; 255
    1d7a:	3c a3       	std	Y+36, r19	; 0x24
    1d7c:	2b a3       	std	Y+35, r18	; 0x23
    1d7e:	9c 01       	movw	r18, r24
    1d80:	69 01       	movw	r12, r18
follow_path():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:688
)
{
	FRESULT res;


	while (*path == ' ') path++;		/* Strip leading spaces */
    1d82:	f9 01       	movw	r30, r18
    1d84:	80 81       	ld	r24, Z
    1d86:	2f 5f       	subi	r18, 0xFF	; 255
    1d88:	3f 4f       	sbci	r19, 0xFF	; 255
    1d8a:	80 32       	cpi	r24, 0x20	; 32
    1d8c:	c9 f3       	breq	.-14     	; 0x1d80 <pf_open+0x4a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:689
	if (*path == '/') path++;			/* Strip heading separator if exist */
    1d8e:	8f 32       	cpi	r24, 0x2F	; 47
    1d90:	09 f4       	brne	.+2      	; 0x1d94 <pf_open+0x5e>
    1d92:	69 01       	movw	r12, r18
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:690
	dj->sclust = 0;						/* Set start directory (always root dir) */
    1d94:	1d a2       	std	Y+37, r1	; 0x25
    1d96:	1e a2       	std	Y+38, r1	; 0x26
    1d98:	1f a2       	std	Y+39, r1	; 0x27
    1d9a:	18 a6       	std	Y+40, r1	; 0x28
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:692

	if ((BYTE)*path < ' ') {			/* Null path means the root directory */
    1d9c:	f6 01       	movw	r30, r12
    1d9e:	80 81       	ld	r24, Z
mem_set():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:330

/* Fill memory */
static
void mem_set (void* dst, int val, int cnt) {
	char *d = (char*)dst;
	while (cnt--) *d++ = (char)val;
    1da0:	a0 e2       	ldi	r26, 0x20	; 32
    1da2:	ba 2e       	mov	r11, r26
follow_path():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:692

	while (*path == ' ') path++;		/* Strip leading spaces */
	if (*path == '/') path++;			/* Strip heading separator if exist */
	dj->sclust = 0;						/* Set start directory (always root dir) */

	if ((BYTE)*path < ' ') {			/* Null path means the root directory */
    1da4:	80 32       	cpi	r24, 0x20	; 32
    1da6:	08 f0       	brcs	.+2      	; 0x1daa <pf_open+0x74>
    1da8:	d4 c0       	rjmp	.+424    	; 0x1f52 <pf_open+0x21c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:693
		res = dir_rewind(dj);
    1daa:	ce 01       	movw	r24, r28
    1dac:	81 96       	adiw	r24, 0x21	; 33
    1dae:	0e 94 cc 08 	call	0x1198	; 0x1198 <dir_rewind(DIR*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:694
		dir[0] = 0;
    1db2:	19 82       	std	Y+1, r1	; 0x01
pf_open():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:844
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */

	fs->flag = 0;
	dj.fn = sp;
	res = follow_path(&dj, dir, path);	/* Follow the file path */
	if (res != FR_OK) return res;		/* Follow failed */
    1db4:	00 97       	sbiw	r24, 0x00	; 0
    1db6:	09 f4       	brne	.+2      	; 0x1dba <pf_open+0x84>
    1db8:	07 c1       	rjmp	.+526    	; 0x1fc8 <pf_open+0x292>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:854
	fs->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
	fs->fptr = 0;						/* File pointer */
	fs->flag = FA_OPENED;

	return FR_OK;
}
    1dba:	ec 96       	adiw	r28, 0x3c	; 60
    1dbc:	0f b6       	in	r0, 0x3f	; 63
    1dbe:	f8 94       	cli
    1dc0:	de bf       	out	0x3e, r29	; 62
    1dc2:	0f be       	out	0x3f, r0	; 63
    1dc4:	cd bf       	out	0x3d, r28	; 61
    1dc6:	df 91       	pop	r29
    1dc8:	cf 91       	pop	r28
    1dca:	1f 91       	pop	r17
    1dcc:	0f 91       	pop	r16
    1dce:	ff 90       	pop	r15
    1dd0:	ef 90       	pop	r14
    1dd2:	df 90       	pop	r13
    1dd4:	cf 90       	pop	r12
    1dd6:	bf 90       	pop	r11
    1dd8:	7f 90       	pop	r7
    1dda:	6f 90       	pop	r6
    1ddc:	5f 90       	pop	r5
    1dde:	4f 90       	pop	r4
    1de0:	08 95       	ret
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:596
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0; ni = 8;
    1de2:	20 e0       	ldi	r18, 0x00	; 0
    1de4:	e0 e0       	ldi	r30, 0x00	; 0
    1de6:	88 e0       	ldi	r24, 0x08	; 8
    1de8:	d1 c0       	rjmp	.+418    	; 0x1f8c <pf_open+0x256>
_ZL11create_nameP3DIRPPKc.isra.0():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:622
		{						/* Single byte code */
			if (_USE_LCC && IsLower(c)) c -= 0x20;	/* toupper */
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Rerurn pointer to the next segment */
    1dea:	c3 0e       	add	r12, r19
    1dec:	d1 1c       	adc	r13, r1
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:624

	sfn[11] = (c <= ' ') ? 1 : 0;		/* Set last segment flag if end of path */
    1dee:	81 e0       	ldi	r24, 0x01	; 1
    1df0:	91 32       	cpi	r25, 0x21	; 33
    1df2:	08 f0       	brcs	.+2      	; 0x1df6 <pf_open+0xc0>
    1df4:	80 e0       	ldi	r24, 0x00	; 0
    1df6:	1b 96       	adiw	r26, 0x0b	; 11
    1df8:	8c 93       	st	X, r24
dir_find():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:518
{
	FRESULT res;
	BYTE c;


	res = dir_rewind(dj);			/* Rewind directory object */
    1dfa:	ce 01       	movw	r24, r28
    1dfc:	81 96       	adiw	r24, 0x21	; 33
    1dfe:	0e 94 cc 08 	call	0x1198	; 0x1198 <dir_rewind(DIR*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:519
	if (res != FR_OK) return res;
    1e02:	00 97       	sbiw	r24, 0x00	; 0
    1e04:	d1 f6       	brne	.-76     	; 0x1dba <pf_open+0x84>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:522

	do {
		res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32)	/* Read an entry */
    1e06:	29 a1       	ldd	r18, Y+33	; 0x21
    1e08:	3a a1       	ldd	r19, Y+34	; 0x22
    1e0a:	2f 70       	andi	r18, 0x0F	; 15
    1e0c:	33 27       	eor	r19, r19
    1e0e:	f5 e0       	ldi	r31, 0x05	; 5
    1e10:	22 0f       	add	r18, r18
    1e12:	33 1f       	adc	r19, r19
    1e14:	fa 95       	dec	r31
    1e16:	e1 f7       	brne	.-8      	; 0x1e10 <pf_open+0xda>
    1e18:	4d a5       	ldd	r20, Y+45	; 0x2d
    1e1a:	5e a5       	ldd	r21, Y+46	; 0x2e
    1e1c:	6f a5       	ldd	r22, Y+47	; 0x2f
    1e1e:	78 a9       	ldd	r23, Y+48	; 0x30
    1e20:	00 e2       	ldi	r16, 0x20	; 32
    1e22:	10 e0       	ldi	r17, 0x00	; 0
    1e24:	ce 01       	movw	r24, r28
    1e26:	01 96       	adiw	r24, 0x01	; 1
    1e28:	0e 94 aa 09 	call	0x1354	; 0x1354 <disk_readp>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:523
			? FR_DISK_ERR : FR_OK;
    1e2c:	89 2b       	or	r24, r25
    1e2e:	19 f0       	breq	.+6      	; 0x1e36 <pf_open+0x100>
pf_open():
    1e30:	81 e0       	ldi	r24, 0x01	; 1
    1e32:	90 e0       	ldi	r25, 0x00	; 0
    1e34:	c2 cf       	rjmp	.-124    	; 0x1dba <pf_open+0x84>
dir_find():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:526
		if (res != FR_OK) break;
		c = dir[DIR_Name];	/* First character */
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    1e36:	89 81       	ldd	r24, Y+1	; 0x01
    1e38:	81 11       	cpse	r24, r1
    1e3a:	03 c0       	rjmp	.+6      	; 0x1e42 <pf_open+0x10c>
pf_open():
    1e3c:	83 e0       	ldi	r24, 0x03	; 3
    1e3e:	90 e0       	ldi	r25, 0x00	; 0
    1e40:	bc cf       	rjmp	.-136    	; 0x1dba <pf_open+0x84>
dir_find():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:527
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    1e42:	8c 85       	ldd	r24, Y+12	; 0x0c
    1e44:	83 fd       	sbrc	r24, 3
    1e46:	13 c0       	rjmp	.+38     	; 0x1e6e <pf_open+0x138>
    1e48:	0b a1       	ldd	r16, Y+35	; 0x23
    1e4a:	1c a1       	ldd	r17, Y+36	; 0x24
    1e4c:	9e 01       	movw	r18, r28
    1e4e:	2f 5f       	subi	r18, 0xFF	; 255
    1e50:	3f 4f       	sbci	r19, 0xFF	; 255
    1e52:	d8 01       	movw	r26, r16
    1e54:	b8 01       	movw	r22, r16
    1e56:	65 5f       	subi	r22, 0xF5	; 245
    1e58:	7f 4f       	sbci	r23, 0xFF	; 255
mem_cmp():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:338
/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, int cnt) {
	const char *d = (const char *)dst, *s = (const char *)src;
	int r = 0;
	while (cnt-- && (r = *d++ - *s++) == 0) ;
    1e5a:	6a 17       	cp	r22, r26
    1e5c:	7b 07       	cpc	r23, r27
    1e5e:	09 f4       	brne	.+2      	; 0x1e62 <pf_open+0x12c>
    1e60:	ae c0       	rjmp	.+348    	; 0x1fbe <pf_open+0x288>
    1e62:	f9 01       	movw	r30, r18
    1e64:	41 91       	ld	r20, Z+
    1e66:	9f 01       	movw	r18, r30
    1e68:	9d 91       	ld	r25, X+
    1e6a:	49 17       	cp	r20, r25
    1e6c:	b1 f3       	breq	.-20     	; 0x1e5a <pf_open+0x124>
dir_next():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:473
	CLUST clst;
	WORD i;
	FATFS *fs = FatFs;


	i = dj->index + 1;
    1e6e:	09 a1       	ldd	r16, Y+33	; 0x21
    1e70:	1a a1       	ldd	r17, Y+34	; 0x22
    1e72:	0f 5f       	subi	r16, 0xFF	; 255
    1e74:	1f 4f       	sbci	r17, 0xFF	; 255
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:474
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    1e76:	11 f3       	breq	.-60     	; 0x1e3c <pf_open+0x106>
    1e78:	8d a5       	ldd	r24, Y+45	; 0x2d
    1e7a:	9e a5       	ldd	r25, Y+46	; 0x2e
    1e7c:	af a5       	ldd	r26, Y+47	; 0x2f
    1e7e:	b8 a9       	ldd	r27, Y+48	; 0x30
    1e80:	00 97       	sbiw	r24, 0x00	; 0
    1e82:	a1 05       	cpc	r26, r1
    1e84:	b1 05       	cpc	r27, r1
    1e86:	d1 f2       	breq	.-76     	; 0x1e3c <pf_open+0x106>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:477
		return FR_NO_FILE;

	if (!(i % 16)) {		/* Sector changed? */
    1e88:	98 01       	movw	r18, r16
    1e8a:	2f 70       	andi	r18, 0x0F	; 15
    1e8c:	33 27       	eor	r19, r19
    1e8e:	23 2b       	or	r18, r19
    1e90:	b9 f4       	brne	.+46     	; 0x1ec0 <pf_open+0x18a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:478
		dj->sect++;			/* Next sector */
    1e92:	01 96       	adiw	r24, 0x01	; 1
    1e94:	a1 1d       	adc	r26, r1
    1e96:	b1 1d       	adc	r27, r1
    1e98:	8d a7       	std	Y+45, r24	; 0x2d
    1e9a:	9e a7       	std	Y+46, r25	; 0x2e
    1e9c:	af a7       	std	Y+47, r26	; 0x2f
    1e9e:	b8 ab       	std	Y+48, r27	; 0x30
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:480

		if (dj->clust == 0) {	/* Static table */
    1ea0:	69 a5       	ldd	r22, Y+41	; 0x29
    1ea2:	7a a5       	ldd	r23, Y+42	; 0x2a
    1ea4:	8b a5       	ldd	r24, Y+43	; 0x2b
    1ea6:	9c a5       	ldd	r25, Y+44	; 0x2c
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:481
			if (i >= fs->n_rootdir)	/* Report EOT when end of table */
    1ea8:	f7 01       	movw	r30, r14
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:480
		return FR_NO_FILE;

	if (!(i % 16)) {		/* Sector changed? */
		dj->sect++;			/* Next sector */

		if (dj->clust == 0) {	/* Static table */
    1eaa:	61 15       	cp	r22, r1
    1eac:	71 05       	cpc	r23, r1
    1eae:	81 05       	cpc	r24, r1
    1eb0:	91 05       	cpc	r25, r1
    1eb2:	49 f4       	brne	.+18     	; 0x1ec6 <pf_open+0x190>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:481
			if (i >= fs->n_rootdir)	/* Report EOT when end of table */
    1eb4:	84 81       	ldd	r24, Z+4	; 0x04
    1eb6:	95 81       	ldd	r25, Z+5	; 0x05
    1eb8:	08 17       	cp	r16, r24
    1eba:	19 07       	cpc	r17, r25
    1ebc:	08 f0       	brcs	.+2      	; 0x1ec0 <pf_open+0x18a>
    1ebe:	be cf       	rjmp	.-132    	; 0x1e3c <pf_open+0x106>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:496
				dj->sect = clust2sect(clst);
			}
		}
	}

	dj->index = i;
    1ec0:	1a a3       	std	Y+34, r17	; 0x22
    1ec2:	09 a3       	std	Y+33, r16	; 0x21
    1ec4:	a0 cf       	rjmp	.-192    	; 0x1e06 <pf_open+0xd0>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:485
		if (dj->clust == 0) {	/* Static table */
			if (i >= fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
    1ec6:	22 81       	ldd	r18, Z+2	; 0x02
    1ec8:	e2 2f       	mov	r30, r18
    1eca:	e1 50       	subi	r30, 0x01	; 1
    1ecc:	ff 0b       	sbc	r31, r31
    1ece:	af 01       	movw	r20, r30
    1ed0:	98 01       	movw	r18, r16
    1ed2:	e4 e0       	ldi	r30, 0x04	; 4
    1ed4:	36 95       	lsr	r19
    1ed6:	27 95       	ror	r18
    1ed8:	ea 95       	dec	r30
    1eda:	e1 f7       	brne	.-8      	; 0x1ed4 <pf_open+0x19e>
    1edc:	24 23       	and	r18, r20
    1ede:	35 23       	and	r19, r21
    1ee0:	23 2b       	or	r18, r19
    1ee2:	71 f7       	brne	.-36     	; 0x1ec0 <pf_open+0x18a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:486
				clst = get_fat(dj->clust);		/* Get next cluster */
    1ee4:	0e 94 2c 0c 	call	0x1858	; 0x1858 <get_fat(unsigned long)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:487
				if (clst <= 1) return FR_DISK_ERR;
    1ee8:	62 30       	cpi	r22, 0x02	; 2
    1eea:	71 05       	cpc	r23, r1
    1eec:	81 05       	cpc	r24, r1
    1eee:	91 05       	cpc	r25, r1
    1ef0:	08 f4       	brcc	.+2      	; 0x1ef4 <pf_open+0x1be>
    1ef2:	9e cf       	rjmp	.-196    	; 0x1e30 <pf_open+0xfa>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:488
				if (clst >= fs->n_fatent)		/* When it reached end of dynamic table */
    1ef4:	f7 01       	movw	r30, r14
    1ef6:	46 80       	ldd	r4, Z+6	; 0x06
    1ef8:	57 80       	ldd	r5, Z+7	; 0x07
    1efa:	60 84       	ldd	r6, Z+8	; 0x08
    1efc:	71 84       	ldd	r7, Z+9	; 0x09
    1efe:	64 15       	cp	r22, r4
    1f00:	75 05       	cpc	r23, r5
    1f02:	86 05       	cpc	r24, r6
    1f04:	97 05       	cpc	r25, r7
    1f06:	08 f0       	brcs	.+2      	; 0x1f0a <pf_open+0x1d4>
    1f08:	99 cf       	rjmp	.-206    	; 0x1e3c <pf_open+0x106>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:490
					return FR_NO_FILE;			/* Report EOT */
				dj->clust = clst;				/* Initialize data for new cluster */
    1f0a:	69 a7       	std	Y+41, r22	; 0x29
    1f0c:	7a a7       	std	Y+42, r23	; 0x2a
    1f0e:	8b a7       	std	Y+43, r24	; 0x2b
    1f10:	9c a7       	std	Y+44, r25	; 0x2c
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:491
				dj->sect = clust2sect(clst);
    1f12:	0e 94 a1 08 	call	0x1142	; 0x1142 <clust2sect(unsigned long)>
    1f16:	6d a7       	std	Y+45, r22	; 0x2d
    1f18:	7e a7       	std	Y+46, r23	; 0x2e
    1f1a:	8f a7       	std	Y+47, r24	; 0x2f
    1f1c:	98 ab       	std	Y+48, r25	; 0x30
    1f1e:	d0 cf       	rjmp	.-96     	; 0x1ec0 <pf_open+0x18a>
follow_path():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:703
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj, dir);		/* Find it */
			if (res != FR_OK) break;		/* Could not find the object */
			if (dj->fn[11]) break;			/* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
    1f20:	84 ff       	sbrs	r24, 4
    1f22:	8c cf       	rjmp	.-232    	; 0x1e3c <pf_open+0x106>
get_clust():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:421
{
	FATFS *fs = FatFs;
	CLUST clst = 0;


	if (_FS_32ONLY || (_FS_FAT32 && fs->fs_type == FS_FAT32)) {
    1f24:	f7 01       	movw	r30, r14
    1f26:	80 81       	ld	r24, Z
    1f28:	83 30       	cpi	r24, 0x03	; 3
    1f2a:	f1 f4       	brne	.+60     	; 0x1f68 <pf_open+0x232>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:422
		clst = LD_WORD(dir+DIR_FstClusHI);
    1f2c:	8d 89       	ldd	r24, Y+21	; 0x15
    1f2e:	9e 89       	ldd	r25, Y+22	; 0x16
    1f30:	b0 e0       	ldi	r27, 0x00	; 0
    1f32:	a0 e0       	ldi	r26, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:423
		clst <<= 16;
    1f34:	dc 01       	movw	r26, r24
    1f36:	99 27       	eor	r25, r25
    1f38:	88 27       	eor	r24, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:425
	}
	clst |= LD_WORD(dir+DIR_FstClusLO);
    1f3a:	4b 8d       	ldd	r20, Y+27	; 0x1b
    1f3c:	5c 8d       	ldd	r21, Y+28	; 0x1c
    1f3e:	70 e0       	ldi	r23, 0x00	; 0
    1f40:	60 e0       	ldi	r22, 0x00	; 0
    1f42:	84 2b       	or	r24, r20
    1f44:	95 2b       	or	r25, r21
    1f46:	a6 2b       	or	r26, r22
    1f48:	b7 2b       	or	r27, r23
follow_path():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:706
			if (res != FR_OK) break;		/* Could not find the object */
			if (dj->fn[11]) break;			/* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
				res = FR_NO_FILE; break;
			}
			dj->sclust = get_clust(dir);	/* Follow next */
    1f4a:	8d a3       	std	Y+37, r24	; 0x25
    1f4c:	9e a3       	std	Y+38, r25	; 0x26
    1f4e:	af a3       	std	Y+39, r26	; 0x27
    1f50:	b8 a7       	std	Y+40, r27	; 0x28
    1f52:	ab a1       	ldd	r26, Y+35	; 0x23
    1f54:	bc a1       	ldd	r27, Y+36	; 0x24
    1f56:	fd 01       	movw	r30, r26
    1f58:	cd 01       	movw	r24, r26
    1f5a:	0b 96       	adiw	r24, 0x0b	; 11
mem_set():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:330

/* Fill memory */
static
void mem_set (void* dst, int val, int cnt) {
	char *d = (char*)dst;
	while (cnt--) *d++ = (char)val;
    1f5c:	8e 17       	cp	r24, r30
    1f5e:	9f 07       	cpc	r25, r31
    1f60:	09 f4       	brne	.+2      	; 0x1f64 <pf_open+0x22e>
    1f62:	3f cf       	rjmp	.-386    	; 0x1de2 <pf_open+0xac>
    1f64:	b1 92       	st	Z+, r11
    1f66:	fa cf       	rjmp	.-12     	; 0x1f5c <pf_open+0x226>
pf_open():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:418
CLUST get_clust (
	BYTE* dir		/* Pointer to directory entry */
)
{
	FATFS *fs = FatFs;
	CLUST clst = 0;
    1f68:	80 e0       	ldi	r24, 0x00	; 0
    1f6a:	90 e0       	ldi	r25, 0x00	; 0
    1f6c:	dc 01       	movw	r26, r24
    1f6e:	e5 cf       	rjmp	.-54     	; 0x1f3a <pf_open+0x204>
    1f70:	80 e0       	ldi	r24, 0x00	; 0
    1f72:	90 e0       	ldi	r25, 0x00	; 0
    1f74:	dc 01       	movw	r26, r24
    1f76:	3d c0       	rjmp	.+122    	; 0x1ff2 <pf_open+0x2bc>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:839
	DIR dj;
	BYTE sp[12], dir[32];
	FATFS *fs = FatFs;


	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    1f78:	85 e0       	ldi	r24, 0x05	; 5
    1f7a:	90 e0       	ldi	r25, 0x00	; 0
    1f7c:	1e cf       	rjmp	.-452    	; 0x1dba <pf_open+0x84>
_ZL11create_nameP3DIRPPKc.isra.0():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:602
	p = *path;
	for (;;) {
		c = p[si++];
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') break;
    1f7e:	88 30       	cpi	r24, 0x08	; 8
    1f80:	09 f0       	breq	.+2      	; 0x1f84 <pf_open+0x24e>
    1f82:	33 cf       	rjmp	.-410    	; 0x1dea <pf_open+0xb4>
pf_open():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:603
			i = 8; ni = 11;
    1f84:	9b e0       	ldi	r25, 0x0B	; 11
_ZL11create_nameP3DIRPPKc.isra.0():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:599
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0; ni = 8;
	p = *path;
	for (;;) {
		c = p[si++];
    1f86:	28 2f       	mov	r18, r24
    1f88:	e3 2f       	mov	r30, r19
    1f8a:	89 2f       	mov	r24, r25
    1f8c:	31 e0       	ldi	r19, 0x01	; 1
    1f8e:	3e 0f       	add	r19, r30
    1f90:	ec 0d       	add	r30, r12
    1f92:	fd 2d       	mov	r31, r13
    1f94:	f1 1d       	adc	r31, r1
    1f96:	90 81       	ld	r25, Z
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:600
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
    1f98:	91 32       	cpi	r25, 0x21	; 33
    1f9a:	08 f4       	brcc	.+2      	; 0x1f9e <pf_open+0x268>
    1f9c:	26 cf       	rjmp	.-436    	; 0x1dea <pf_open+0xb4>
    1f9e:	9f 32       	cpi	r25, 0x2F	; 47
    1fa0:	09 f4       	brne	.+2      	; 0x1fa4 <pf_open+0x26e>
    1fa2:	23 cf       	rjmp	.-442    	; 0x1dea <pf_open+0xb4>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:601
		if (c == '.' || i >= ni) {
    1fa4:	9e 32       	cpi	r25, 0x2E	; 46
    1fa6:	59 f3       	breq	.-42     	; 0x1f7e <pf_open+0x248>
    1fa8:	28 17       	cp	r18, r24
    1faa:	08 f0       	brcs	.+2      	; 0x1fae <pf_open+0x278>
    1fac:	1e cf       	rjmp	.-452    	; 0x1dea <pf_open+0xb4>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:619
			sfn[i++] = d;
		} else
#endif
		{						/* Single byte code */
			if (_USE_LCC && IsLower(c)) c -= 0x20;	/* toupper */
			sfn[i++] = c;
    1fae:	fd 01       	movw	r30, r26
    1fb0:	e2 0f       	add	r30, r18
    1fb2:	f1 1d       	adc	r31, r1
    1fb4:	90 83       	st	Z, r25
    1fb6:	98 2f       	mov	r25, r24
pf_open():
    1fb8:	81 e0       	ldi	r24, 0x01	; 1
    1fba:	82 0f       	add	r24, r18
    1fbc:	e4 cf       	rjmp	.-56     	; 0x1f86 <pf_open+0x250>
follow_path():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:702
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj, dir);		/* Find it */
			if (res != FR_OK) break;		/* Could not find the object */
			if (dj->fn[11]) break;			/* Last segment match. Function completed. */
    1fbe:	f8 01       	movw	r30, r16
    1fc0:	93 85       	ldd	r25, Z+11	; 0x0b
    1fc2:	99 23       	and	r25, r25
    1fc4:	09 f4       	brne	.+2      	; 0x1fc8 <pf_open+0x292>
    1fc6:	ac cf       	rjmp	.-168    	; 0x1f20 <pf_open+0x1ea>
pf_open():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:845

	fs->flag = 0;
	dj.fn = sp;
	res = follow_path(&dj, dir, path);	/* Follow the file path */
	if (res != FR_OK) return res;		/* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
    1fc8:	89 81       	ldd	r24, Y+1	; 0x01
    1fca:	88 23       	and	r24, r24
    1fcc:	09 f4       	brne	.+2      	; 0x1fd0 <pf_open+0x29a>
    1fce:	36 cf       	rjmp	.-404    	; 0x1e3c <pf_open+0x106>
    1fd0:	8c 85       	ldd	r24, Y+12	; 0x0c
    1fd2:	84 fd       	sbrc	r24, 4
    1fd4:	33 cf       	rjmp	.-410    	; 0x1e3c <pf_open+0x106>
get_clust():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:421
{
	FATFS *fs = FatFs;
	CLUST clst = 0;


	if (_FS_32ONLY || (_FS_FAT32 && fs->fs_type == FS_FAT32)) {
    1fd6:	e0 91 a4 02 	lds	r30, 0x02A4	; 0x8002a4 <FatFs>
    1fda:	f0 91 a5 02 	lds	r31, 0x02A5	; 0x8002a5 <FatFs+0x1>
    1fde:	80 81       	ld	r24, Z
    1fe0:	83 30       	cpi	r24, 0x03	; 3
    1fe2:	31 f6       	brne	.-116    	; 0x1f70 <pf_open+0x23a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:422
		clst = LD_WORD(dir+DIR_FstClusHI);
    1fe4:	8d 89       	ldd	r24, Y+21	; 0x15
    1fe6:	9e 89       	ldd	r25, Y+22	; 0x16
    1fe8:	b0 e0       	ldi	r27, 0x00	; 0
    1fea:	a0 e0       	ldi	r26, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:423
		clst <<= 16;
    1fec:	dc 01       	movw	r26, r24
    1fee:	99 27       	eor	r25, r25
    1ff0:	88 27       	eor	r24, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:425
	}
	clst |= LD_WORD(dir+DIR_FstClusLO);
    1ff2:	4b 8d       	ldd	r20, Y+27	; 0x1b
    1ff4:	5c 8d       	ldd	r21, Y+28	; 0x1c
    1ff6:	70 e0       	ldi	r23, 0x00	; 0
    1ff8:	60 e0       	ldi	r22, 0x00	; 0
    1ffa:	84 2b       	or	r24, r20
    1ffc:	95 2b       	or	r25, r21
    1ffe:	a6 2b       	or	r26, r22
    2000:	b7 2b       	or	r27, r23
pf_open():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:848
	res = follow_path(&dj, dir, path);	/* Follow the file path */
	if (res != FR_OK) return res;		/* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
		return FR_NO_FILE;

	fs->org_clust = get_clust(dir);		/* File start cluster */
    2002:	f7 01       	movw	r30, r14
    2004:	86 8f       	std	Z+30, r24	; 0x1e
    2006:	97 8f       	std	Z+31, r25	; 0x1f
    2008:	a0 a3       	std	Z+32, r26	; 0x20
    200a:	b1 a3       	std	Z+33, r27	; 0x21
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:849
	fs->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    200c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    200e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2010:	af 8d       	ldd	r26, Y+31	; 0x1f
    2012:	b8 a1       	ldd	r27, Y+32	; 0x20
    2014:	82 8f       	std	Z+26, r24	; 0x1a
    2016:	93 8f       	std	Z+27, r25	; 0x1b
    2018:	a4 8f       	std	Z+28, r26	; 0x1c
    201a:	b5 8f       	std	Z+29, r27	; 0x1d
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:850
	fs->fptr = 0;						/* File pointer */
    201c:	16 8a       	std	Z+22, r1	; 0x16
    201e:	17 8a       	std	Z+23, r1	; 0x17
    2020:	10 8e       	std	Z+24, r1	; 0x18
    2022:	11 8e       	std	Z+25, r1	; 0x19
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:851
	fs->flag = FA_OPENED;
    2024:	81 e0       	ldi	r24, 0x01	; 1
    2026:	81 83       	std	Z+1, r24	; 0x01
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:853

	return FR_OK;
    2028:	90 e0       	ldi	r25, 0x00	; 0
    202a:	80 e0       	ldi	r24, 0x00	; 0
    202c:	c6 ce       	rjmp	.-628    	; 0x1dba <pf_open+0x84>

0000202e <pulseClock(unsigned char)>:
pulseClock():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2541


void pulseClock(byte numPulse)
// Generate <numPulse> clock pulses on the Z80 clock pin.
// The steady clock level is LOW, e.g. one clock pulse is a 0-1-0 transition
{
    202e:	cf 93       	push	r28
    2030:	df 93       	push	r29
    2032:	d8 2f       	mov	r29, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2543
  byte    i;
  for (i = 0; i < numPulse; i++)
    2034:	c0 e0       	ldi	r28, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2547
    // Generate one clock pulse
  {
    // Send one impulse (0-1-0) on the CLK output
    digitalWrite(CLK, HIGH);
    2036:	61 e0       	ldi	r22, 0x01	; 1
    2038:	8f e0       	ldi	r24, 0x0F	; 15
    203a:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2548
    digitalWrite(CLK, LOW);
    203e:	60 e0       	ldi	r22, 0x00	; 0
    2040:	8f e0       	ldi	r24, 0x0F	; 15
    2042:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2543
void pulseClock(byte numPulse)
// Generate <numPulse> clock pulses on the Z80 clock pin.
// The steady clock level is LOW, e.g. one clock pulse is a 0-1-0 transition
{
  byte    i;
  for (i = 0; i < numPulse; i++)
    2046:	cf 5f       	subi	r28, 0xFF	; 255
    2048:	dc 13       	cpse	r29, r28
    204a:	f5 cf       	rjmp	.-22     	; 0x2036 <pulseClock(unsigned char)+0x8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2550
  {
    // Send one impulse (0-1-0) on the CLK output
    digitalWrite(CLK, HIGH);
    digitalWrite(CLK, LOW);
  }
}
    204c:	df 91       	pop	r29
    204e:	cf 91       	pop	r28
    2050:	08 95       	ret

00002052 <loadHL(unsigned int)>:
loadHL():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2600
// ------------------------------------------------------------------------------

void loadHL(word value)
// Load "value" word into the HL registers inside the Z80 CPU, using the "LD HL,nn" instruction.
// In the following "T" are the T-cycles of the Z80 (See the Z80 datashet).
{
    2052:	1f 93       	push	r17
    2054:	cf 93       	push	r28
    2056:	df 93       	push	r29
    2058:	18 2f       	mov	r17, r24
    205a:	d9 2f       	mov	r29, r25
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2603
  // Execute the LD dd,nn instruction (T = 4+3+3), with dd = HL and nn = value. See the Z80 datasheet and manual.
  // After the execution of this instruction the word "value" (16bit) is loaded into HL.
  pulseClock(1);                      // Execute the T1 cycle of M1 (Instruction Fetch machine cycle)
    205c:	81 e0       	ldi	r24, 0x01	; 1
    205e:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2604
  digitalWrite(RAM_CE2, LOW);         // Force the RAM in HiZ (CE2 = LOW)
    2062:	60 e0       	ldi	r22, 0x00	; 0
    2064:	82 e0       	ldi	r24, 0x02	; 2
    2066:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2605
  DDRA = 0xFF;                        // Configure Z80 data bus D0-D7 (PA0-PA7) as output
    206a:	cf ef       	ldi	r28, 0xFF	; 255
    206c:	ca bb       	out	0x1a, r28	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2606
  PORTA = LD_HLnn;                    // Write "LD HL, n" instruction on data bus
    206e:	81 e2       	ldi	r24, 0x21	; 33
    2070:	8b bb       	out	0x1b, r24	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2607
  pulseClock(2);                      // Execute T2 and T3 cycles of M1
    2072:	82 e0       	ldi	r24, 0x02	; 2
    2074:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2608
  DDRA = 0x00;                        // Configure Z80 data bus D0-D7 (PA0-PA7) as input...
    2078:	1a ba       	out	0x1a, r1	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2609
  PORTA = 0xFF;                       // ...with pull-up
    207a:	cb bb       	out	0x1b, r28	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2610
  pulseClock(2);                      // Complete the execution of M1 and execute the T1 cycle of the following
    207c:	82 e0       	ldi	r24, 0x02	; 2
    207e:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2612
  // Memory Read machine cycle
  DDRA = 0xFF;                        // Configure Z80 data bus D0-D7 (PA0-PA7) as output
    2082:	ca bb       	out	0x1a, r28	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2613
  PORTA = lowByte(value);             // Write first byte of "value" to load in HL
    2084:	1b bb       	out	0x1b, r17	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2614
  pulseClock(3);                      // Execute the T2 and T3 cycles of the first Memory Read machine cycle
    2086:	83 e0       	ldi	r24, 0x03	; 3
    2088:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2616
  // and T1, of the second Memory Read machine cycle
  PORTA = highByte(value);            // Write second byte of "value" to load in HL
    208c:	db bb       	out	0x1b, r29	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2617
  pulseClock(2);                      // Execute the T2 and T3 cycles of the second Memory Read machine cycle
    208e:	82 e0       	ldi	r24, 0x02	; 2
    2090:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2618
  DDRA = 0x00;                        // Configure Z80 data bus D0-D7 (PA0-PA7) as input...
    2094:	1a ba       	out	0x1a, r1	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2619
  PORTA = 0xFF;                       // ...with pull-up
    2096:	cb bb       	out	0x1b, r28	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2620
  digitalWrite(RAM_CE2, HIGH);        // Enable the RAM again (CE2 = HIGH)
    2098:	61 e0       	ldi	r22, 0x01	; 1
    209a:	82 e0       	ldi	r24, 0x02	; 2
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2621
}
    209c:	df 91       	pop	r29
    209e:	cf 91       	pop	r28
    20a0:	1f 91       	pop	r17
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2620
  // and T1, of the second Memory Read machine cycle
  PORTA = highByte(value);            // Write second byte of "value" to load in HL
  pulseClock(2);                      // Execute the T2 and T3 cycles of the second Memory Read machine cycle
  DDRA = 0x00;                        // Configure Z80 data bus D0-D7 (PA0-PA7) as input...
  PORTA = 0xFF;                       // ...with pull-up
  digitalWrite(RAM_CE2, HIGH);        // Enable the RAM again (CE2 = HIGH)
    20a2:	0c 94 42 06 	jmp	0xc84	; 0xc84 <digitalWrite>

000020a6 <loadByteToRAM(unsigned char)>:
loadByteToRAM():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2561
// The RAM_CE2 signal is used to force the RAM in HiZ, so the Atmega can write the needed instruction/data
//  on the data bus. Controlling the clock signal and knowing exactly how many clocks pulse are required it
//  is possible control the whole loading process.
// In the following "T" are the T-cycles of the Z80 (See the Z80 datashet).
// The two instruction are "LD (HL), n" and "INC (HL)".
{
    20a6:	cf 93       	push	r28
    20a8:	df 93       	push	r29
    20aa:	d8 2f       	mov	r29, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2565

  // Execute the LD(HL),n instruction (T = 4+3+3). See the Z80 datasheet and manual.
  // After the execution of this instruction the <value> byte is loaded in the memory address pointed by HL.
  pulseClock(1);                      // Execute the T1 cycle of M1 (Instruction Fetch machine cycle)
    20ac:	81 e0       	ldi	r24, 0x01	; 1
    20ae:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2566
  digitalWrite(RAM_CE2, LOW);         // Force the RAM in HiZ (CE2 = LOW)
    20b2:	60 e0       	ldi	r22, 0x00	; 0
    20b4:	82 e0       	ldi	r24, 0x02	; 2
    20b6:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2567
  DDRA = 0xFF;                        // Configure Z80 data bus D0-D7 (PA0-PA7) as output
    20ba:	cf ef       	ldi	r28, 0xFF	; 255
    20bc:	ca bb       	out	0x1a, r28	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2568
  PORTA = LD_HL;                      // Write "LD (HL), n" instruction on data bus
    20be:	86 e3       	ldi	r24, 0x36	; 54
    20c0:	8b bb       	out	0x1b, r24	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2569
  pulseClock(2);                      // Execute T2 and T3 cycles of M1
    20c2:	82 e0       	ldi	r24, 0x02	; 2
    20c4:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2570
  DDRA = 0x00;                        // Configure Z80 data bus D0-D7 (PA0-PA7) as input...
    20c8:	1a ba       	out	0x1a, r1	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2571
  PORTA = 0xFF;                       // ...with pull-up
    20ca:	cb bb       	out	0x1b, r28	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2572
  pulseClock(2);                      // Complete the execution of M1 and execute the T1 cycle of the following
    20cc:	82 e0       	ldi	r24, 0x02	; 2
    20ce:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2574
  // Memory Read machine cycle
  DDRA = 0xFF;                        // Configure Z80 data bus D0-D7 (PA0-PA7) as output
    20d2:	ca bb       	out	0x1a, r28	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2575
  PORTA = value;                      // Write the byte to load in RAM on data bus
    20d4:	db bb       	out	0x1b, r29	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2576
  pulseClock(2);                      // Execute the T2 and T3 cycles of the Memory Read machine cycle
    20d6:	82 e0       	ldi	r24, 0x02	; 2
    20d8:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2577
  DDRA = 0x00;                        // Configure Z80 data bus D0-D7 (PA0-PA7) as input...
    20dc:	1a ba       	out	0x1a, r1	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2578
  PORTA = 0xFF;                       // ...with pull-up
    20de:	cb bb       	out	0x1b, r28	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2579
  digitalWrite(RAM_CE2, HIGH);        // Enable the RAM again (CE2 = HIGH)
    20e0:	61 e0       	ldi	r22, 0x01	; 1
    20e2:	82 e0       	ldi	r24, 0x02	; 2
    20e4:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2580
  pulseClock(3);                      // Execute all the following Memory Write machine cycle
    20e8:	83 e0       	ldi	r24, 0x03	; 3
    20ea:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2584

  // Execute the INC(HL) instruction (T = 6). See the Z80 datasheet and manual.
  // After the execution of this instruction HL points to the next memory address.
  pulseClock(1);                      // Execute the T1 cycle of M1 (Instruction Fetch machine cycle)
    20ee:	81 e0       	ldi	r24, 0x01	; 1
    20f0:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2585
  digitalWrite(RAM_CE2, LOW);         // Force the RAM in HiZ (CE2 = LOW)
    20f4:	60 e0       	ldi	r22, 0x00	; 0
    20f6:	82 e0       	ldi	r24, 0x02	; 2
    20f8:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2586
  DDRA = 0xFF;                        // Configure Z80 data bus D0-D7 (PA0-PA7) as output
    20fc:	ca bb       	out	0x1a, r28	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2587
  PORTA = INC_HL;                     // Write "INC(HL)" instruction on data bus
    20fe:	83 e2       	ldi	r24, 0x23	; 35
    2100:	8b bb       	out	0x1b, r24	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2588
  pulseClock(2);                      // Execute T2 and T3 cycles of M1
    2102:	82 e0       	ldi	r24, 0x02	; 2
    2104:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2589
  DDRA = 0x00;                        // Configure Z80 data bus D0-D7 (PA0-PA7) as input...
    2108:	1a ba       	out	0x1a, r1	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2590
  PORTA = 0xFF;                       // ...with pull-up
    210a:	cb bb       	out	0x1b, r28	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2591
  digitalWrite(RAM_CE2, HIGH);        // Enable the RAM again (CE2 = HIGH)
    210c:	61 e0       	ldi	r22, 0x01	; 1
    210e:	82 e0       	ldi	r24, 0x02	; 2
    2110:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2592
  pulseClock(3);                      // Execute all the remaining T cycles
    2114:	83 e0       	ldi	r24, 0x03	; 3
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2593
}
    2116:	df 91       	pop	r29
    2118:	cf 91       	pop	r28
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2592
  PORTA = INC_HL;                     // Write "INC(HL)" instruction on data bus
  pulseClock(2);                      // Execute T2 and T3 cycles of M1
  DDRA = 0x00;                        // Configure Z80 data bus D0-D7 (PA0-PA7) as input...
  PORTA = 0xFF;                       // ...with pull-up
  digitalWrite(RAM_CE2, HIGH);        // Enable the RAM again (CE2 = HIGH)
  pulseClock(3);                      // Execute all the remaining T cycles
    211a:	0c 94 17 10 	jmp	0x202e	; 0x202e <pulseClock(unsigned char)>

0000211e <serialEvent()>:
serialEvent():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2110

void serialEvent()
// Set INT_ to ACTIVE if there are received chars from serial to read and if the interrupt generation is enabled
// and a previous serial Rx was done by the Z80 CPU
{
  if ((Serial.available() > 0) && (Z80IntRx == 1) && (RxDoneFlag))
    211e:	86 ea       	ldi	r24, 0xA6	; 166
    2120:	92 e0       	ldi	r25, 0x02	; 2
    2122:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
    2126:	18 16       	cp	r1, r24
    2128:	19 06       	cpc	r1, r25
    212a:	9c f4       	brge	.+38     	; 0x2152 <serialEvent()+0x34>
    212c:	80 91 f0 01 	lds	r24, 0x01F0	; 0x8001f0 <Z80IntRx>
    2130:	81 30       	cpi	r24, 0x01	; 1
    2132:	79 f4       	brne	.+30     	; 0x2152 <serialEvent()+0x34>
    2134:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <RxDoneFlag>
    2138:	88 23       	and	r24, r24
    213a:	59 f0       	breq	.+22     	; 0x2152 <serialEvent()+0x34>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2112
  {
    digitalWrite(INT_, LOW);
    213c:	60 e0       	ldi	r22, 0x00	; 0
    213e:	81 e0       	ldi	r24, 0x01	; 1
    2140:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2113
    irqStatus = irqStatus | B00000001;            // Set the serial Rx IRQ status bit (see SYSIRQ Opcode)
    2144:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <irqStatus>
    2148:	81 60       	ori	r24, 0x01	; 1
    214a:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <irqStatus>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2114
    RxDoneFlag = 0;
    214e:	10 92 6b 00 	sts	0x006B, r1	; 0x80006b <RxDoneFlag>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2116
  }
}
    2152:	08 95       	ret

00002154 <serialEventRun()>:
serialEventRun():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:67
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    2154:	0e 94 4b 05 	call	0xa96	; 0xa96 <Serial0_available()>
    2158:	81 11       	cpse	r24, r1
    215a:	0c 94 8f 10 	jmp	0x211e	; 0x211e <serialEvent()>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:78
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
    215e:	08 95       	ret

00002160 <TwoWire::requestFrom(int, int) [clone .constprop.21]>:
requestFrom():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:183
uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity)
{
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
}

uint8_t TwoWire::requestFrom(int address, int quantity)
    2160:	ac 01       	movw	r20, r24
twi_readFrom():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:177
        twi_handleTimeout(twi_do_reset_on_timeout);
        return 0;
      }
    }
  #else
    while(TWI_READY != twi_state){
    2162:	80 91 30 02 	lds	r24, 0x0230	; 0x800230 <twi_state>
    2166:	81 11       	cpse	r24, r1
    2168:	fc cf       	rjmp	.-8      	; 0x2162 <TwoWire::requestFrom(int, int) [clone .constprop.21]+0x2>
requestFrom():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:185
{
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
    216a:	96 2f       	mov	r25, r22
twi_readFrom():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:181
      continue;
    }
  #endif
  twi_state = TWI_MRX;
    216c:	81 e0       	ldi	r24, 0x01	; 1
    216e:	80 93 30 02 	sts	0x0230, r24	; 0x800230 <twi_state>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:182
  twi_sendStop = sendStop;
    2172:	80 93 2f 02 	sts	0x022F, r24	; 0x80022f <twi_sendStop>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:184
  // reset error state (0xFF.. no error occurred)
  twi_error = 0xFF;
    2176:	2f ef       	ldi	r18, 0xFF	; 255
    2178:	20 93 2e 02 	sts	0x022E, r18	; 0x80022e <twi_error>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:187

  // initialize buffer iteration vars
  twi_masterBuffer = data;
    217c:	23 e0       	ldi	r18, 0x03	; 3
    217e:	32 e0       	ldi	r19, 0x02	; 2
    2180:	30 93 2d 02 	sts	0x022D, r19	; 0x80022d <twi_masterBuffer+0x1>
    2184:	20 93 2c 02 	sts	0x022C, r18	; 0x80022c <twi_masterBuffer>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:188
  twi_masterBufferIndex = 0;
    2188:	10 92 2b 02 	sts	0x022B, r1	; 0x80022b <twi_masterBufferIndex>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:189
  twi_masterBufferLength = length-1;  // This is not intuitive, read on...
    218c:	2f ef       	ldi	r18, 0xFF	; 255
    218e:	26 0f       	add	r18, r22
    2190:	20 93 2a 02 	sts	0x022A, r18	; 0x80022a <twi_masterBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:197
  // Therefore we must actually set NACK when the _next_ to last byte is
  // received, causing that NACK to be sent in response to receiving the last
  // expected byte of data.

  // build sla+w, slave device address + w bit
  twi_slarw = TW_READ;
    2194:	80 93 29 02 	sts	0x0229, r24	; 0x800229 <twi_slarw>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:198
  twi_slarw |= address << 1;
    2198:	20 91 29 02 	lds	r18, 0x0229	; 0x800229 <twi_slarw>
    219c:	44 0f       	add	r20, r20
    219e:	55 1f       	adc	r21, r21
    21a0:	82 2f       	mov	r24, r18
    21a2:	84 2b       	or	r24, r20
    21a4:	80 93 29 02 	sts	0x0229, r24	; 0x800229 <twi_slarw>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:200

  if (true == twi_inRepStart) {
    21a8:	80 91 28 02 	lds	r24, 0x0228	; 0x800228 <twi_inRepStart>
    21ac:	81 30       	cpi	r24, 0x01	; 1
    21ae:	d1 f4       	brne	.+52     	; 0x21e4 <TwoWire::requestFrom(int, int) [clone .constprop.21]+0x84>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:207
    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
    // We need to remove ourselves from the repeated start state before we enable interrupts,
    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
    // up. Also, don't enable the START interrupt. There may be one pending from the
    // repeated start that we sent ourselves, and that would really confuse things.
    twi_inRepStart = false; // Remember, we're dealing with an ASYNC ISR
    21b0:	10 92 28 02 	sts	0x0228, r1	; 0x800228 <twi_inRepStart>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:219
          return 0;
        }
      } while(TWCR & _BV(TWWC));
    #else
      do {
        TWDR = twi_slarw;
    21b4:	80 91 29 02 	lds	r24, 0x0229	; 0x800229 <twi_slarw>
    21b8:	83 b9       	out	0x03, r24	; 3
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:220
      } while(TWCR & _BV(TWWC));
    21ba:	06 b6       	in	r0, 0x36	; 54
    21bc:	03 fc       	sbrc	r0, 3
    21be:	fa cf       	rjmp	.-12     	; 0x21b4 <TwoWire::requestFrom(int, int) [clone .constprop.21]+0x54>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:222
    #endif
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);  // enable INTs, but not START
    21c0:	85 ec       	ldi	r24, 0xC5	; 197
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:226
  }
  else
    // send start condition
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);
    21c2:	86 bf       	out	0x36, r24	; 54
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:238
        twi_handleTimeout(twi_do_reset_on_timeout);
        return 0;
      }
    }
  #else
    while(TWI_MRX == twi_state){
    21c4:	80 91 30 02 	lds	r24, 0x0230	; 0x800230 <twi_state>
    21c8:	81 30       	cpi	r24, 0x01	; 1
    21ca:	e1 f3       	breq	.-8      	; 0x21c4 <TwoWire::requestFrom(int, int) [clone .constprop.21]+0x64>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:243
      continue;
    }
  #endif

  if (twi_masterBufferIndex < length)
    21cc:	80 91 2b 02 	lds	r24, 0x022B	; 0x80022b <twi_masterBufferIndex>
    21d0:	86 17       	cp	r24, r22
    21d2:	10 f4       	brcc	.+4      	; 0x21d8 <TwoWire::requestFrom(int, int) [clone .constprop.21]+0x78>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:244
    length = twi_masterBufferIndex;
    21d4:	90 91 2b 02 	lds	r25, 0x022B	; 0x80022b <twi_masterBufferIndex>
requestFrom():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:120
    quantity = TWI_BUFFER_SIZE;
  }
  // perform blocking read into buffer
  uint8_t read = twi_readFrom(address, rxBuffer, quantity, sendStop);
  // set rx buffer iterator vars
  rxBufferIndex = 0;
    21d8:	10 92 24 02 	sts	0x0224, r1	; 0x800224 <TwoWire::rxBufferIndex>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:121
  rxBufferLength = read;
    21dc:	90 93 23 02 	sts	0x0223, r25	; 0x800223 <TwoWire::rxBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:186
}

uint8_t TwoWire::requestFrom(int address, int quantity)
{
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
}
    21e0:	89 2f       	mov	r24, r25
    21e2:	08 95       	ret
twi_readFrom():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:226
    #endif
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);  // enable INTs, but not START
  }
  else
    // send start condition
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);
    21e4:	85 ee       	ldi	r24, 0xE5	; 229
    21e6:	ed cf       	rjmp	.-38     	; 0x21c2 <TwoWire::requestFrom(int, int) [clone .constprop.21]+0x62>

000021e8 <readRTC(unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*) [clone .constprop.20]>:
readRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2219
  return ( (val / 16 * 10) + (val % 16) );
}

// ------------------------------------------------------------------------------

void readRTC(byte *second, byte *minute, byte *hour, byte *day, byte *month, byte *year, byte *tempC)
    21e8:	cf 93       	push	r28
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
  txBufferLength = 0;
}

void TwoWire::beginTransmission(int address)
{
  beginTransmission((uint8_t)address);
    21ea:	88 e6       	ldi	r24, 0x68	; 104
    21ec:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
readRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2224
// Read current date/time binary values and the temprerature (2 complement) from the DS3231 RTC
{
  byte    i;
  Wire.beginTransmission(DS3231_RTC);
  Wire.write(DS3231_SECRG);                       // Set the DS3231 Seconds Register
    21f0:	90 e0       	ldi	r25, 0x00	; 0
    21f2:	80 e0       	ldi	r24, 0x00	; 0
    21f4:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2225
  Wire.endTransmission();
    21f8:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2227
  // Read from RTC and convert to binary
  Wire.requestFrom(DS3231_RTC, 18);
    21fc:	62 e1       	ldi	r22, 0x12	; 18
    21fe:	70 e0       	ldi	r23, 0x00	; 0
    2200:	88 e6       	ldi	r24, 0x68	; 104
    2202:	90 e0       	ldi	r25, 0x00	; 0
    2204:	0e 94 b0 10 	call	0x2160	; 0x2160 <TwoWire::requestFrom(int, int) [clone .constprop.21]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2228
  *second = bcdToDec(Wire.read() & 0x7f);
    2208:	0e 94 b7 04 	call	0x96e	; 0x96e <TwoWire::read() [clone .constprop.26]>
bcdToDec():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2214
// ------------------------------------------------------------------------------

byte bcdToDec(byte val)
// Convert binary coded decimal to normal decimal numbers
{
  return ( (val / 16 * 10) + (val % 16) );
    220c:	98 2f       	mov	r25, r24
    220e:	92 95       	swap	r25
    2210:	97 70       	andi	r25, 0x07	; 7
    2212:	ca e0       	ldi	r28, 0x0A	; 10
    2214:	8f 70       	andi	r24, 0x0F	; 15
    2216:	9c 9f       	mul	r25, r28
    2218:	80 0d       	add	r24, r0
    221a:	11 24       	eor	r1, r1
readRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2228
  Wire.beginTransmission(DS3231_RTC);
  Wire.write(DS3231_SECRG);                       // Set the DS3231 Seconds Register
  Wire.endTransmission();
  // Read from RTC and convert to binary
  Wire.requestFrom(DS3231_RTC, 18);
  *second = bcdToDec(Wire.read() & 0x7f);
    221c:	80 93 27 02 	sts	0x0227, r24	; 0x800227 <seconds>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2229
  *minute = bcdToDec(Wire.read());
    2220:	0e 94 b7 04 	call	0x96e	; 0x96e <TwoWire::read() [clone .constprop.26]>
bcdToDec():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2214
// ------------------------------------------------------------------------------

byte bcdToDec(byte val)
// Convert binary coded decimal to normal decimal numbers
{
  return ( (val / 16 * 10) + (val % 16) );
    2224:	98 2f       	mov	r25, r24
    2226:	92 95       	swap	r25
    2228:	9f 70       	andi	r25, 0x0F	; 15
    222a:	8f 70       	andi	r24, 0x0F	; 15
    222c:	9c 9f       	mul	r25, r28
    222e:	80 0d       	add	r24, r0
    2230:	11 24       	eor	r1, r1
readRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2229
  Wire.write(DS3231_SECRG);                       // Set the DS3231 Seconds Register
  Wire.endTransmission();
  // Read from RTC and convert to binary
  Wire.requestFrom(DS3231_RTC, 18);
  *second = bcdToDec(Wire.read() & 0x7f);
  *minute = bcdToDec(Wire.read());
    2232:	80 93 26 02 	sts	0x0226, r24	; 0x800226 <minutes>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2230
  *hour = bcdToDec(Wire.read() & 0x3f);
    2236:	0e 94 b7 04 	call	0x96e	; 0x96e <TwoWire::read() [clone .constprop.26]>
bcdToDec():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2214
// ------------------------------------------------------------------------------

byte bcdToDec(byte val)
// Convert binary coded decimal to normal decimal numbers
{
  return ( (val / 16 * 10) + (val % 16) );
    223a:	98 2f       	mov	r25, r24
    223c:	92 95       	swap	r25
    223e:	93 70       	andi	r25, 0x03	; 3
    2240:	8f 70       	andi	r24, 0x0F	; 15
    2242:	9c 9f       	mul	r25, r28
    2244:	80 0d       	add	r24, r0
    2246:	11 24       	eor	r1, r1
readRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2230
  Wire.endTransmission();
  // Read from RTC and convert to binary
  Wire.requestFrom(DS3231_RTC, 18);
  *second = bcdToDec(Wire.read() & 0x7f);
  *minute = bcdToDec(Wire.read());
  *hour = bcdToDec(Wire.read() & 0x3f);
    2248:	80 93 25 02 	sts	0x0225, r24	; 0x800225 <hours>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2231
  Wire.read();                                    // Jump over the DoW
    224c:	0e 94 b7 04 	call	0x96e	; 0x96e <TwoWire::read() [clone .constprop.26]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2232
  *day = bcdToDec(Wire.read());
    2250:	0e 94 b7 04 	call	0x96e	; 0x96e <TwoWire::read() [clone .constprop.26]>
bcdToDec():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2214
// ------------------------------------------------------------------------------

byte bcdToDec(byte val)
// Convert binary coded decimal to normal decimal numbers
{
  return ( (val / 16 * 10) + (val % 16) );
    2254:	98 2f       	mov	r25, r24
    2256:	92 95       	swap	r25
    2258:	9f 70       	andi	r25, 0x0F	; 15
    225a:	8f 70       	andi	r24, 0x0F	; 15
    225c:	9c 9f       	mul	r25, r28
    225e:	80 0d       	add	r24, r0
    2260:	11 24       	eor	r1, r1
readRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2232
  Wire.requestFrom(DS3231_RTC, 18);
  *second = bcdToDec(Wire.read() & 0x7f);
  *minute = bcdToDec(Wire.read());
  *hour = bcdToDec(Wire.read() & 0x3f);
  Wire.read();                                    // Jump over the DoW
  *day = bcdToDec(Wire.read());
    2262:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <day>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2233
  *month = bcdToDec(Wire.read());
    2266:	0e 94 b7 04 	call	0x96e	; 0x96e <TwoWire::read() [clone .constprop.26]>
bcdToDec():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2214
// ------------------------------------------------------------------------------

byte bcdToDec(byte val)
// Convert binary coded decimal to normal decimal numbers
{
  return ( (val / 16 * 10) + (val % 16) );
    226a:	98 2f       	mov	r25, r24
    226c:	92 95       	swap	r25
    226e:	9f 70       	andi	r25, 0x0F	; 15
    2270:	8f 70       	andi	r24, 0x0F	; 15
    2272:	9c 9f       	mul	r25, r28
    2274:	80 0d       	add	r24, r0
    2276:	11 24       	eor	r1, r1
readRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2233
  *second = bcdToDec(Wire.read() & 0x7f);
  *minute = bcdToDec(Wire.read());
  *hour = bcdToDec(Wire.read() & 0x3f);
  Wire.read();                                    // Jump over the DoW
  *day = bcdToDec(Wire.read());
  *month = bcdToDec(Wire.read());
    2278:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <month>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2234
  *year = bcdToDec(Wire.read());
    227c:	0e 94 b7 04 	call	0x96e	; 0x96e <TwoWire::read() [clone .constprop.26]>
bcdToDec():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2214
// ------------------------------------------------------------------------------

byte bcdToDec(byte val)
// Convert binary coded decimal to normal decimal numbers
{
  return ( (val / 16 * 10) + (val % 16) );
    2280:	98 2f       	mov	r25, r24
    2282:	92 95       	swap	r25
    2284:	9f 70       	andi	r25, 0x0F	; 15
    2286:	8f 70       	andi	r24, 0x0F	; 15
    2288:	9c 9f       	mul	r25, r28
    228a:	80 0d       	add	r24, r0
    228c:	11 24       	eor	r1, r1
readRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2234
  *minute = bcdToDec(Wire.read());
  *hour = bcdToDec(Wire.read() & 0x3f);
  Wire.read();                                    // Jump over the DoW
  *day = bcdToDec(Wire.read());
  *month = bcdToDec(Wire.read());
  *year = bcdToDec(Wire.read());
    228e:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <year>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2235
  for (i = 0; i < 10; i++) Wire.read();           // Jump over 10 registers
    2292:	0e 94 b7 04 	call	0x96e	; 0x96e <TwoWire::read() [clone .constprop.26]>
    2296:	c1 50       	subi	r28, 0x01	; 1
    2298:	e1 f7       	brne	.-8      	; 0x2292 <readRTC(unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*) [clone .constprop.20]+0xaa>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2236
  *tempC = Wire.read();
    229a:	0e 94 b7 04 	call	0x96e	; 0x96e <TwoWire::read() [clone .constprop.26]>
    229e:	80 93 ff 01 	sts	0x01FF, r24	; 0x8001ff <tempC>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2237
}
    22a2:	cf 91       	pop	r28
    22a4:	08 95       	ret

000022a6 <Print::write(char const*) [clone .part.2]>:
_ZN5Print5writeEPKc.part.2():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.h:54
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
    22a6:	fb 01       	movw	r30, r22
    22a8:	01 90       	ld	r0, Z+
    22aa:	00 20       	and	r0, r0
    22ac:	e9 f7       	brne	.-6      	; 0x22a8 <Print::write(char const*) [clone .part.2]+0x2>
    22ae:	31 97       	sbiw	r30, 0x01	; 1
    22b0:	af 01       	movw	r20, r30
    22b2:	46 1b       	sub	r20, r22
    22b4:	57 0b       	sbc	r21, r23
    22b6:	dc 01       	movw	r26, r24
    22b8:	ed 91       	ld	r30, X+
    22ba:	fc 91       	ld	r31, X
    22bc:	02 80       	ldd	r0, Z+2	; 0x02
    22be:	f3 81       	ldd	r31, Z+3	; 0x03
    22c0:	e0 2d       	mov	r30, r0
    22c2:	09 94       	ijmp

000022c4 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]>:
printNumber():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:232
  return vfprintf_P(&f, (const char *)format, ap);
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
    22c4:	8f 92       	push	r8
    22c6:	9f 92       	push	r9
    22c8:	af 92       	push	r10
    22ca:	bf 92       	push	r11
    22cc:	0f 93       	push	r16
    22ce:	1f 93       	push	r17
    22d0:	cf 93       	push	r28
    22d2:	df 93       	push	r29
    22d4:	cd b7       	in	r28, 0x3d	; 61
    22d6:	de b7       	in	r29, 0x3e	; 62
    22d8:	a1 97       	sbiw	r28, 0x21	; 33
    22da:	0f b6       	in	r0, 0x3f	; 63
    22dc:	f8 94       	cli
    22de:	de bf       	out	0x3e, r29	; 62
    22e0:	0f be       	out	0x3f, r0	; 63
    22e2:	cd bf       	out	0x3d, r28	; 61
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:237
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    22e4:	19 a2       	std	Y+33, r1	; 0x21
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:240

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
    22e6:	42 30       	cpi	r20, 0x02	; 2
    22e8:	08 f4       	brcc	.+2      	; 0x22ec <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]+0x28>
    22ea:	4a e0       	ldi	r20, 0x0A	; 10
    22ec:	8e 01       	movw	r16, r28
    22ee:	0f 5d       	subi	r16, 0xDF	; 223
    22f0:	1f 4f       	sbci	r17, 0xFF	; 255
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:243

  do {
    char c = n % base;
    22f2:	84 2e       	mov	r8, r20
    22f4:	91 2c       	mov	r9, r1
    22f6:	b1 2c       	mov	r11, r1
    22f8:	a1 2c       	mov	r10, r1
    22fa:	a5 01       	movw	r20, r10
    22fc:	94 01       	movw	r18, r8
    22fe:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <__udivmodsi4>
    2302:	e6 2f       	mov	r30, r22
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:244
    n /= base;
    2304:	b9 01       	movw	r22, r18
    2306:	ca 01       	movw	r24, r20
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:246

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    2308:	ea 30       	cpi	r30, 0x0A	; 10
    230a:	04 f5       	brge	.+64     	; 0x234c <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]+0x88>
    230c:	e0 5d       	subi	r30, 0xD0	; 208
    230e:	d8 01       	movw	r26, r16
    2310:	ee 93       	st	-X, r30
    2312:	8d 01       	movw	r16, r26
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:247
  } while(n);
    2314:	23 2b       	or	r18, r19
    2316:	24 2b       	or	r18, r20
    2318:	25 2b       	or	r18, r21
    231a:	79 f7       	brne	.-34     	; 0x22fa <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]+0x36>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.h:53
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    231c:	90 e0       	ldi	r25, 0x00	; 0
    231e:	80 e0       	ldi	r24, 0x00	; 0
write():
    2320:	10 97       	sbiw	r26, 0x00	; 0
    2322:	29 f0       	breq	.+10     	; 0x232e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]+0x6a>
    2324:	bd 01       	movw	r22, r26
    2326:	86 ea       	ldi	r24, 0xA6	; 166
    2328:	92 e0       	ldi	r25, 0x02	; 2
    232a:	0e 94 53 11 	call	0x22a6	; 0x22a6 <Print::write(char const*) [clone .part.2]>
printNumber():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:250

  return write(str);
}
    232e:	a1 96       	adiw	r28, 0x21	; 33
    2330:	0f b6       	in	r0, 0x3f	; 63
    2332:	f8 94       	cli
    2334:	de bf       	out	0x3e, r29	; 62
    2336:	0f be       	out	0x3f, r0	; 63
    2338:	cd bf       	out	0x3d, r28	; 61
    233a:	df 91       	pop	r29
    233c:	cf 91       	pop	r28
    233e:	1f 91       	pop	r17
    2340:	0f 91       	pop	r16
    2342:	bf 90       	pop	r11
    2344:	af 90       	pop	r10
    2346:	9f 90       	pop	r9
    2348:	8f 90       	pop	r8
    234a:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:246

  do {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    234c:	e9 5c       	subi	r30, 0xC9	; 201
    234e:	df cf       	rjmp	.-66     	; 0x230e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]+0x4a>

00002350 <Print::print(int, int) [clone .constprop.16]>:
print():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:77
size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
    2350:	cf 92       	push	r12
    2352:	df 92       	push	r13
    2354:	ef 92       	push	r14
    2356:	ff 92       	push	r15
    2358:	cf 93       	push	r28
    235a:	df 93       	push	r29
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:79
{
  return print((long) n, base);
    235c:	6c 01       	movw	r12, r24
    235e:	99 0f       	add	r25, r25
    2360:	ee 08       	sbc	r14, r14
    2362:	ff 08       	sbc	r15, r15
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:92
size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
    2364:	f7 fe       	sbrs	r15, 7
    2366:	19 c0       	rjmp	.+50     	; 0x239a <Print::print(int, int) [clone .constprop.16]+0x4a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:69
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
    2368:	6d e2       	ldi	r22, 0x2D	; 45
    236a:	86 ea       	ldi	r24, 0xA6	; 166
    236c:	92 e0       	ldi	r25, 0x02	; 2
    236e:	0e 94 76 05 	call	0xaec	; 0xaec <HardwareSerial::write(unsigned char)>
    2372:	ec 01       	movw	r28, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:94
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
      n = -n;
    2374:	66 27       	eor	r22, r22
    2376:	77 27       	eor	r23, r23
    2378:	cb 01       	movw	r24, r22
    237a:	6c 19       	sub	r22, r12
    237c:	7d 09       	sbc	r23, r13
    237e:	8e 09       	sbc	r24, r14
    2380:	9f 09       	sbc	r25, r15
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:95
      return printNumber(n, 10) + t;
    2382:	4a e0       	ldi	r20, 0x0A	; 10
    2384:	0e 94 62 11 	call	0x22c4	; 0x22c4 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]>
    2388:	8c 0f       	add	r24, r28
    238a:	9d 1f       	adc	r25, r29
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:80
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
}
    238c:	df 91       	pop	r29
    238e:	cf 91       	pop	r28
    2390:	ff 90       	pop	r15
    2392:	ef 90       	pop	r14
    2394:	df 90       	pop	r13
    2396:	cf 90       	pop	r12
    2398:	08 95       	ret
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:97
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
    239a:	4a e0       	ldi	r20, 0x0A	; 10
    239c:	c7 01       	movw	r24, r14
    239e:	b6 01       	movw	r22, r12
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:80
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
}
    23a0:	df 91       	pop	r29
    23a2:	cf 91       	pop	r28
    23a4:	ff 90       	pop	r15
    23a6:	ef 90       	pop	r14
    23a8:	df 90       	pop	r13
    23aa:	cf 90       	pop	r12
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:97
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
    23ac:	0c 94 62 11 	jmp	0x22c4	; 0x22c4 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]>

000023b0 <Print::println() [clone .constprop.49]>:
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:126
size_t Print::print(const Printable& x)
{
  return x.printTo(*this);
}

size_t Print::println(void)
    23b0:	66 ed       	ldi	r22, 0xD6	; 214
    23b2:	70 e0       	ldi	r23, 0x00	; 0
    23b4:	86 ea       	ldi	r24, 0xA6	; 166
    23b6:	92 e0       	ldi	r25, 0x02	; 2
    23b8:	0c 94 53 11 	jmp	0x22a6	; 0x22a6 <Print::write(char const*) [clone .part.2]>

000023bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>:
println():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:114
size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
}

size_t Print::println(const __FlashStringHelper *ifsh)
    23bc:	cf 93       	push	r28
    23be:	df 93       	push	r29
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:116
{
  size_t n = print(ifsh);
    23c0:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
    23c4:	ec 01       	movw	r28, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:117
  n += println();
    23c6:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:119
  return n;
}
    23ca:	8c 0f       	add	r24, r28
    23cc:	9d 1f       	adc	r25, r29
    23ce:	df 91       	pop	r29
    23d0:	cf 91       	pop	r28
    23d2:	08 95       	ret

000023d4 <waitKey()>:
waitKey():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2824
// ------------------------------------------------------------------------------

void waitKey()
// Wait a key to continue
{
  while (Serial.available() > 0) Serial.read();   // Flush serial Rx buffer
    23d4:	86 ea       	ldi	r24, 0xA6	; 166
    23d6:	92 e0       	ldi	r25, 0x02	; 2
    23d8:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
    23dc:	18 16       	cp	r1, r24
    23de:	19 06       	cpc	r1, r25
    23e0:	2c f4       	brge	.+10     	; 0x23ec <waitKey()+0x18>
    23e2:	86 ea       	ldi	r24, 0xA6	; 166
    23e4:	92 e0       	ldi	r25, 0x02	; 2
    23e6:	0e 94 1d 05 	call	0xa3a	; 0xa3a <HardwareSerial::read()>
    23ea:	f4 cf       	rjmp	.-24     	; 0x23d4 <waitKey()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2825
  Serial.println(F("IOS: Check SD and press a key to repeat\r\n"));
    23ec:	8e eb       	ldi	r24, 0xBE	; 190
    23ee:	92 e0       	ldi	r25, 0x02	; 2
    23f0:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2826
  while (Serial.available() < 1);
    23f4:	86 ea       	ldi	r24, 0xA6	; 166
    23f6:	92 e0       	ldi	r25, 0x02	; 2
    23f8:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
    23fc:	18 16       	cp	r1, r24
    23fe:	19 06       	cpc	r1, r25
    2400:	cc f7       	brge	.-14     	; 0x23f4 <waitKey()+0x20>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2827
}
    2402:	08 95       	ret

00002404 <Print::println(char const*) [clone .constprop.48]>:
println():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:138
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[])
    2404:	cf 93       	push	r28
    2406:	df 93       	push	r29
write():
    2408:	bc 01       	movw	r22, r24
    240a:	86 ea       	ldi	r24, 0xA6	; 166
    240c:	92 e0       	ldi	r25, 0x02	; 2
    240e:	0e 94 53 11 	call	0x22a6	; 0x22a6 <Print::write(char const*) [clone .part.2]>
    2412:	ec 01       	movw	r28, r24
println():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:141
{
  size_t n = print(c);
  n += println();
    2414:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:143
  return n;
}
    2418:	8c 0f       	add	r24, r28
    241a:	9d 1f       	adc	r25, r29
    241c:	df 91       	pop	r29
    241e:	cf 91       	pop	r28
    2420:	08 95       	ret

00002422 <Print::print(char const*)>:
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.h:53
    2422:	61 15       	cp	r22, r1
    2424:	71 05       	cpc	r23, r1
    2426:	11 f0       	breq	.+4      	; 0x242c <Print::print(char const*)+0xa>
    2428:	0c 94 53 11 	jmp	0x22a6	; 0x22a6 <Print::write(char const*) [clone .part.2]>
print():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:65
}

size_t Print::print(const char str[])
{
  return write(str);
}
    242c:	90 e0       	ldi	r25, 0x00	; 0
    242e:	80 e0       	ldi	r24, 0x00	; 0
    2430:	08 95       	ret

00002432 <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]>:
_Z10printErrSDhhPKc.part.3():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2731
  return pf_lseek(((unsigned long) sectNum) << 9);
}

// ------------------------------------------------------------------------------

void printErrSD(byte opType, byte errCode, const char* fileName)
    2432:	0f 93       	push	r16
    2434:	1f 93       	push	r17
    2436:	cf 93       	push	r28
    2438:	df 93       	push	r29
    243a:	d8 2f       	mov	r29, r24
    243c:	c6 2f       	mov	r28, r22
    243e:	8a 01       	movw	r16, r20
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2784
//
// ........................................................................
{
  if (errCode)
  {
    Serial.print(F("\r\nIOS: SD error "));
    2440:	8a e5       	ldi	r24, 0x5A	; 90
    2442:	93 e0       	ldi	r25, 0x03	; 3
    2444:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
print():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:74
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
    2448:	6c 2f       	mov	r22, r28
    244a:	70 e0       	ldi	r23, 0x00	; 0
    244c:	90 e0       	ldi	r25, 0x00	; 0
    244e:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    2450:	4a e0       	ldi	r20, 0x0A	; 10
    2452:	0e 94 62 11 	call	0x22c4	; 0x22c4 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]>
_Z10printErrSDhhPKc.part.3():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2786
    Serial.print(errCode);
    Serial.print(" (");
    2456:	69 ed       	ldi	r22, 0xD9	; 217
    2458:	70 e0       	ldi	r23, 0x00	; 0
    245a:	86 ea       	ldi	r24, 0xA6	; 166
    245c:	92 e0       	ldi	r25, 0x02	; 2
    245e:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2792
    switch (errCode)
      // See PetitFS implementation for the codes
    {
      case 1: Serial.print(F("DISK_ERR")); break;
      case 2: Serial.print(F("NOT_READY")); break;
      case 3: Serial.print(F("NO_FILE")); break;
    2462:	8f e3       	ldi	r24, 0x3F	; 63
    2464:	93 e0       	ldi	r25, 0x03	; 3
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2787
  if (errCode)
  {
    Serial.print(F("\r\nIOS: SD error "));
    Serial.print(errCode);
    Serial.print(" (");
    switch (errCode)
    2466:	c3 30       	cpi	r28, 0x03	; 3
    2468:	c1 f0       	breq	.+48     	; 0x249a <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]+0x68>
    246a:	58 f4       	brcc	.+22     	; 0x2482 <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]+0x50>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2790
      // See PetitFS implementation for the codes
    {
      case 1: Serial.print(F("DISK_ERR")); break;
    246c:	81 e5       	ldi	r24, 0x51	; 81
    246e:	93 e0       	ldi	r25, 0x03	; 3
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2787
  if (errCode)
  {
    Serial.print(F("\r\nIOS: SD error "));
    Serial.print(errCode);
    Serial.print(" (");
    switch (errCode)
    2470:	c1 30       	cpi	r28, 0x01	; 1
    2472:	99 f0       	breq	.+38     	; 0x249a <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]+0x68>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2791
      // See PetitFS implementation for the codes
    {
      case 1: Serial.print(F("DISK_ERR")); break;
      case 2: Serial.print(F("NOT_READY")); break;
    2474:	87 e4       	ldi	r24, 0x47	; 71
    2476:	93 e0       	ldi	r25, 0x03	; 3
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2787
  if (errCode)
  {
    Serial.print(F("\r\nIOS: SD error "));
    Serial.print(errCode);
    Serial.print(" (");
    switch (errCode)
    2478:	c2 30       	cpi	r28, 0x02	; 2
    247a:	79 f0       	breq	.+30     	; 0x249a <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]+0x68>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2796
      case 2: Serial.print(F("NOT_READY")); break;
      case 3: Serial.print(F("NO_FILE")); break;
      case 4: Serial.print(F("NOT_OPENED")); break;
      case 5: Serial.print(F("NOT_ENABLED")); break;
      case 6: Serial.print(F("NO_FILESYSTEM")); break;
      default: Serial.print(F("UNKNOWN"));
    247c:	82 e1       	ldi	r24, 0x12	; 18
    247e:	93 e0       	ldi	r25, 0x03	; 3
    2480:	0c c0       	rjmp	.+24     	; 0x249a <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]+0x68>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2794
    {
      case 1: Serial.print(F("DISK_ERR")); break;
      case 2: Serial.print(F("NOT_READY")); break;
      case 3: Serial.print(F("NO_FILE")); break;
      case 4: Serial.print(F("NOT_OPENED")); break;
      case 5: Serial.print(F("NOT_ENABLED")); break;
    2482:	88 e2       	ldi	r24, 0x28	; 40
    2484:	93 e0       	ldi	r25, 0x03	; 3
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2787
  if (errCode)
  {
    Serial.print(F("\r\nIOS: SD error "));
    Serial.print(errCode);
    Serial.print(" (");
    switch (errCode)
    2486:	c5 30       	cpi	r28, 0x05	; 5
    2488:	41 f0       	breq	.+16     	; 0x249a <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]+0x68>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2793
      // See PetitFS implementation for the codes
    {
      case 1: Serial.print(F("DISK_ERR")); break;
      case 2: Serial.print(F("NOT_READY")); break;
      case 3: Serial.print(F("NO_FILE")); break;
      case 4: Serial.print(F("NOT_OPENED")); break;
    248a:	84 e3       	ldi	r24, 0x34	; 52
    248c:	93 e0       	ldi	r25, 0x03	; 3
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2787
  if (errCode)
  {
    Serial.print(F("\r\nIOS: SD error "));
    Serial.print(errCode);
    Serial.print(" (");
    switch (errCode)
    248e:	c5 30       	cpi	r28, 0x05	; 5
    2490:	20 f0       	brcs	.+8      	; 0x249a <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]+0x68>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2795
      case 1: Serial.print(F("DISK_ERR")); break;
      case 2: Serial.print(F("NOT_READY")); break;
      case 3: Serial.print(F("NO_FILE")); break;
      case 4: Serial.print(F("NOT_OPENED")); break;
      case 5: Serial.print(F("NOT_ENABLED")); break;
      case 6: Serial.print(F("NO_FILESYSTEM")); break;
    2492:	8a e1       	ldi	r24, 0x1A	; 26
    2494:	93 e0       	ldi	r25, 0x03	; 3
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2787
  if (errCode)
  {
    Serial.print(F("\r\nIOS: SD error "));
    Serial.print(errCode);
    Serial.print(" (");
    switch (errCode)
    2496:	c6 30       	cpi	r28, 0x06	; 6
    2498:	89 f7       	brne	.-30     	; 0x247c <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]+0x4a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2796
      case 2: Serial.print(F("NOT_READY")); break;
      case 3: Serial.print(F("NO_FILE")); break;
      case 4: Serial.print(F("NOT_OPENED")); break;
      case 5: Serial.print(F("NOT_ENABLED")); break;
      case 6: Serial.print(F("NO_FILESYSTEM")); break;
      default: Serial.print(F("UNKNOWN"));
    249a:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2798
    }
    Serial.print(F(" on "));
    249e:	8d e0       	ldi	r24, 0x0D	; 13
    24a0:	93 e0       	ldi	r25, 0x03	; 3
    24a2:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2802
    switch (opType)
    {
      case 0: Serial.print(F("MOUNT")); break;
      case 1: Serial.print(F("OPEN")); break;
    24a6:	82 e0       	ldi	r24, 0x02	; 2
    24a8:	93 e0       	ldi	r25, 0x03	; 3
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2799
      case 5: Serial.print(F("NOT_ENABLED")); break;
      case 6: Serial.print(F("NO_FILESYSTEM")); break;
      default: Serial.print(F("UNKNOWN"));
    }
    Serial.print(F(" on "));
    switch (opType)
    24aa:	d1 30       	cpi	r29, 0x01	; 1
    24ac:	31 f0       	breq	.+12     	; 0x24ba <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]+0x88>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2801
    {
      case 0: Serial.print(F("MOUNT")); break;
    24ae:	87 e0       	ldi	r24, 0x07	; 7
    24b0:	93 e0       	ldi	r25, 0x03	; 3
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2799
      case 5: Serial.print(F("NOT_ENABLED")); break;
      case 6: Serial.print(F("NO_FILESYSTEM")); break;
      default: Serial.print(F("UNKNOWN"));
    }
    Serial.print(F(" on "));
    switch (opType)
    24b2:	d2 30       	cpi	r29, 0x02	; 2
    24b4:	11 f4       	brne	.+4      	; 0x24ba <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]+0x88>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2803
    {
      case 0: Serial.print(F("MOUNT")); break;
      case 1: Serial.print(F("OPEN")); break;
      case 2: Serial.print(F("READ")); break;
    24b6:	8d ef       	ldi	r24, 0xFD	; 253
    24b8:	92 e0       	ldi	r25, 0x02	; 2
    24ba:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2808
      case 3: Serial.print(F("WRITE")); break;
      case 4: Serial.print(F("SEEK")); break;
      default: Serial.print(F("UNKNOWN"));
    }
    Serial.print(F(" operation"));
    24be:	82 ef       	ldi	r24, 0xF2	; 242
    24c0:	92 e0       	ldi	r25, 0x02	; 2
    24c2:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2809
    if (fileName)
    24c6:	01 15       	cp	r16, r1
    24c8:	11 05       	cpc	r17, r1
    24ca:	49 f0       	breq	.+18     	; 0x24de <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]+0xac>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2812
      // Not a NULL pointer, so print file name too
    {
      Serial.print(F(" - File: "));
    24cc:	88 ee       	ldi	r24, 0xE8	; 232
    24ce:	92 e0       	ldi	r25, 0x02	; 2
    24d0:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2813
      Serial.print(fileName);
    24d4:	b8 01       	movw	r22, r16
    24d6:	86 ea       	ldi	r24, 0xA6	; 166
    24d8:	92 e0       	ldi	r25, 0x02	; 2
    24da:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2815
    }
    Serial.println(")");
    24de:	8c ed       	ldi	r24, 0xDC	; 220
    24e0:	90 e0       	ldi	r25, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2817
  }
}
    24e2:	df 91       	pop	r29
    24e4:	cf 91       	pop	r28
    24e6:	1f 91       	pop	r17
    24e8:	0f 91       	pop	r16
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2815
      // Not a NULL pointer, so print file name too
    {
      Serial.print(F(" - File: "));
      Serial.print(fileName);
    }
    Serial.println(")");
    24ea:	0c 94 02 12 	jmp	0x2404	; 0x2404 <Print::println(char const*) [clone .constprop.48]>

000024ee <printOsName(unsigned char)>:
printOsName():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2834
// ------------------------------------------------------------------------------

void printOsName(byte currentDiskSet)
// Print the current Disk Set number and the OS name, if it is defined.
// The OS name is inside the file defined in DS_OSNAME
{
    24ee:	1f 93       	push	r17
    24f0:	cf 93       	push	r28
    24f2:	df 93       	push	r29
    24f4:	00 d0       	rcall	.+0      	; 0x24f6 <printOsName(unsigned char)+0x8>
    24f6:	cd b7       	in	r28, 0x3d	; 61
    24f8:	de b7       	in	r29, 0x3e	; 62
    24fa:	18 2f       	mov	r17, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2835
  Serial.print("Disk Set ");
    24fc:	6e ed       	ldi	r22, 0xDE	; 222
    24fe:	70 e0       	ldi	r23, 0x00	; 0
    2500:	86 ea       	ldi	r24, 0xA6	; 166
    2502:	92 e0       	ldi	r25, 0x02	; 2
    2504:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
print():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:74
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
    2508:	61 2f       	mov	r22, r17
    250a:	70 e0       	ldi	r23, 0x00	; 0
    250c:	90 e0       	ldi	r25, 0x00	; 0
    250e:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    2510:	4a e0       	ldi	r20, 0x0A	; 10
    2512:	0e 94 62 11 	call	0x22c4	; 0x22c4 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]>
printOsName():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2837
  Serial.print(currentDiskSet);
  OsName[2] = currentDiskSet + 48;    // Set the Disk Set
    2516:	10 5d       	subi	r17, 0xD0	; 208
    2518:	10 93 62 00 	sts	0x0062, r17	; 0x800062 <__data_start+0x2>
openSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2658
byte openSD(const char* fileName)
// Open an existing file on SD:
// *  "fileName" is the pointer to the string holding the file name (8.3 format)
// The returned value is the resulting status (0 = ok, otherwise see printErrSD())
{
  return pf_open(fileName);
    251c:	80 e6       	ldi	r24, 0x60	; 96
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <pf_open>
readSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2678
// NOTE2: Past current sector boundary, the next sector will be pointed. So to read a whole file it is sufficient
//        call readSD() consecutively until EOF is reached
{
  UINT  numBytes;
  byte  errcode;
  errcode = pf_read(buffSD, 32, &numBytes);
    2524:	ce 01       	movw	r24, r28
    2526:	01 96       	adiw	r24, 0x01	; 1
    2528:	0e 94 9c 0c 	call	0x1938	; 0x1938 <pf_read.constprop.36>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2679
  *numReadBytes = (byte) numBytes;
    252c:	89 81       	ldd	r24, Y+1	; 0x01
    252e:	80 93 d5 01 	sts	0x01D5, r24	; 0x8001d5 <numReadBytes>
printOsName():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2840
  Serial.print("Disk Set ");
  Serial.print(currentDiskSet);
  OsName[2] = currentDiskSet + 48;    // Set the Disk Set
  openSD(OsName);                     // Open file with the OS name
  readSD(bufferSD, &numReadBytes);    // Read the OS name
  if (numReadBytes > 0)
    2532:	88 23       	and	r24, r24
    2534:	91 f0       	breq	.+36     	; 0x255a <printOsName(unsigned char)+0x6c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2843
    // Print the OS name
  {
    Serial.print(" (");
    2536:	69 ed       	ldi	r22, 0xD9	; 217
    2538:	70 e0       	ldi	r23, 0x00	; 0
    253a:	86 ea       	ldi	r24, 0xA6	; 166
    253c:	92 e0       	ldi	r25, 0x02	; 2
    253e:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2844
    Serial.print((const char *)bufferSD);
    2542:	69 e5       	ldi	r22, 0x59	; 89
    2544:	72 e0       	ldi	r23, 0x02	; 2
    2546:	86 ea       	ldi	r24, 0xA6	; 166
    2548:	92 e0       	ldi	r25, 0x02	; 2
    254a:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2845
    Serial.print(")");
    254e:	6c ed       	ldi	r22, 0xDC	; 220
    2550:	70 e0       	ldi	r23, 0x00	; 0
    2552:	86 ea       	ldi	r24, 0xA6	; 166
    2554:	92 e0       	ldi	r25, 0x02	; 2
    2556:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2847
  }
}
    255a:	0f 90       	pop	r0
    255c:	0f 90       	pop	r0
    255e:	df 91       	pop	r29
    2560:	cf 91       	pop	r28
    2562:	1f 91       	pop	r17
    2564:	08 95       	ret

00002566 <print2digit(unsigned char)>:
print2digit():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2362

// ------------------------------------------------------------------------------

void print2digit(byte data)
// Print a byte [0..99] using 2 digit with leading zeros if needed
{
    2566:	cf 93       	push	r28
    2568:	c8 2f       	mov	r28, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2363
  if (data < 10) Serial.print("0");
    256a:	8a 30       	cpi	r24, 0x0A	; 10
    256c:	30 f4       	brcc	.+12     	; 0x257a <print2digit(unsigned char)+0x14>
    256e:	68 ee       	ldi	r22, 0xE8	; 232
    2570:	70 e0       	ldi	r23, 0x00	; 0
    2572:	86 ea       	ldi	r24, 0xA6	; 166
    2574:	92 e0       	ldi	r25, 0x02	; 2
    2576:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
print():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:74
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
    257a:	6c 2f       	mov	r22, r28
    257c:	70 e0       	ldi	r23, 0x00	; 0
    257e:	90 e0       	ldi	r25, 0x00	; 0
    2580:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    2582:	4a e0       	ldi	r20, 0x0A	; 10
print2digit():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2365
  Serial.print(data);
}
    2584:	cf 91       	pop	r28
print():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:106
    2586:	0c 94 62 11 	jmp	0x22c4	; 0x22c4 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]>

0000258a <printDateTime(unsigned char)>:
printDateTime():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2344
//
// Flag readSourceFlag [0..1] usage:
//    If readSourceFlag = 0 the RTC read is not done
//    If readSourceFlag = 1 the RTC read is done (global variables are updated)
{
  if (readSourceFlag) readRTC(&seconds, &minutes, &hours, &day,  &month,  &year, &tempC);
    258a:	81 11       	cpse	r24, r1
    258c:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <readRTC(unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*) [clone .constprop.20]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2345
  print2digit(day);
    2590:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <day>
    2594:	0e 94 b3 12 	call	0x2566	; 0x2566 <print2digit(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2346
  Serial.print("/");
    2598:	6a ee       	ldi	r22, 0xEA	; 234
    259a:	70 e0       	ldi	r23, 0x00	; 0
    259c:	86 ea       	ldi	r24, 0xA6	; 166
    259e:	92 e0       	ldi	r25, 0x02	; 2
    25a0:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2347
  print2digit(month);
    25a4:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <month>
    25a8:	0e 94 b3 12 	call	0x2566	; 0x2566 <print2digit(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2348
  Serial.print("/");
    25ac:	6a ee       	ldi	r22, 0xEA	; 234
    25ae:	70 e0       	ldi	r23, 0x00	; 0
    25b0:	86 ea       	ldi	r24, 0xA6	; 166
    25b2:	92 e0       	ldi	r25, 0x02	; 2
    25b4:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2349
  print2digit(year);
    25b8:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <year>
    25bc:	0e 94 b3 12 	call	0x2566	; 0x2566 <print2digit(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2350
  Serial.print(" ");
    25c0:	66 ee       	ldi	r22, 0xE6	; 230
    25c2:	70 e0       	ldi	r23, 0x00	; 0
    25c4:	86 ea       	ldi	r24, 0xA6	; 166
    25c6:	92 e0       	ldi	r25, 0x02	; 2
    25c8:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2351
  print2digit(hours);
    25cc:	80 91 25 02 	lds	r24, 0x0225	; 0x800225 <hours>
    25d0:	0e 94 b3 12 	call	0x2566	; 0x2566 <print2digit(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2352
  Serial.print(":");
    25d4:	6c ee       	ldi	r22, 0xEC	; 236
    25d6:	70 e0       	ldi	r23, 0x00	; 0
    25d8:	86 ea       	ldi	r24, 0xA6	; 166
    25da:	92 e0       	ldi	r25, 0x02	; 2
    25dc:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2353
  print2digit(minutes);
    25e0:	80 91 26 02 	lds	r24, 0x0226	; 0x800226 <minutes>
    25e4:	0e 94 b3 12 	call	0x2566	; 0x2566 <print2digit(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2354
  Serial.print(":");
    25e8:	6c ee       	ldi	r22, 0xEC	; 236
    25ea:	70 e0       	ldi	r23, 0x00	; 0
    25ec:	86 ea       	ldi	r24, 0xA6	; 166
    25ee:	92 e0       	ldi	r25, 0x02	; 2
    25f0:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2355
  print2digit(seconds);
    25f4:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <seconds>
    25f8:	0c 94 b3 12 	jmp	0x2566	; 0x2566 <print2digit(unsigned char)>

000025fc <String::toInt() const>:
toInt():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:738
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const
{
  if (buffer) return atol(buffer);
    25fc:	fc 01       	movw	r30, r24
    25fe:	80 81       	ld	r24, Z
    2600:	91 81       	ldd	r25, Z+1	; 0x01
    2602:	00 97       	sbiw	r24, 0x00	; 0
    2604:	11 f0       	breq	.+4      	; 0x260a <String::toInt() const+0xe>
    2606:	0c 94 cc 24 	jmp	0x4998	; 0x4998 <atol>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:740
  return 0;
}
    260a:	60 e0       	ldi	r22, 0x00	; 0
    260c:	70 e0       	ldi	r23, 0x00	; 0
    260e:	cb 01       	movw	r24, r22
    2610:	08 95       	ret

00002612 <String::~String()>:
__base_dtor ():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:124
  *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
}

String::~String()
{
  if(buffer)
    2612:	fc 01       	movw	r30, r24
    2614:	80 81       	ld	r24, Z
    2616:	91 81       	ldd	r25, Z+1	; 0x01
    2618:	00 97       	sbiw	r24, 0x00	; 0
    261a:	11 f0       	breq	.+4      	; 0x2620 <String::~String()+0xe>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:125
    free(buffer);
    261c:	0c 94 3e 26 	jmp	0x4c7c	; 0x4c7c <free>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:126
}
    2620:	08 95       	ret

00002622 <String::copy(char const*, unsigned int)>:
copy():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:172
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    2622:	ef 92       	push	r14
    2624:	ff 92       	push	r15
    2626:	0f 93       	push	r16
    2628:	1f 93       	push	r17
    262a:	cf 93       	push	r28
    262c:	df 93       	push	r29
    262e:	ec 01       	movw	r28, r24
    2630:	7b 01       	movw	r14, r22
    2632:	8a 01       	movw	r16, r20
reserve():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:148
  capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
  if (buffer && capacity >= size) return 1;
    2634:	88 81       	ld	r24, Y
    2636:	99 81       	ldd	r25, Y+1	; 0x01
    2638:	00 97       	sbiw	r24, 0x00	; 0
    263a:	29 f0       	breq	.+10     	; 0x2646 <String::copy(char const*, unsigned int)+0x24>
    263c:	2a 81       	ldd	r18, Y+2	; 0x02
    263e:	3b 81       	ldd	r19, Y+3	; 0x03
    2640:	24 17       	cp	r18, r20
    2642:	35 07       	cpc	r19, r21
    2644:	88 f4       	brcc	.+34     	; 0x2668 <String::copy(char const*, unsigned int)+0x46>
changeBuffer():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:158
  return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
  char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    2646:	b8 01       	movw	r22, r16
    2648:	6f 5f       	subi	r22, 0xFF	; 255
    264a:	7f 4f       	sbci	r23, 0xFF	; 255
    264c:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <realloc>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:159
  if (newbuffer) {
    2650:	00 97       	sbiw	r24, 0x00	; 0
    2652:	91 f0       	breq	.+36     	; 0x2678 <String::copy(char const*, unsigned int)+0x56>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:160
    buffer = newbuffer;
    2654:	99 83       	std	Y+1, r25	; 0x01
    2656:	88 83       	st	Y, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:161
    capacity = maxStrLen;
    2658:	1b 83       	std	Y+3, r17	; 0x03
    265a:	0a 83       	std	Y+2, r16	; 0x02
reserve():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:150

unsigned char String::reserve(unsigned int size)
{
  if (buffer && capacity >= size) return 1;
  if (changeBuffer(size)) {
    if (len == 0) buffer[0] = 0;
    265c:	2c 81       	ldd	r18, Y+4	; 0x04
    265e:	3d 81       	ldd	r19, Y+5	; 0x05
    2660:	23 2b       	or	r18, r19
    2662:	11 f4       	brne	.+4      	; 0x2668 <String::copy(char const*, unsigned int)+0x46>
    2664:	fc 01       	movw	r30, r24
    2666:	10 82       	st	Z, r1
copy():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:177
{
  if (!reserve(length)) {
    invalidate();
    return *this;
  }
  len = length;
    2668:	1d 83       	std	Y+5, r17	; 0x05
    266a:	0c 83       	std	Y+4, r16	; 0x04
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:178
  strcpy(buffer, cstr);
    266c:	b7 01       	movw	r22, r14
    266e:	88 81       	ld	r24, Y
    2670:	99 81       	ldd	r25, Y+1	; 0x01
    2672:	0e 94 8d 27 	call	0x4f1a	; 0x4f1a <strcpy>
    2676:	0c c0       	rjmp	.+24     	; 0x2690 <String::copy(char const*, unsigned int)+0x6e>
invalidate():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:141
  len = 0;
}

void String::invalidate(void)
{
  if (buffer) free(buffer);
    2678:	88 81       	ld	r24, Y
    267a:	99 81       	ldd	r25, Y+1	; 0x01
    267c:	00 97       	sbiw	r24, 0x00	; 0
    267e:	11 f0       	breq	.+4      	; 0x2684 <String::copy(char const*, unsigned int)+0x62>
    2680:	0e 94 3e 26 	call	0x4c7c	; 0x4c7c <free>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:142
  buffer = NULL;
    2684:	19 82       	std	Y+1, r1	; 0x01
    2686:	18 82       	st	Y, r1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:143
  capacity = len = 0;
    2688:	1d 82       	std	Y+5, r1	; 0x05
    268a:	1c 82       	std	Y+4, r1	; 0x04
    268c:	1b 82       	std	Y+3, r1	; 0x03
    268e:	1a 82       	std	Y+2, r1	; 0x02
copy():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:180
    return *this;
  }
  len = length;
  strcpy(buffer, cstr);
  return *this;
}
    2690:	ce 01       	movw	r24, r28
    2692:	df 91       	pop	r29
    2694:	cf 91       	pop	r28
    2696:	1f 91       	pop	r17
    2698:	0f 91       	pop	r16
    269a:	ff 90       	pop	r15
    269c:	ef 90       	pop	r14
    269e:	08 95       	ret

000026a0 <String::substring(unsigned int, unsigned int) const>:
substring():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:616
  }
  return found;
}

String String::substring(unsigned int left, unsigned int right) const
{
    26a0:	af 92       	push	r10
    26a2:	bf 92       	push	r11
    26a4:	cf 92       	push	r12
    26a6:	df 92       	push	r13
    26a8:	ef 92       	push	r14
    26aa:	ff 92       	push	r15
    26ac:	0f 93       	push	r16
    26ae:	1f 93       	push	r17
    26b0:	cf 93       	push	r28
    26b2:	df 93       	push	r29
    26b4:	ec 01       	movw	r28, r24
    26b6:	6b 01       	movw	r12, r22
    26b8:	5a 01       	movw	r10, r20
    26ba:	79 01       	movw	r14, r18
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:617
  if (left > right) {
    26bc:	24 17       	cp	r18, r20
    26be:	35 07       	cpc	r19, r21
    26c0:	20 f4       	brcc	.+8      	; 0x26ca <String::substring(unsigned int, unsigned int) const+0x2a>
    26c2:	8b 2d       	mov	r24, r11
    26c4:	59 01       	movw	r10, r18
    26c6:	e4 2e       	mov	r14, r20
    26c8:	f8 2e       	mov	r15, r24
_ZN6String4initEv():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:134
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
  buffer = NULL;
    26ca:	19 82       	std	Y+1, r1	; 0x01
    26cc:	18 82       	st	Y, r1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:135
  capacity = 0;
    26ce:	1b 82       	std	Y+3, r1	; 0x03
    26d0:	1a 82       	std	Y+2, r1	; 0x02
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:136
  len = 0;
    26d2:	1d 82       	std	Y+5, r1	; 0x05
    26d4:	1c 82       	std	Y+4, r1	; 0x04
__base_ctor ():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:31
/*********************************************/

String::String(const char *cstr)
{
  init();
  if (cstr) copy(cstr, strlen(cstr));
    26d6:	50 e0       	ldi	r21, 0x00	; 0
    26d8:	40 e0       	ldi	r20, 0x00	; 0
    26da:	68 ed       	ldi	r22, 0xD8	; 216
    26dc:	70 e0       	ldi	r23, 0x00	; 0
    26de:	ce 01       	movw	r24, r28
    26e0:	0e 94 11 13 	call	0x2622	; 0x2622 <String::copy(char const*, unsigned int)>
substring():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:623
    unsigned int temp = right;
    right = left;
    left = temp;
  }
  String out;
  if (left >= len) return out;
    26e4:	d6 01       	movw	r26, r12
    26e6:	14 96       	adiw	r26, 0x04	; 4
    26e8:	0d 91       	ld	r16, X+
    26ea:	1c 91       	ld	r17, X
    26ec:	a0 16       	cp	r10, r16
    26ee:	b1 06       	cpc	r11, r17
    26f0:	28 f5       	brcc	.+74     	; 0x273c <String::substring(unsigned int, unsigned int) const+0x9c>
    26f2:	e0 16       	cp	r14, r16
    26f4:	f1 06       	cpc	r15, r17
    26f6:	08 f4       	brcc	.+2      	; 0x26fa <String::substring(unsigned int, unsigned int) const+0x5a>
    26f8:	87 01       	movw	r16, r14
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:625
  if (right > len) right = len;
  char temp = buffer[right];  // save the replaced character
    26fa:	d6 01       	movw	r26, r12
    26fc:	ed 91       	ld	r30, X+
    26fe:	fc 91       	ld	r31, X
    2700:	11 97       	sbiw	r26, 0x01	; 1
    2702:	e0 0f       	add	r30, r16
    2704:	f1 1f       	adc	r31, r17
    2706:	f0 80       	ld	r15, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:626
  buffer[right] = '\0'; 
    2708:	10 82       	st	Z, r1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:627
  out = buffer + left;  // pointer arithmetic
    270a:	6d 91       	ld	r22, X+
    270c:	7c 91       	ld	r23, X
    270e:	6a 0d       	add	r22, r10
    2710:	7b 1d       	adc	r23, r11
operator=():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:241
}
#endif

String & String::operator = (const char *cstr)
{
  if (cstr) copy(cstr, strlen(cstr));
    2712:	61 15       	cp	r22, r1
    2714:	71 05       	cpc	r23, r1
    2716:	f1 f0       	breq	.+60     	; 0x2754 <String::substring(unsigned int, unsigned int) const+0xb4>
    2718:	fb 01       	movw	r30, r22
    271a:	01 90       	ld	r0, Z+
    271c:	00 20       	and	r0, r0
    271e:	e9 f7       	brne	.-6      	; 0x271a <String::substring(unsigned int, unsigned int) const+0x7a>
    2720:	31 97       	sbiw	r30, 0x01	; 1
    2722:	af 01       	movw	r20, r30
    2724:	46 1b       	sub	r20, r22
    2726:	57 0b       	sbc	r21, r23
    2728:	ce 01       	movw	r24, r28
    272a:	0e 94 11 13 	call	0x2622	; 0x2622 <String::copy(char const*, unsigned int)>
substring():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:628
  if (left >= len) return out;
  if (right > len) right = len;
  char temp = buffer[right];  // save the replaced character
  buffer[right] = '\0'; 
  out = buffer + left;  // pointer arithmetic
  buffer[right] = temp;  //restore character
    272e:	f6 01       	movw	r30, r12
    2730:	80 81       	ld	r24, Z
    2732:	91 81       	ldd	r25, Z+1	; 0x01
    2734:	08 0f       	add	r16, r24
    2736:	19 1f       	adc	r17, r25
    2738:	d8 01       	movw	r26, r16
    273a:	fc 92       	st	X, r15
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:630
  return out;
}
    273c:	ce 01       	movw	r24, r28
    273e:	df 91       	pop	r29
    2740:	cf 91       	pop	r28
    2742:	1f 91       	pop	r17
    2744:	0f 91       	pop	r16
    2746:	ff 90       	pop	r15
    2748:	ef 90       	pop	r14
    274a:	df 90       	pop	r13
    274c:	cf 90       	pop	r12
    274e:	bf 90       	pop	r11
    2750:	af 90       	pop	r10
    2752:	08 95       	ret
invalidate():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:141
  len = 0;
}

void String::invalidate(void)
{
  if (buffer) free(buffer);
    2754:	88 81       	ld	r24, Y
    2756:	99 81       	ldd	r25, Y+1	; 0x01
    2758:	00 97       	sbiw	r24, 0x00	; 0
    275a:	11 f0       	breq	.+4      	; 0x2760 <String::substring(unsigned int, unsigned int) const+0xc0>
    275c:	0e 94 3e 26 	call	0x4c7c	; 0x4c7c <free>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:142
  buffer = NULL;
    2760:	19 82       	std	Y+1, r1	; 0x01
    2762:	18 82       	st	Y, r1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/WString.cpp:143
  capacity = len = 0;
    2764:	1d 82       	std	Y+5, r1	; 0x05
    2766:	1c 82       	std	Y+4, r1	; 0x04
    2768:	1b 82       	std	Y+3, r1	; 0x03
    276a:	1a 82       	std	Y+2, r1	; 0x02
    276c:	e0 cf       	rjmp	.-64     	; 0x272e <String::substring(unsigned int, unsigned int) const+0x8e>

0000276e <EEPROMClass::update(int, unsigned char) [clone .isra.2]>:
_ZN11EEPROMClass6updateEih.isra.2():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\EEPROM\src/EEPROM.h:122

    //Basic user access methods.
    EERef operator[]( const int idx )    { return idx; }
    uint8_t read( int idx )              { return EERef( idx ); }
    void write( int idx, uint8_t val )   { (EERef( idx )) = val; }
    void update( int idx, uint8_t val )  { EERef( idx ).update( val ); }
    276e:	1f 93       	push	r17
    2770:	cf 93       	push	r28
    2772:	df 93       	push	r29
    2774:	ec 01       	movw	r28, r24
    2776:	16 2f       	mov	r17, r22
operator*():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\EEPROM\src/EEPROM.h:42

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    2778:	0e 94 08 25 	call	0x4a10	; 0x4a10 <eeprom_read_byte>
update():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\EEPROM\src/EEPROM.h:59
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }
    
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    277c:	18 17       	cp	r17, r24
    277e:	39 f0       	breq	.+14     	; 0x278e <EEPROMClass::update(int, unsigned char) [clone .isra.2]+0x20>
_ZN5EERefaSEh():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\EEPROM\src/EEPROM.h:47
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator uint8_t() const             { return **this; }
    
    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    2780:	61 2f       	mov	r22, r17
    2782:	ce 01       	movw	r24, r28
_ZN11EEPROMClass6updateEih.isra.2():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\EEPROM\src/EEPROM.h:122

    //Basic user access methods.
    EERef operator[]( const int idx )    { return idx; }
    uint8_t read( int idx )              { return EERef( idx ); }
    void write( int idx, uint8_t val )   { (EERef( idx )) = val; }
    void update( int idx, uint8_t val )  { EERef( idx ).update( val ); }
    2784:	df 91       	pop	r29
    2786:	cf 91       	pop	r28
    2788:	1f 91       	pop	r17
_ZN5EERefaSEh():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\EEPROM\src/EEPROM.h:47
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator uint8_t() const             { return **this; }
    
    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    278a:	0c 94 10 25 	jmp	0x4a20	; 0x4a20 <eeprom_write_byte>
_ZN11EEPROMClass6updateEih.isra.2():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\EEPROM\src/EEPROM.h:122

    //Basic user access methods.
    EERef operator[]( const int idx )    { return idx; }
    uint8_t read( int idx )              { return EERef( idx ); }
    void write( int idx, uint8_t val )   { (EERef( idx )) = val; }
    void update( int idx, uint8_t val )  { EERef( idx ).update( val ); }
    278e:	df 91       	pop	r29
    2790:	cf 91       	pop	r28
    2792:	1f 91       	pop	r17
    2794:	08 95       	ret

00002796 <EEPROMClass::read(int) [clone .isra.1]>:
operator*():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\EEPROM\src/EEPROM.h:42

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    2796:	0c 94 08 25 	jmp	0x4a10	; 0x4a10 <eeprom_read_byte>

0000279a <WaitAndBlink(baudRecCheck) [clone .constprop.33]>:
WaitAndBlink():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2120
  }
}

// ------------------------------------------------------------------------------

void WaitAndBlink(baudRecCheck baudRecSwitch)
    279a:	cf 92       	push	r12
    279c:	df 92       	push	r13
    279e:	ef 92       	push	r14
    27a0:	ff 92       	push	r15
    27a2:	0f 93       	push	r16
    27a4:	1f 93       	push	r17
    27a6:	cf 93       	push	r28
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2133
{
  byte                  UserKeyLongPressed = 1;   // Flag for the "User key long pressed" event
  static unsigned long  timeStamp1;               // Timestamps
  unsigned long         timeStamp2;

  timeStamp2 = millis();
    27a8:	0e 94 39 07 	call	0xe72	; 0xe72 <millis>
    27ac:	6b 01       	movw	r12, r22
    27ae:	7c 01       	movw	r14, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2129
// In this happens the Baud Recovery procedure is done if the current serial speed is different from the default
// value (115200).
// When the Baud Recovery procedure is executed the serial port speed is set at the default value (115200) and both
// the USER and IOS leds blink quickly. The default serial port speed will be effective after the next reset.
{
  byte                  UserKeyLongPressed = 1;   // Flag for the "User key long pressed" event
    27b0:	c1 e0       	ldi	r28, 0x01	; 1
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2134
  static unsigned long  timeStamp1;               // Timestamps
  unsigned long         timeStamp2;

  timeStamp2 = millis();
  while (!Serial.available())
    27b2:	86 ea       	ldi	r24, 0xA6	; 166
    27b4:	92 e0       	ldi	r25, 0x02	; 2
    27b6:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
    27ba:	89 2b       	or	r24, r25
    27bc:	09 f0       	breq	.+2      	; 0x27c0 <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0x26>
    27be:	9b c0       	rjmp	.+310    	; 0x28f6 <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0x15c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2136
  {
    if ((millis() - timeStamp2) < 3000)
    27c0:	0e 94 39 07 	call	0xe72	; 0xe72 <millis>
    27c4:	6c 19       	sub	r22, r12
    27c6:	7d 09       	sbc	r23, r13
    27c8:	8e 09       	sbc	r24, r14
    27ca:	9f 09       	sbc	r25, r15
    27cc:	68 3b       	cpi	r22, 0xB8	; 184
    27ce:	7b 40       	sbci	r23, 0x0B	; 11
    27d0:	81 05       	cpc	r24, r1
    27d2:	91 05       	cpc	r25, r1
    27d4:	a0 f4       	brcc	.+40     	; 0x27fe <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0x64>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2139
      // Check is User key remains pressed for 3s more
    {
      pinMode(USER, INPUT_PULLUP);                // Set read mode for USER key
    27d6:	62 e0       	ldi	r22, 0x02	; 2
    27d8:	8d e0       	ldi	r24, 0x0D	; 13
    27da:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2140
      if (digitalRead(USER)) UserKeyLongPressed = 0;  // Clear the flag if USER key was released at least once before 3s
    27de:	8d e0       	ldi	r24, 0x0D	; 13
    27e0:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
    27e4:	89 2b       	or	r24, r25
    27e6:	09 f0       	breq	.+2      	; 0x27ea <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0x50>
    27e8:	c0 e0       	ldi	r28, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2141
      pinMode(USER, OUTPUT);                      // Set write mode for USER led
    27ea:	61 e0       	ldi	r22, 0x01	; 1
    27ec:	8d e0       	ldi	r24, 0x0D	; 13
    27ee:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2142
      delay(10);                                  // Just to dimm USER led up to fade off
    27f2:	6a e0       	ldi	r22, 0x0A	; 10
    27f4:	70 e0       	ldi	r23, 0x00	; 0
    27f6:	80 e0       	ldi	r24, 0x00	; 0
    27f8:	90 e0       	ldi	r25, 0x00	; 0
    27fa:	0e 94 07 07 	call	0xe0e	; 0xe0e <delay>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2144
    }
    if ((millis() - timeStamp1) > 300)
    27fe:	0e 94 39 07 	call	0xe72	; 0xe72 <millis>
    2802:	00 91 55 02 	lds	r16, 0x0255	; 0x800255 <WaitAndBlink(baudRecCheck)::timeStamp1>
    2806:	10 91 56 02 	lds	r17, 0x0256	; 0x800256 <WaitAndBlink(baudRecCheck)::timeStamp1+0x1>
    280a:	20 91 57 02 	lds	r18, 0x0257	; 0x800257 <WaitAndBlink(baudRecCheck)::timeStamp1+0x2>
    280e:	30 91 58 02 	lds	r19, 0x0258	; 0x800258 <WaitAndBlink(baudRecCheck)::timeStamp1+0x3>
    2812:	60 1b       	sub	r22, r16
    2814:	71 0b       	sbc	r23, r17
    2816:	82 0b       	sbc	r24, r18
    2818:	93 0b       	sbc	r25, r19
    281a:	6d 32       	cpi	r22, 0x2D	; 45
    281c:	71 40       	sbci	r23, 0x01	; 1
    281e:	81 05       	cpc	r24, r1
    2820:	91 05       	cpc	r25, r1
    2822:	a0 f0       	brcs	.+40     	; 0x284c <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0xb2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2147
      // Blink IOS led
    {
      digitalWrite(LED_IOS, !digitalRead(LED_IOS));
    2824:	80 e0       	ldi	r24, 0x00	; 0
    2826:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
    282a:	61 e0       	ldi	r22, 0x01	; 1
    282c:	89 2b       	or	r24, r25
    282e:	09 f0       	breq	.+2      	; 0x2832 <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0x98>
    2830:	60 e0       	ldi	r22, 0x00	; 0
    2832:	80 e0       	ldi	r24, 0x00	; 0
    2834:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2148
      timeStamp1 = millis();
    2838:	0e 94 39 07 	call	0xe72	; 0xe72 <millis>
    283c:	60 93 55 02 	sts	0x0255, r22	; 0x800255 <WaitAndBlink(baudRecCheck)::timeStamp1>
    2840:	70 93 56 02 	sts	0x0256, r23	; 0x800256 <WaitAndBlink(baudRecCheck)::timeStamp1+0x1>
    2844:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <WaitAndBlink(baudRecCheck)::timeStamp1+0x2>
    2848:	90 93 58 02 	sts	0x0258, r25	; 0x800258 <WaitAndBlink(baudRecCheck)::timeStamp1+0x3>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2150
    }
    if (((millis() - timeStamp2) > 3000) && (UserKeyLongPressed) && (baudRecSwitch = CHECK) && (EEPROM.read(serBaudAddr) != 9))
    284c:	0e 94 39 07 	call	0xe72	; 0xe72 <millis>
    2850:	6c 19       	sub	r22, r12
    2852:	7d 09       	sbc	r23, r13
    2854:	8e 09       	sbc	r24, r14
    2856:	9f 09       	sbc	r25, r15
    2858:	69 3b       	cpi	r22, 0xB9	; 185
    285a:	7b 40       	sbci	r23, 0x0B	; 11
    285c:	81 05       	cpc	r24, r1
    285e:	91 05       	cpc	r25, r1
    2860:	08 f4       	brcc	.+2      	; 0x2864 <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0xca>
    2862:	a7 cf       	rjmp	.-178    	; 0x27b2 <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0x18>
    2864:	cc 23       	and	r28, r28
    2866:	09 f4       	brne	.+2      	; 0x286a <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0xd0>
    2868:	a4 cf       	rjmp	.-184    	; 0x27b2 <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0x18>
    286a:	8f e0       	ldi	r24, 0x0F	; 15
    286c:	90 e0       	ldi	r25, 0x00	; 0
    286e:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
    2872:	89 30       	cpi	r24, 0x09	; 9
    2874:	09 f4       	brne	.+2      	; 0x2878 <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0xde>
    2876:	9d cf       	rjmp	.-198    	; 0x27b2 <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0x18>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2156
      // Do the Baud Recovery procedure.
      // The User key was pressed for at least 3s and the serial port speed is different from default value (115200),
      // so set the default baud rate (115200) for the serial port and wait for a reboot while both IOS and USER leds
      // blink quickly.
    {
      digitalWrite(LED_IOS, LOW);
    2878:	60 e0       	ldi	r22, 0x00	; 0
    287a:	80 e0       	ldi	r24, 0x00	; 0
    287c:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2157
      EEPROM.update(serBaudAddr, 9);              // Set the default baud rate (115200)
    2880:	69 e0       	ldi	r22, 0x09	; 9
    2882:	8f e0       	ldi	r24, 0x0F	; 15
    2884:	90 e0       	ldi	r25, 0x00	; 0
    2886:	0e 94 b7 13 	call	0x276e	; 0x276e <EEPROMClass::update(int, unsigned char) [clone .isra.2]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2158
      Serial.println(F("\r\n\nIOS: Baud recovery done - Please reboot now!"));
    288a:	82 e0       	ldi	r24, 0x02	; 2
    288c:	98 e0       	ldi	r25, 0x08	; 8
    288e:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2161
      while (1)
      {
        if ((millis() - timeStamp1) > 100)
    2892:	0e 94 39 07 	call	0xe72	; 0xe72 <millis>
    2896:	c0 90 55 02 	lds	r12, 0x0255	; 0x800255 <WaitAndBlink(baudRecCheck)::timeStamp1>
    289a:	d0 90 56 02 	lds	r13, 0x0256	; 0x800256 <WaitAndBlink(baudRecCheck)::timeStamp1+0x1>
    289e:	e0 90 57 02 	lds	r14, 0x0257	; 0x800257 <WaitAndBlink(baudRecCheck)::timeStamp1+0x2>
    28a2:	f0 90 58 02 	lds	r15, 0x0258	; 0x800258 <WaitAndBlink(baudRecCheck)::timeStamp1+0x3>
    28a6:	6c 19       	sub	r22, r12
    28a8:	7d 09       	sbc	r23, r13
    28aa:	8e 09       	sbc	r24, r14
    28ac:	9f 09       	sbc	r25, r15
    28ae:	65 36       	cpi	r22, 0x65	; 101
    28b0:	71 05       	cpc	r23, r1
    28b2:	81 05       	cpc	r24, r1
    28b4:	91 05       	cpc	r25, r1
    28b6:	68 f3       	brcs	.-38     	; 0x2892 <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0xf8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2163
        {
          digitalWrite(LED_IOS, !digitalRead(LED_IOS));
    28b8:	80 e0       	ldi	r24, 0x00	; 0
    28ba:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
    28be:	61 e0       	ldi	r22, 0x01	; 1
    28c0:	89 2b       	or	r24, r25
    28c2:	09 f0       	breq	.+2      	; 0x28c6 <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0x12c>
    28c4:	60 e0       	ldi	r22, 0x00	; 0
    28c6:	80 e0       	ldi	r24, 0x00	; 0
    28c8:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2164
          digitalWrite(USER, !digitalRead(USER));
    28cc:	8d e0       	ldi	r24, 0x0D	; 13
    28ce:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
    28d2:	61 e0       	ldi	r22, 0x01	; 1
    28d4:	89 2b       	or	r24, r25
    28d6:	09 f0       	breq	.+2      	; 0x28da <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0x140>
    28d8:	60 e0       	ldi	r22, 0x00	; 0
    28da:	8d e0       	ldi	r24, 0x0D	; 13
    28dc:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2165
          timeStamp1 = millis();
    28e0:	0e 94 39 07 	call	0xe72	; 0xe72 <millis>
    28e4:	60 93 55 02 	sts	0x0255, r22	; 0x800255 <WaitAndBlink(baudRecCheck)::timeStamp1>
    28e8:	70 93 56 02 	sts	0x0256, r23	; 0x800256 <WaitAndBlink(baudRecCheck)::timeStamp1+0x1>
    28ec:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <WaitAndBlink(baudRecCheck)::timeStamp1+0x2>
    28f0:	90 93 58 02 	sts	0x0258, r25	; 0x800258 <WaitAndBlink(baudRecCheck)::timeStamp1+0x3>
    28f4:	ce cf       	rjmp	.-100    	; 0x2892 <WaitAndBlink(baudRecCheck) [clone .constprop.33]+0xf8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2170
        }
      }
    }
  }
}
    28f6:	cf 91       	pop	r28
    28f8:	1f 91       	pop	r17
    28fa:	0f 91       	pop	r16
    28fc:	ff 90       	pop	r15
    28fe:	ef 90       	pop	r14
    2900:	df 90       	pop	r13
    2902:	cf 90       	pop	r12
    2904:	08 95       	ret

00002906 <__vector_14>:
__vector_14():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial0.cpp:63
#elif defined(USART0_UDRE_vect)
ISR(USART0_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    2906:	1f 92       	push	r1
    2908:	0f 92       	push	r0
    290a:	0f b6       	in	r0, 0x3f	; 63
    290c:	0f 92       	push	r0
    290e:	11 24       	eor	r1, r1
    2910:	2f 93       	push	r18
    2912:	3f 93       	push	r19
    2914:	4f 93       	push	r20
    2916:	5f 93       	push	r21
    2918:	6f 93       	push	r22
    291a:	7f 93       	push	r23
    291c:	8f 93       	push	r24
    291e:	9f 93       	push	r25
    2920:	af 93       	push	r26
    2922:	bf 93       	push	r27
    2924:	ef 93       	push	r30
    2926:	ff 93       	push	r31
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial0.cpp:64
  Serial._tx_udr_empty_irq();
    2928:	86 ea       	ldi	r24, 0xA6	; 166
    292a:	92 e0       	ldi	r25, 0x02	; 2
    292c:	0e 94 55 05 	call	0xaaa	; 0xaaa <HardwareSerial::_tx_udr_empty_irq()>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial0.cpp:65
}
    2930:	ff 91       	pop	r31
    2932:	ef 91       	pop	r30
    2934:	bf 91       	pop	r27
    2936:	af 91       	pop	r26
    2938:	9f 91       	pop	r25
    293a:	8f 91       	pop	r24
    293c:	7f 91       	pop	r23
    293e:	6f 91       	pop	r22
    2940:	5f 91       	pop	r21
    2942:	4f 91       	pop	r20
    2944:	3f 91       	pop	r19
    2946:	2f 91       	pop	r18
    2948:	0f 90       	pop	r0
    294a:	0f be       	out	0x3f, r0	; 63
    294c:	0f 90       	pop	r0
    294e:	1f 90       	pop	r1
    2950:	18 95       	reti

00002952 <__vector_13>:
__vector_13():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial0.cpp:50
#elif defined(USART_RX_vect)
  ISR(USART_RX_vect)
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    2952:	1f 92       	push	r1
    2954:	0f 92       	push	r0
    2956:	0f b6       	in	r0, 0x3f	; 63
    2958:	0f 92       	push	r0
    295a:	11 24       	eor	r1, r1
    295c:	2f 93       	push	r18
    295e:	8f 93       	push	r24
    2960:	9f 93       	push	r25
    2962:	ef 93       	push	r30
    2964:	ff 93       	push	r31
_rx_complete_irq():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial_private.h:100

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    2966:	e0 91 b6 02 	lds	r30, 0x02B6	; 0x8002b6 <Serial+0x10>
    296a:	f0 91 b7 02 	lds	r31, 0x02B7	; 0x8002b7 <Serial+0x11>
    296e:	80 81       	ld	r24, Z
    2970:	e0 91 bc 02 	lds	r30, 0x02BC	; 0x8002bc <Serial+0x16>
    2974:	f0 91 bd 02 	lds	r31, 0x02BD	; 0x8002bd <Serial+0x17>
    2978:	82 fd       	sbrc	r24, 2
    297a:	1b c0       	rjmp	.+54     	; 0x29b2 <__vector_13+0x60>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial_private.h:103
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    297c:	90 81       	ld	r25, Z
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial_private.h:104
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    297e:	80 91 bf 02 	lds	r24, 0x02BF	; 0x8002bf <Serial+0x19>
    2982:	8f 5f       	subi	r24, 0xFF	; 255
    2984:	8f 73       	andi	r24, 0x3F	; 63
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial_private.h:110

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    2986:	20 91 c0 02 	lds	r18, 0x02C0	; 0x8002c0 <Serial+0x1a>
    298a:	82 17       	cp	r24, r18
    298c:	41 f0       	breq	.+16     	; 0x299e <__vector_13+0x4c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial_private.h:111
      _rx_buffer[_rx_buffer_head] = c;
    298e:	e0 91 bf 02 	lds	r30, 0x02BF	; 0x8002bf <Serial+0x19>
    2992:	f0 e0       	ldi	r31, 0x00	; 0
    2994:	ea 55       	subi	r30, 0x5A	; 90
    2996:	fd 4f       	sbci	r31, 0xFD	; 253
    2998:	95 8f       	std	Z+29, r25	; 0x1d
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial_private.h:112
      _rx_buffer_head = i;
    299a:	80 93 bf 02 	sts	0x02BF, r24	; 0x8002bf <Serial+0x19>
__vector_13():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial0.cpp:52
    Serial._rx_complete_irq();
  }
    299e:	ff 91       	pop	r31
    29a0:	ef 91       	pop	r30
    29a2:	9f 91       	pop	r25
    29a4:	8f 91       	pop	r24
    29a6:	2f 91       	pop	r18
    29a8:	0f 90       	pop	r0
    29aa:	0f be       	out	0x3f, r0	; 63
    29ac:	0f 90       	pop	r0
    29ae:	1f 90       	pop	r1
    29b0:	18 95       	reti
_rx_complete_irq():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial_private.h:116
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    29b2:	80 81       	ld	r24, Z
    29b4:	f4 cf       	rjmp	.-24     	; 0x299e <__vector_13+0x4c>

000029b6 <__vector_11>:
__vector_11():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:159
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
    29b6:	1f 92       	push	r1
    29b8:	0f 92       	push	r0
    29ba:	0f b6       	in	r0, 0x3f	; 63
    29bc:	0f 92       	push	r0
    29be:	11 24       	eor	r1, r1
    29c0:	2f 93       	push	r18
    29c2:	3f 93       	push	r19
    29c4:	8f 93       	push	r24
    29c6:	9f 93       	push	r25
    29c8:	af 93       	push	r26
    29ca:	bf 93       	push	r27
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:167
  static unsigned char timer0_exact = 0;
#endif

  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access, so this saves time)
  unsigned long m = timer0_millis;
    29cc:	80 91 ba 01 	lds	r24, 0x01BA	; 0x8001ba <timer0_millis>
    29d0:	90 91 bb 01 	lds	r25, 0x01BB	; 0x8001bb <timer0_millis+0x1>
    29d4:	a0 91 bc 01 	lds	r26, 0x01BC	; 0x8001bc <timer0_millis+0x2>
    29d8:	b0 91 bd 01 	lds	r27, 0x01BD	; 0x8001bd <timer0_millis+0x3>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:168
  unsigned char f = timer0_fract;
    29dc:	30 91 b9 01 	lds	r19, 0x01B9	; 0x8001b9 <timer0_fract>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:170

  f += FRACT_INC FRACT_INC_PLUS;
    29e0:	23 e0       	ldi	r18, 0x03	; 3
    29e2:	23 0f       	add	r18, r19
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:200
    ++f;
  }
#endif
#endif // CORRECT_EXACT_MILLIS

  if (f >= FRACT_MAX) {
    29e4:	2d 37       	cpi	r18, 0x7D	; 125
    29e6:	68 f1       	brcs	.+90     	; 0x2a42 <__vector_11+0x8c>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:201
    f -= FRACT_MAX;
    29e8:	26 e8       	ldi	r18, 0x86	; 134
    29ea:	23 0f       	add	r18, r19
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:202
    m += MILLIS_INC + 1;
    29ec:	02 96       	adiw	r24, 0x02	; 2
    29ee:	a1 1d       	adc	r26, r1
    29f0:	b1 1d       	adc	r27, r1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:208
  }
  else {
    m += MILLIS_INC;
  }

  timer0_fract = f;
    29f2:	20 93 b9 01 	sts	0x01B9, r18	; 0x8001b9 <timer0_fract>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:209
  timer0_millis = m;
    29f6:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <timer0_millis>
    29fa:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <timer0_millis+0x1>
    29fe:	a0 93 bc 01 	sts	0x01BC, r26	; 0x8001bc <timer0_millis+0x2>
    2a02:	b0 93 bd 01 	sts	0x01BD, r27	; 0x8001bd <timer0_millis+0x3>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:211
#ifndef CORRECT_EXACT_MICROS
  timer0_overflow_count++;
    2a06:	80 91 be 01 	lds	r24, 0x01BE	; 0x8001be <timer0_overflow_count>
    2a0a:	90 91 bf 01 	lds	r25, 0x01BF	; 0x8001bf <timer0_overflow_count+0x1>
    2a0e:	a0 91 c0 01 	lds	r26, 0x01C0	; 0x8001c0 <timer0_overflow_count+0x2>
    2a12:	b0 91 c1 01 	lds	r27, 0x01C1	; 0x8001c1 <timer0_overflow_count+0x3>
    2a16:	01 96       	adiw	r24, 0x01	; 1
    2a18:	a1 1d       	adc	r26, r1
    2a1a:	b1 1d       	adc	r27, r1
    2a1c:	80 93 be 01 	sts	0x01BE, r24	; 0x8001be <timer0_overflow_count>
    2a20:	90 93 bf 01 	sts	0x01BF, r25	; 0x8001bf <timer0_overflow_count+0x1>
    2a24:	a0 93 c0 01 	sts	0x01C0, r26	; 0x8001c0 <timer0_overflow_count+0x2>
    2a28:	b0 93 c1 01 	sts	0x01C1, r27	; 0x8001c1 <timer0_overflow_count+0x3>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:213
#endif
}
    2a2c:	bf 91       	pop	r27
    2a2e:	af 91       	pop	r26
    2a30:	9f 91       	pop	r25
    2a32:	8f 91       	pop	r24
    2a34:	3f 91       	pop	r19
    2a36:	2f 91       	pop	r18
    2a38:	0f 90       	pop	r0
    2a3a:	0f be       	out	0x3f, r0	; 63
    2a3c:	0f 90       	pop	r0
    2a3e:	1f 90       	pop	r1
    2a40:	18 95       	reti
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:205
  if (f >= FRACT_MAX) {
    f -= FRACT_MAX;
    m += MILLIS_INC + 1;
  }
  else {
    m += MILLIS_INC;
    2a42:	01 96       	adiw	r24, 0x01	; 1
    2a44:	a1 1d       	adc	r26, r1
    2a46:	b1 1d       	adc	r27, r1
    2a48:	d4 cf       	rjmp	.-88     	; 0x29f2 <__vector_11+0x3c>

00002a4a <__vector_19>:
__vector_19():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:534
  }
  return(flag);
}

ISR(TWI_vect)
{
    2a4a:	1f 92       	push	r1
    2a4c:	0f 92       	push	r0
    2a4e:	0f b6       	in	r0, 0x3f	; 63
    2a50:	0f 92       	push	r0
    2a52:	11 24       	eor	r1, r1
    2a54:	2f 93       	push	r18
    2a56:	3f 93       	push	r19
    2a58:	4f 93       	push	r20
    2a5a:	5f 93       	push	r21
    2a5c:	6f 93       	push	r22
    2a5e:	7f 93       	push	r23
    2a60:	8f 93       	push	r24
    2a62:	9f 93       	push	r25
    2a64:	af 93       	push	r26
    2a66:	bf 93       	push	r27
    2a68:	ef 93       	push	r30
    2a6a:	ff 93       	push	r31
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:535
  switch(TW_STATUS){
    2a6c:	81 b1       	in	r24, 0x01	; 1
    2a6e:	88 7f       	andi	r24, 0xF8	; 248
    2a70:	80 36       	cpi	r24, 0x60	; 96
    2a72:	09 f4       	brne	.+2      	; 0x2a76 <__vector_19+0x2c>
    2a74:	4a c0       	rjmp	.+148    	; 0x2b0a <__vector_19+0xc0>
    2a76:	f0 f5       	brcc	.+124    	; 0x2af4 <__vector_19+0xaa>
    2a78:	88 32       	cpi	r24, 0x28	; 40
    2a7a:	09 f4       	brne	.+2      	; 0x2a7e <__vector_19+0x34>
    2a7c:	a3 c0       	rjmp	.+326    	; 0x2bc4 <__vector_19+0x17a>
    2a7e:	18 f5       	brcc	.+70     	; 0x2ac6 <__vector_19+0x7c>
    2a80:	80 31       	cpi	r24, 0x10	; 16
    2a82:	09 f4       	brne	.+2      	; 0x2a86 <__vector_19+0x3c>
    2a84:	99 c0       	rjmp	.+306    	; 0x2bb8 <__vector_19+0x16e>
    2a86:	b8 f4       	brcc	.+46     	; 0x2ab6 <__vector_19+0x6c>
    2a88:	88 23       	and	r24, r24
    2a8a:	09 f4       	brne	.+2      	; 0x2a8e <__vector_19+0x44>
    2a8c:	fd c0       	rjmp	.+506    	; 0x2c88 <__vector_19+0x23e>
    2a8e:	88 30       	cpi	r24, 0x08	; 8
    2a90:	09 f4       	brne	.+2      	; 0x2a94 <__vector_19+0x4a>
    2a92:	92 c0       	rjmp	.+292    	; 0x2bb8 <__vector_19+0x16e>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:696
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
      twi_stop();
      break;
  }
}
    2a94:	ff 91       	pop	r31
    2a96:	ef 91       	pop	r30
    2a98:	bf 91       	pop	r27
    2a9a:	af 91       	pop	r26
    2a9c:	9f 91       	pop	r25
    2a9e:	8f 91       	pop	r24
    2aa0:	7f 91       	pop	r23
    2aa2:	6f 91       	pop	r22
    2aa4:	5f 91       	pop	r21
    2aa6:	4f 91       	pop	r20
    2aa8:	3f 91       	pop	r19
    2aaa:	2f 91       	pop	r18
    2aac:	0f 90       	pop	r0
    2aae:	0f be       	out	0x3f, r0	; 63
    2ab0:	0f 90       	pop	r0
    2ab2:	1f 90       	pop	r1
    2ab4:	18 95       	reti
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    2ab6:	88 31       	cpi	r24, 0x18	; 24
    2ab8:	09 f4       	brne	.+2      	; 0x2abc <__vector_19+0x72>
    2aba:	84 c0       	rjmp	.+264    	; 0x2bc4 <__vector_19+0x17a>
    2abc:	80 32       	cpi	r24, 0x20	; 32
    2abe:	51 f7       	brne	.-44     	; 0x2a94 <__vector_19+0x4a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:570
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    2ac0:	80 93 2e 02 	sts	0x022E, r24	; 0x80022e <twi_error>
    2ac4:	14 c0       	rjmp	.+40     	; 0x2aee <__vector_19+0xa4>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    2ac6:	80 34       	cpi	r24, 0x40	; 64
    2ac8:	09 f4       	brne	.+2      	; 0x2acc <__vector_19+0x82>
    2aca:	a0 c0       	rjmp	.+320    	; 0x2c0c <__vector_19+0x1c2>
    2acc:	40 f4       	brcc	.+16     	; 0x2ade <__vector_19+0x94>
    2ace:	80 33       	cpi	r24, 0x30	; 48
    2ad0:	b9 f3       	breq	.-18     	; 0x2ac0 <__vector_19+0x76>
    2ad2:	88 33       	cpi	r24, 0x38	; 56
    2ad4:	f9 f6       	brne	.-66     	; 0x2a94 <__vector_19+0x4a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:574
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    2ad6:	80 93 2e 02 	sts	0x022E, r24	; 0x80022e <twi_error>
twi_reply():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:421
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2ada:	85 ec       	ldi	r24, 0xC5	; 197
    2adc:	b6 c0       	rjmp	.+364    	; 0x2c4a <__vector_19+0x200>
__vector_19():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    2ade:	80 35       	cpi	r24, 0x50	; 80
    2ae0:	09 f4       	brne	.+2      	; 0x2ae4 <__vector_19+0x9a>
    2ae2:	85 c0       	rjmp	.+266    	; 0x2bee <__vector_19+0x1a4>
    2ae4:	88 35       	cpi	r24, 0x58	; 88
    2ae6:	09 f4       	brne	.+2      	; 0x2aea <__vector_19+0xa0>
    2ae8:	99 c0       	rjmp	.+306    	; 0x2c1c <__vector_19+0x1d2>
    2aea:	88 34       	cpi	r24, 0x48	; 72
    2aec:	99 f6       	brne	.-90     	; 0x2a94 <__vector_19+0x4a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:693
    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
      twi_stop();
    2aee:	0e 94 46 07 	call	0xe8c	; 0xe8c <twi_stop>
    2af2:	d0 cf       	rjmp	.-96     	; 0x2a94 <__vector_19+0x4a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    2af4:	88 39       	cpi	r24, 0x98	; 152
    2af6:	09 f4       	brne	.+2      	; 0x2afa <__vector_19+0xb0>
    2af8:	8f c0       	rjmp	.+286    	; 0x2c18 <__vector_19+0x1ce>
    2afa:	30 f5       	brcc	.+76     	; 0x2b48 <__vector_19+0xfe>
    2afc:	88 37       	cpi	r24, 0x78	; 120
    2afe:	29 f0       	breq	.+10     	; 0x2b0a <__vector_19+0xc0>
    2b00:	50 f4       	brcc	.+20     	; 0x2b16 <__vector_19+0xcc>
    2b02:	88 36       	cpi	r24, 0x68	; 104
    2b04:	11 f0       	breq	.+4      	; 0x2b0a <__vector_19+0xc0>
    2b06:	80 37       	cpi	r24, 0x70	; 112
    2b08:	29 f6       	brne	.-118    	; 0x2a94 <__vector_19+0x4a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:616
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    2b0a:	83 e0       	ldi	r24, 0x03	; 3
    2b0c:	80 93 30 02 	sts	0x0230, r24	; 0x800230 <twi_state>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:618
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    2b10:	10 92 b8 01 	sts	0x01B8, r1	; 0x8001b8 <twi_rxBufferIndex>
    2b14:	54 c0       	rjmp	.+168    	; 0x2bbe <__vector_19+0x174>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    2b16:	88 38       	cpi	r24, 0x88	; 136
    2b18:	09 f4       	brne	.+2      	; 0x2b1c <__vector_19+0xd2>
    2b1a:	7e c0       	rjmp	.+252    	; 0x2c18 <__vector_19+0x1ce>
    2b1c:	80 39       	cpi	r24, 0x90	; 144
    2b1e:	19 f0       	breq	.+6      	; 0x2b26 <__vector_19+0xdc>
    2b20:	80 38       	cpi	r24, 0x80	; 128
    2b22:	09 f0       	breq	.+2      	; 0x2b26 <__vector_19+0xdc>
    2b24:	b7 cf       	rjmp	.-146    	; 0x2a94 <__vector_19+0x4a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:624
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_SIZE){
    2b26:	80 91 b8 01 	lds	r24, 0x01B8	; 0x8001b8 <twi_rxBufferIndex>
    2b2a:	80 32       	cpi	r24, 0x20	; 32
    2b2c:	08 f0       	brcs	.+2      	; 0x2b30 <__vector_19+0xe6>
    2b2e:	74 c0       	rjmp	.+232    	; 0x2c18 <__vector_19+0x1ce>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:626
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    2b30:	e0 91 b8 01 	lds	r30, 0x01B8	; 0x8001b8 <twi_rxBufferIndex>
    2b34:	81 e0       	ldi	r24, 0x01	; 1
    2b36:	8e 0f       	add	r24, r30
    2b38:	80 93 b8 01 	sts	0x01B8, r24	; 0x8001b8 <twi_rxBufferIndex>
    2b3c:	83 b1       	in	r24, 0x03	; 3
    2b3e:	f0 e0       	ldi	r31, 0x00	; 0
    2b40:	e8 56       	subi	r30, 0x68	; 104
    2b42:	fe 4f       	sbci	r31, 0xFE	; 254
    2b44:	80 83       	st	Z, r24
    2b46:	3b c0       	rjmp	.+118    	; 0x2bbe <__vector_19+0x174>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    2b48:	80 3b       	cpi	r24, 0xB0	; 176
    2b4a:	39 f0       	breq	.+14     	; 0x2b5a <__vector_19+0x110>
    2b4c:	e0 f4       	brcc	.+56     	; 0x2b86 <__vector_19+0x13c>
    2b4e:	80 3a       	cpi	r24, 0xA0	; 160
    2b50:	09 f4       	brne	.+2      	; 0x2b54 <__vector_19+0x10a>
    2b52:	7f c0       	rjmp	.+254    	; 0x2c52 <__vector_19+0x208>
    2b54:	88 3a       	cpi	r24, 0xA8	; 168
    2b56:	09 f0       	breq	.+2      	; 0x2b5a <__vector_19+0x110>
    2b58:	9d cf       	rjmp	.-198    	; 0x2a94 <__vector_19+0x4a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:655

    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    2b5a:	84 e0       	ldi	r24, 0x04	; 4
    2b5c:	80 93 30 02 	sts	0x0230, r24	; 0x800230 <twi_state>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:657
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    2b60:	10 92 97 01 	sts	0x0197, r1	; 0x800197 <twi_txBufferIndex>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:659
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    2b64:	10 92 96 01 	sts	0x0196, r1	; 0x800196 <twi_txBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:662
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    2b68:	e0 91 fd 01 	lds	r30, 0x01FD	; 0x8001fd <twi_onSlaveTransmit>
    2b6c:	f0 91 fe 01 	lds	r31, 0x01FE	; 0x8001fe <twi_onSlaveTransmit+0x1>
    2b70:	09 95       	icall
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:664
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    2b72:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <twi_txBufferLength>
    2b76:	81 11       	cpse	r24, r1
    2b78:	0f c0       	rjmp	.+30     	; 0x2b98 <__vector_19+0x14e>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:665
        twi_txBufferLength = 1;
    2b7a:	81 e0       	ldi	r24, 0x01	; 1
    2b7c:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <twi_txBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:666
        twi_txBuffer[0] = 0x00;
    2b80:	10 92 76 01 	sts	0x0176, r1	; 0x800176 <twi_txBuffer>
    2b84:	09 c0       	rjmp	.+18     	; 0x2b98 <__vector_19+0x14e>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    2b86:	80 3c       	cpi	r24, 0xC0	; 192
    2b88:	09 f4       	brne	.+2      	; 0x2b8c <__vector_19+0x142>
    2b8a:	a7 cf       	rjmp	.-178    	; 0x2ada <__vector_19+0x90>
    2b8c:	88 3c       	cpi	r24, 0xC8	; 200
    2b8e:	09 f4       	brne	.+2      	; 0x2b92 <__vector_19+0x148>
    2b90:	a4 cf       	rjmp	.-184    	; 0x2ada <__vector_19+0x90>
    2b92:	88 3b       	cpi	r24, 0xB8	; 184
    2b94:	09 f0       	breq	.+2      	; 0x2b98 <__vector_19+0x14e>
    2b96:	7e cf       	rjmp	.-260    	; 0x2a94 <__vector_19+0x4a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:672
      }
      // transmit first byte from buffer, fall
      /* fall through */
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    2b98:	e0 91 97 01 	lds	r30, 0x0197	; 0x800197 <twi_txBufferIndex>
    2b9c:	81 e0       	ldi	r24, 0x01	; 1
    2b9e:	8e 0f       	add	r24, r30
    2ba0:	80 93 97 01 	sts	0x0197, r24	; 0x800197 <twi_txBufferIndex>
    2ba4:	f0 e0       	ldi	r31, 0x00	; 0
    2ba6:	ea 58       	subi	r30, 0x8A	; 138
    2ba8:	fe 4f       	sbci	r31, 0xFE	; 254
    2baa:	80 81       	ld	r24, Z
    2bac:	83 b9       	out	0x03, r24	; 3
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:674
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    2bae:	90 91 97 01 	lds	r25, 0x0197	; 0x800197 <twi_txBufferIndex>
    2bb2:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <twi_txBufferLength>
    2bb6:	2e c0       	rjmp	.+92     	; 0x2c14 <__vector_19+0x1ca>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:540
  switch(TW_STATUS){
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    2bb8:	80 91 29 02 	lds	r24, 0x0229	; 0x800229 <twi_slarw>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:550
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    2bbc:	83 b9       	out	0x03, r24	; 3
twi_reply():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:421
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2bbe:	85 ec       	ldi	r24, 0xC5	; 197
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:423
  }else{
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2bc0:	86 bf       	out	0x36, r24	; 54
    2bc2:	68 cf       	rjmp	.-304    	; 0x2a94 <__vector_19+0x4a>
__vector_19():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:548

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop
      if(twi_masterBufferIndex < twi_masterBufferLength){
    2bc4:	90 91 2b 02 	lds	r25, 0x022B	; 0x80022b <twi_masterBufferIndex>
    2bc8:	80 91 2a 02 	lds	r24, 0x022A	; 0x80022a <twi_masterBufferLength>
    2bcc:	98 17       	cp	r25, r24
    2bce:	a8 f5       	brcc	.+106    	; 0x2c3a <__vector_19+0x1f0>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:550
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    2bd0:	80 91 2c 02 	lds	r24, 0x022C	; 0x80022c <twi_masterBuffer>
    2bd4:	90 91 2d 02 	lds	r25, 0x022D	; 0x80022d <twi_masterBuffer+0x1>
    2bd8:	e0 91 2b 02 	lds	r30, 0x022B	; 0x80022b <twi_masterBufferIndex>
    2bdc:	21 e0       	ldi	r18, 0x01	; 1
    2bde:	2e 0f       	add	r18, r30
    2be0:	20 93 2b 02 	sts	0x022B, r18	; 0x80022b <twi_masterBufferIndex>
    2be4:	e8 0f       	add	r30, r24
    2be6:	f9 2f       	mov	r31, r25
    2be8:	f1 1d       	adc	r31, r1
    2bea:	80 81       	ld	r24, Z
    2bec:	e7 cf       	rjmp	.-50     	; 0x2bbc <__vector_19+0x172>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:581
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2bee:	20 91 2c 02 	lds	r18, 0x022C	; 0x80022c <twi_masterBuffer>
    2bf2:	30 91 2d 02 	lds	r19, 0x022D	; 0x80022d <twi_masterBuffer+0x1>
    2bf6:	e0 91 2b 02 	lds	r30, 0x022B	; 0x80022b <twi_masterBufferIndex>
    2bfa:	81 e0       	ldi	r24, 0x01	; 1
    2bfc:	8e 0f       	add	r24, r30
    2bfe:	80 93 2b 02 	sts	0x022B, r24	; 0x80022b <twi_masterBufferIndex>
    2c02:	83 b1       	in	r24, 0x03	; 3
    2c04:	e2 0f       	add	r30, r18
    2c06:	f3 2f       	mov	r31, r19
    2c08:	f1 1d       	adc	r31, r1
    2c0a:	80 83       	st	Z, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:585
      /* fall through */
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    2c0c:	90 91 2b 02 	lds	r25, 0x022B	; 0x80022b <twi_masterBufferIndex>
    2c10:	80 91 2a 02 	lds	r24, 0x022A	; 0x80022a <twi_masterBufferLength>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:674
      /* fall through */
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    2c14:	98 17       	cp	r25, r24
    2c16:	98 f2       	brcs	.-90     	; 0x2bbe <__vector_19+0x174>
twi_reply():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:423
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2c18:	85 e8       	ldi	r24, 0x85	; 133
    2c1a:	d2 cf       	rjmp	.-92     	; 0x2bc0 <__vector_19+0x176>
__vector_19():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:593
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2c1c:	20 91 2c 02 	lds	r18, 0x022C	; 0x80022c <twi_masterBuffer>
    2c20:	30 91 2d 02 	lds	r19, 0x022D	; 0x80022d <twi_masterBuffer+0x1>
    2c24:	e0 91 2b 02 	lds	r30, 0x022B	; 0x80022b <twi_masterBufferIndex>
    2c28:	81 e0       	ldi	r24, 0x01	; 1
    2c2a:	8e 0f       	add	r24, r30
    2c2c:	80 93 2b 02 	sts	0x022B, r24	; 0x80022b <twi_masterBufferIndex>
    2c30:	83 b1       	in	r24, 0x03	; 3
    2c32:	e2 0f       	add	r30, r18
    2c34:	f3 2f       	mov	r31, r19
    2c36:	f1 1d       	adc	r31, r1
    2c38:	80 83       	st	Z, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:594
  if (twi_sendStop)
    2c3a:	80 91 2f 02 	lds	r24, 0x022F	; 0x80022f <twi_sendStop>
    2c3e:	81 11       	cpse	r24, r1
    2c40:	56 cf       	rjmp	.-340    	; 0x2aee <__vector_19+0xa4>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:597
          twi_stop();
  else {
    twi_inRepStart = true;  // we're going to send the START
    2c42:	81 e0       	ldi	r24, 0x01	; 1
    2c44:	80 93 28 02 	sts	0x0228, r24	; 0x800228 <twi_inRepStart>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:601
    // don't enable the interrupt. We'll generate the start, but we
    // avoid handling the interrupt until we're in the next transaction,
    // at the point where we would normally issue the start.
    TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    2c48:	84 ea       	ldi	r24, 0xA4	; 164
twi_reply():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:421
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2c4a:	86 bf       	out	0x36, r24	; 54
__vector_19():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:685
    case TW_ST_DATA_NACK: // received nack, we are done
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    2c4c:	10 92 30 02 	sts	0x0230, r1	; 0x800230 <twi_state>
    2c50:	21 cf       	rjmp	.-446    	; 0x2a94 <__vector_19+0x4a>
twi_releaseBus():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:474
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    2c52:	85 ec       	ldi	r24, 0xC5	; 197
    2c54:	86 bf       	out	0x36, r24	; 54
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:477

  // update twi state
  twi_state = TWI_READY;
    2c56:	10 92 30 02 	sts	0x0230, r1	; 0x800230 <twi_state>
__vector_19():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:637
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_SIZE){
    2c5a:	80 91 b8 01 	lds	r24, 0x01B8	; 0x8001b8 <twi_rxBufferIndex>
    2c5e:	80 32       	cpi	r24, 0x20	; 32
    2c60:	30 f4       	brcc	.+12     	; 0x2c6e <__vector_19+0x224>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:638
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    2c62:	e0 91 b8 01 	lds	r30, 0x01B8	; 0x8001b8 <twi_rxBufferIndex>
    2c66:	f0 e0       	ldi	r31, 0x00	; 0
    2c68:	e8 56       	subi	r30, 0x68	; 104
    2c6a:	fe 4f       	sbci	r31, 0xFE	; 254
    2c6c:	10 82       	st	Z, r1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:641
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    2c6e:	60 91 b8 01 	lds	r22, 0x01B8	; 0x8001b8 <twi_rxBufferIndex>
    2c72:	70 e0       	ldi	r23, 0x00	; 0
    2c74:	e0 91 fb 01 	lds	r30, 0x01FB	; 0x8001fb <twi_onSlaveReceive>
    2c78:	f0 91 fc 01 	lds	r31, 0x01FC	; 0x8001fc <twi_onSlaveReceive+0x1>
    2c7c:	88 e9       	ldi	r24, 0x98	; 152
    2c7e:	91 e0       	ldi	r25, 0x01	; 1
    2c80:	09 95       	icall
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:643
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    2c82:	10 92 b8 01 	sts	0x01B8, r1	; 0x8001b8 <twi_rxBufferIndex>
    2c86:	06 cf       	rjmp	.-500    	; 0x2a94 <__vector_19+0x4a>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src\utility/twi.c:692

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    2c88:	10 92 2e 02 	sts	0x022E, r1	; 0x80022e <twi_error>
    2c8c:	30 cf       	rjmp	.-416    	; 0x2aee <__vector_19+0xa4>

00002c8e <disk_writep>:
disk_writep():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:226
#if _USE_WRITE
DRESULT disk_writep (
	const BYTE *buff,	/* Pointer to the bytes to be written (NULL:Initiate/Finalize sector write) */
	DWORD sc			/* Number of bytes to send, Sector number (LBA) or zero */
)
{
    2c8e:	ef 92       	push	r14
    2c90:	ff 92       	push	r15
    2c92:	0f 93       	push	r16
    2c94:	1f 93       	push	r17
    2c96:	cf 93       	push	r28
    2c98:	df 93       	push	r29
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:233
	UINT bc;
	static UINT wc;	/* Sector write counter */

	res = RES_ERROR;

	if (buff) {		/* Send data bytes */
    2c9a:	00 97       	sbiw	r24, 0x00	; 0
    2c9c:	c9 f0       	breq	.+50     	; 0x2cd0 <disk_writep+0x42>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:234
		bc = sc;
    2c9e:	ea 01       	movw	r28, r20
    2ca0:	8c 01       	movw	r16, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:235
		while (bc && wc) {		/* Send data bytes to the card */
    2ca2:	20 97       	sbiw	r28, 0x00	; 0
    2ca4:	b1 f1       	breq	.+108    	; 0x2d12 <disk_writep+0x84>
    2ca6:	e0 90 cf 01 	lds	r14, 0x01CF	; 0x8001cf <disk_writep::wc>
    2caa:	f0 90 d0 01 	lds	r15, 0x01D0	; 0x8001d0 <disk_writep::wc+0x1>
    2cae:	e1 14       	cp	r14, r1
    2cb0:	f1 04       	cpc	r15, r1
    2cb2:	79 f1       	breq	.+94     	; 0x2d12 <disk_writep+0x84>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:236
			xmit_spi(*buff++);
    2cb4:	f8 01       	movw	r30, r16
    2cb6:	81 91       	ld	r24, Z+
    2cb8:	8f 01       	movw	r16, r30
    2cba:	0e 94 13 09 	call	0x1226	; 0x1226 <xmit_spi(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:237
			wc--; bc--;
    2cbe:	f1 e0       	ldi	r31, 0x01	; 1
    2cc0:	ef 1a       	sub	r14, r31
    2cc2:	f1 08       	sbc	r15, r1
    2cc4:	f0 92 d0 01 	sts	0x01D0, r15	; 0x8001d0 <disk_writep::wc+0x1>
    2cc8:	e0 92 cf 01 	sts	0x01CF, r14	; 0x8001cf <disk_writep::wc>
    2ccc:	21 97       	sbiw	r28, 0x01	; 1
    2cce:	e9 cf       	rjmp	.-46     	; 0x2ca2 <disk_writep+0x14>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:241
		}
		res = RES_OK;
	} else {
		if (sc) {	/* Initiate sector write process */
    2cd0:	41 15       	cp	r20, r1
    2cd2:	51 05       	cpc	r21, r1
    2cd4:	61 05       	cpc	r22, r1
    2cd6:	71 05       	cpc	r23, r1
    2cd8:	29 f1       	breq	.+74     	; 0x2d24 <disk_writep+0x96>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:242
			if (!(CardType & CT_BLOCK)) sc *= 512;	/* Convert to byte address if needed */
    2cda:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <CardType>
    2cde:	83 fd       	sbrc	r24, 3
    2ce0:	07 c0       	rjmp	.+14     	; 0x2cf0 <disk_writep+0x62>
    2ce2:	89 e0       	ldi	r24, 0x09	; 9
    2ce4:	44 0f       	add	r20, r20
    2ce6:	55 1f       	adc	r21, r21
    2ce8:	66 1f       	adc	r22, r22
    2cea:	77 1f       	adc	r23, r23
    2cec:	8a 95       	dec	r24
    2cee:	d1 f7       	brne	.-12     	; 0x2ce4 <disk_writep+0x56>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:243
			if (send_cmd(CMD24, sc) == 0) {			/* WRITE_SINGLE_BLOCK */
    2cf0:	88 e5       	ldi	r24, 0x58	; 88
    2cf2:	0e 94 58 09 	call	0x12b0	; 0x12b0 <send_cmd(unsigned char, unsigned long)>
    2cf6:	81 11       	cpse	r24, r1
    2cf8:	1d c0       	rjmp	.+58     	; 0x2d34 <disk_writep+0xa6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:244
				xmit_spi(0xFF); xmit_spi(0xFE);		/* Data block header */
    2cfa:	8f ef       	ldi	r24, 0xFF	; 255
    2cfc:	0e 94 13 09 	call	0x1226	; 0x1226 <xmit_spi(unsigned char)>
    2d00:	8e ef       	ldi	r24, 0xFE	; 254
    2d02:	0e 94 13 09 	call	0x1226	; 0x1226 <xmit_spi(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:245
				wc = 512;							/* Set byte counter */
    2d06:	80 e0       	ldi	r24, 0x00	; 0
    2d08:	92 e0       	ldi	r25, 0x02	; 2
    2d0a:	90 93 d0 01 	sts	0x01D0, r25	; 0x8001d0 <disk_writep::wc+0x1>
    2d0e:	80 93 cf 01 	sts	0x01CF, r24	; 0x8001cf <disk_writep::wc>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:239
		bc = sc;
		while (bc && wc) {		/* Send data bytes to the card */
			xmit_spi(*buff++);
			wc--; bc--;
		}
		res = RES_OK;
    2d12:	90 e0       	ldi	r25, 0x00	; 0
    2d14:	80 e0       	ldi	r24, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:262
			rcv_spi();
		}
	}

	return res;
}
    2d16:	df 91       	pop	r29
    2d18:	cf 91       	pop	r28
    2d1a:	1f 91       	pop	r17
    2d1c:	0f 91       	pop	r16
    2d1e:	ff 90       	pop	r15
    2d20:	ef 90       	pop	r14
    2d22:	08 95       	ret
    2d24:	df 91       	pop	r29
    2d26:	cf 91       	pop	r28
    2d28:	1f 91       	pop	r17
    2d2a:	0f 91       	pop	r16
    2d2c:	ff 90       	pop	r15
    2d2e:	ef 90       	pop	r14
    2d30:	0c 94 1c 09 	jmp	0x1238	; 0x1238 <disk_writep.part.1>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/avr_mmcp.cpp:231
{
	DRESULT res;
	UINT bc;
	static UINT wc;	/* Sector write counter */

	res = RES_ERROR;
    2d34:	81 e0       	ldi	r24, 0x01	; 1
    2d36:	90 e0       	ldi	r25, 0x00	; 0
    2d38:	ee cf       	rjmp	.-36     	; 0x2d16 <disk_writep+0x88>

00002d3a <global constructors keyed to 65535_0_S220718_R290823_IOS_Z80_MBC2.ino.cpp.o.2690>:
_GLOBAL__I_65535_0_S220718_R290823_IOS_Z80_MBC2.ino.cpp.o.2690():
    2d3a:	e6 ea       	ldi	r30, 0xA6	; 166
    2d3c:	f2 e0       	ldi	r31, 0x02	; 2
    2d3e:	13 82       	std	Z+3, r1	; 0x03
    2d40:	12 82       	std	Z+2, r1	; 0x02
    2d42:	88 ee       	ldi	r24, 0xE8	; 232
    2d44:	93 e0       	ldi	r25, 0x03	; 3
    2d46:	a0 e0       	ldi	r26, 0x00	; 0
    2d48:	b0 e0       	ldi	r27, 0x00	; 0
    2d4a:	84 83       	std	Z+4, r24	; 0x04
    2d4c:	95 83       	std	Z+5, r25	; 0x05
    2d4e:	a6 83       	std	Z+6, r26	; 0x06
    2d50:	b7 83       	std	Z+7, r27	; 0x07
    2d52:	2a ea       	ldi	r18, 0xAA	; 170
    2d54:	30 e0       	ldi	r19, 0x00	; 0
    2d56:	31 83       	std	Z+1, r19	; 0x01
    2d58:	20 83       	st	Z, r18
    2d5a:	20 e4       	ldi	r18, 0x40	; 64
    2d5c:	30 e0       	ldi	r19, 0x00	; 0
    2d5e:	35 87       	std	Z+13, r19	; 0x0d
    2d60:	24 87       	std	Z+12, r18	; 0x0c
    2d62:	49 e2       	ldi	r20, 0x29	; 41
    2d64:	50 e0       	ldi	r21, 0x00	; 0
    2d66:	57 87       	std	Z+15, r21	; 0x0f
    2d68:	46 87       	std	Z+14, r20	; 0x0e
    2d6a:	4b e2       	ldi	r20, 0x2B	; 43
    2d6c:	50 e0       	ldi	r21, 0x00	; 0
    2d6e:	51 8b       	std	Z+17, r21	; 0x11
    2d70:	40 8b       	std	Z+16, r20	; 0x10
    2d72:	4a e2       	ldi	r20, 0x2A	; 42
    2d74:	50 e0       	ldi	r21, 0x00	; 0
    2d76:	53 8b       	std	Z+19, r21	; 0x13
    2d78:	42 8b       	std	Z+18, r20	; 0x12
    2d7a:	35 8b       	std	Z+21, r19	; 0x15
    2d7c:	24 8b       	std	Z+20, r18	; 0x14
    2d7e:	2c e2       	ldi	r18, 0x2C	; 44
    2d80:	30 e0       	ldi	r19, 0x00	; 0
    2d82:	37 8b       	std	Z+23, r19	; 0x17
    2d84:	26 8b       	std	Z+22, r18	; 0x16
    2d86:	11 8e       	std	Z+25, r1	; 0x19
    2d88:	12 8e       	std	Z+26, r1	; 0x1a
    2d8a:	13 8e       	std	Z+27, r1	; 0x1b
    2d8c:	14 8e       	std	Z+28, r1	; 0x1c
    2d8e:	e3 e4       	ldi	r30, 0x43	; 67
    2d90:	f3 e0       	ldi	r31, 0x03	; 3
    2d92:	13 82       	std	Z+3, r1	; 0x03
    2d94:	12 82       	std	Z+2, r1	; 0x02
    2d96:	84 83       	std	Z+4, r24	; 0x04
    2d98:	95 83       	std	Z+5, r25	; 0x05
    2d9a:	a6 83       	std	Z+6, r26	; 0x06
    2d9c:	b7 83       	std	Z+7, r27	; 0x07
    2d9e:	8c eb       	ldi	r24, 0xBC	; 188
    2da0:	90 e0       	ldi	r25, 0x00	; 0
    2da2:	91 83       	std	Z+1, r25	; 0x01
    2da4:	80 83       	st	Z, r24
    2da6:	eb e5       	ldi	r30, 0x5B	; 91
    2da8:	f3 e0       	ldi	r31, 0x03	; 3
    2daa:	13 82       	std	Z+3, r1	; 0x03
    2dac:	12 82       	std	Z+2, r1	; 0x02
    2dae:	8e ec       	ldi	r24, 0xCE	; 206
    2db0:	90 e0       	ldi	r25, 0x00	; 0
    2db2:	91 83       	std	Z+1, r25	; 0x01
    2db4:	80 83       	st	Z, r24
    2db6:	87 e2       	ldi	r24, 0x27	; 39
    2db8:	84 83       	std	Z+4, r24	; 0x04
    2dba:	80 e1       	ldi	r24, 0x10	; 16
    2dbc:	80 87       	std	Z+8, r24	; 0x08
    2dbe:	84 e0       	ldi	r24, 0x04	; 4
    2dc0:	81 87       	std	Z+9, r24	; 0x09
    2dc2:	12 86       	std	Z+10, r1	; 0x0a
    2dc4:	88 e0       	ldi	r24, 0x08	; 8
    2dc6:	83 87       	std	Z+11, r24	; 0x0b
    2dc8:	e5 e5       	ldi	r30, 0x55	; 85
    2dca:	f3 e0       	ldi	r31, 0x03	; 3
    2dcc:	11 82       	std	Z+1, r1	; 0x01
    2dce:	10 82       	st	Z, r1
    2dd0:	13 82       	std	Z+3, r1	; 0x03
    2dd2:	12 82       	std	Z+2, r1	; 0x02
    2dd4:	15 82       	std	Z+5, r1	; 0x05
    2dd6:	14 82       	std	Z+4, r1	; 0x04
    2dd8:	48 e0       	ldi	r20, 0x08	; 8
    2dda:	50 e0       	ldi	r21, 0x00	; 0
    2ddc:	6e ee       	ldi	r22, 0xEE	; 238
    2dde:	70 e0       	ldi	r23, 0x00	; 0
    2de0:	cf 01       	movw	r24, r30
    2de2:	0e 94 11 13 	call	0x2622	; 0x2622 <String::copy(char const*, unsigned int)>
    2de6:	ef e4       	ldi	r30, 0x4F	; 79
    2de8:	f3 e0       	ldi	r31, 0x03	; 3
    2dea:	11 82       	std	Z+1, r1	; 0x01
    2dec:	10 82       	st	Z, r1
    2dee:	13 82       	std	Z+3, r1	; 0x03
    2df0:	12 82       	std	Z+2, r1	; 0x02
    2df2:	15 82       	std	Z+5, r1	; 0x05
    2df4:	14 82       	std	Z+4, r1	; 0x04
    2df6:	4b e0       	ldi	r20, 0x0B	; 11
    2df8:	50 e0       	ldi	r21, 0x00	; 0
    2dfa:	67 ef       	ldi	r22, 0xF7	; 247
    2dfc:	70 e0       	ldi	r23, 0x00	; 0
    2dfe:	cf 01       	movw	r24, r30
    2e00:	0c 94 11 13 	jmp	0x2622	; 0x2622 <String::copy(char const*, unsigned int)>

00002e04 <main>:
main():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/main.cpp:34

//void setupUSB() __attribute__((weak));
//void setupUSB() { }

int main(void)
{
    2e04:	cf 93       	push	r28
    2e06:	df 93       	push	r29
    2e08:	cd b7       	in	r28, 0x3d	; 61
    2e0a:	de b7       	in	r29, 0x3e	; 62
    2e0c:	2a 97       	sbiw	r28, 0x0a	; 10
    2e0e:	0f b6       	in	r0, 0x3f	; 63
    2e10:	f8 94       	cli
    2e12:	de bf       	out	0x3e, r29	; 62
    2e14:	0f be       	out	0x3f, r0	; 63
    2e16:	cd bf       	out	0x3d, r28	; 61
init():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:945

void init()
{
  // this needs to be called before setup() or some functions won't
  // work there
  sei();
    2e18:	78 94       	sei
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:966
#if defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__)
  // CPU specific: different values for the ATmega64/128
  TCCR0 |= _BV(WGM01) | _BV(WGM00) | _BV(CS02);
#elif defined(TCCR0) && defined(CS01) && defined(CS00)
  // This combination is for the ATmega8535, ATmega8, ATmega16, ATmega32, ATmega8515, ATmega162
  TCCR0 |= _BV(CS01) | _BV(CS00);
    2e1a:	83 b7       	in	r24, 0x33	; 51
    2e1c:	83 60       	ori	r24, 0x03	; 3
    2e1e:	83 bf       	out	0x33, r24	; 51
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:968
  #if defined(WGM00) && defined(WGM01) // The ATmega8 doesn't have WGM00 and WGM01
    TCCR0 |= _BV(WGM01) | _BV(WGM00);
    2e20:	83 b7       	in	r24, 0x33	; 51
    2e22:	88 64       	ori	r24, 0x48	; 72
    2e24:	83 bf       	out	0x33, r24	; 51
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:982
  #error Timer 0 prescale factor 64 not set correctly
#endif

// Enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
  TIMSK |= _BV(TOIE0);
    2e26:	89 b7       	in	r24, 0x39	; 57
    2e28:	81 60       	ori	r24, 0x01	; 1
    2e2a:	89 bf       	out	0x39, r24	; 57
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:995
// this is better for motors as it ensures an even waveform
// note, however, that fast pwm mode can achieve a frequency of up
// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
  TCCR1B = _BV(CS11); // Set timer 1 prescale factor to 64
    2e2c:	82 e0       	ldi	r24, 0x02	; 2
    2e2e:	8e bd       	out	0x2e, r24	; 46
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:997
#if F_CPU >= 8000000L
  TCCR1B |= _BV(CS10);
    2e30:	8e b5       	in	r24, 0x2e	; 46
    2e32:	81 60       	ori	r24, 0x01	; 1
    2e34:	8e bd       	out	0x2e, r24	; 46
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:1006
#if F_CPU >= 8000000L
  TCCR1 |= _BV(CS10);
#endif
#endif
#if defined(TCCR1A) && defined(WGM10)
  TCCR1A |= _BV(WGM10); // Put timer 1 in 8-bit phase correct pwm mode
    2e36:	8f b5       	in	r24, 0x2f	; 47
    2e38:	81 60       	ori	r24, 0x01	; 1
    2e3a:	8f bd       	out	0x2f, r24	; 47
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:1011
#endif

// Set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
  TCCR2 |= _BV(CS22);
    2e3c:	85 b5       	in	r24, 0x25	; 37
    2e3e:	84 60       	ori	r24, 0x04	; 4
    2e40:	85 bd       	out	0x25, r24	; 37
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:1020
  TCCR2A |= _BV(CS22);
#endif

// Configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
  TCCR2 |= _BV(WGM20);
    2e42:	85 b5       	in	r24, 0x25	; 37
    2e44:	80 64       	ori	r24, 0x40	; 64
    2e46:	85 bd       	out	0x25, r24	; 37
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:1050
#endif

#if defined(ADCSRA)
  // set a2d prescaler so we are inside the desired 50-200 KHz range.
  #if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
    ADCSRA = _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADEN);
    2e48:	87 e8       	ldi	r24, 0x87	; 135
    2e4a:	86 b9       	out	0x06, r24	; 6
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/wiring.c:1068

  // The bootloader connects pins 0 and 1 to the USART; disconnect them
  // here so they can be used as normal digital i/o; they will be
  // reconnected in Serial.begin()
#if defined(UCSRB)
  UCSRB = 0;
    2e4c:	1a b8       	out	0x0a, r1	; 10
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:378
  // ----------------------------------------
  // INITIALIZATION
  // ----------------------------------------

  // Initialize RESET_ and WAIT_RES_
  pinMode(RESET_, OUTPUT);                        // Configure RESET_ and set it ACTIVE
    2e4e:	61 e0       	ldi	r22, 0x01	; 1
    2e50:	86 e1       	ldi	r24, 0x16	; 22
    2e52:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:379
  digitalWrite(RESET_, LOW);
    2e56:	60 e0       	ldi	r22, 0x00	; 0
    2e58:	86 e1       	ldi	r24, 0x16	; 22
    2e5a:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:380
  pinMode(WAIT_RES_, OUTPUT);                     // Configure WAIT_RES_ and set it ACTIVE to reset the WAIT FF (U1C/D)
    2e5e:	61 e0       	ldi	r22, 0x01	; 1
    2e60:	80 e0       	ldi	r24, 0x00	; 0
    2e62:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:381
  digitalWrite(WAIT_RES_, LOW);
    2e66:	60 e0       	ldi	r22, 0x00	; 0
    2e68:	80 e0       	ldi	r24, 0x00	; 0
    2e6a:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:384

  // Check USER Key for boot mode changes
  pinMode(USER, INPUT_PULLUP);                    // Read USER Key to enter into the boot mode selection
    2e6e:	62 e0       	ldi	r22, 0x02	; 2
    2e70:	8d e0       	ldi	r24, 0x0D	; 13
    2e72:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:385
  if (!digitalRead(USER)) bootSelection = 1;
    2e76:	8d e0       	ldi	r24, 0x0D	; 13
    2e78:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
    2e7c:	8c 01       	movw	r16, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:388

  // Initialize USER,  INT_, RAM_CE2, and BUSREQ_
  pinMode(USER, OUTPUT);                          // USER led OFF
    2e7e:	61 e0       	ldi	r22, 0x01	; 1
    2e80:	8d e0       	ldi	r24, 0x0D	; 13
    2e82:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:389
  digitalWrite(USER, HIGH);
    2e86:	61 e0       	ldi	r22, 0x01	; 1
    2e88:	8d e0       	ldi	r24, 0x0D	; 13
    2e8a:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:390
  pinMode(INT_, INPUT_PULLUP);                    // Configure INT_ and set it NOT ACTIVE
    2e8e:	62 e0       	ldi	r22, 0x02	; 2
    2e90:	81 e0       	ldi	r24, 0x01	; 1
    2e92:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:391
  pinMode(INT_, OUTPUT);
    2e96:	61 e0       	ldi	r22, 0x01	; 1
    2e98:	81 e0       	ldi	r24, 0x01	; 1
    2e9a:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:392
  digitalWrite(INT_, HIGH);
    2e9e:	61 e0       	ldi	r22, 0x01	; 1
    2ea0:	81 e0       	ldi	r24, 0x01	; 1
    2ea2:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:393
  pinMode(RAM_CE2, OUTPUT);                       // Configure RAM_CE2 as output
    2ea6:	61 e0       	ldi	r22, 0x01	; 1
    2ea8:	82 e0       	ldi	r24, 0x02	; 2
    2eaa:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:394
  digitalWrite(RAM_CE2, HIGH);                    // Set RAM_CE2 active
    2eae:	61 e0       	ldi	r22, 0x01	; 1
    2eb0:	82 e0       	ldi	r24, 0x02	; 2
    2eb2:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:395
  pinMode(WAIT_, INPUT);                          // Configure WAIT_ as input
    2eb6:	60 e0       	ldi	r22, 0x00	; 0
    2eb8:	83 e0       	ldi	r24, 0x03	; 3
    2eba:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:396
  pinMode(BUSREQ_, INPUT_PULLUP);                 // Set BUSREQ_ HIGH
    2ebe:	62 e0       	ldi	r22, 0x02	; 2
    2ec0:	8e e0       	ldi	r24, 0x0E	; 14
    2ec2:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:397
  pinMode(BUSREQ_, OUTPUT);
    2ec6:	61 e0       	ldi	r22, 0x01	; 1
    2ec8:	8e e0       	ldi	r24, 0x0E	; 14
    2eca:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:398
  digitalWrite(BUSREQ_, HIGH);
    2ece:	61 e0       	ldi	r22, 0x01	; 1
    2ed0:	8e e0       	ldi	r24, 0x0E	; 14
    2ed2:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:401

  // Initialize D0-D7, AD0, MREQ_, RD_ and WR_
  DDRA = 0x00;                                    // Configure Z80 data bus D0-D7 (PA0-PA7) as input with pull-up
    2ed6:	1a ba       	out	0x1a, r1	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:402
  PORTA = 0xFF;
    2ed8:	8f ef       	ldi	r24, 0xFF	; 255
    2eda:	8b bb       	out	0x1b, r24	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:403
  pinMode(MREQ_, INPUT_PULLUP);                   // Configure MREQ_ as input with pull-up
    2edc:	62 e0       	ldi	r22, 0x02	; 2
    2ede:	85 e1       	ldi	r24, 0x15	; 21
    2ee0:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:404
  pinMode(RD_, INPUT_PULLUP);                     // Configure RD_ as input with pull-up
    2ee4:	62 e0       	ldi	r22, 0x02	; 2
    2ee6:	84 e1       	ldi	r24, 0x14	; 20
    2ee8:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:405
  pinMode(WR_, INPUT_PULLUP);                     // Configure WR_ as input with pull-up
    2eec:	62 e0       	ldi	r22, 0x02	; 2
    2eee:	83 e1       	ldi	r24, 0x13	; 19
    2ef0:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:406
  pinMode(AD0, INPUT_PULLUP);
    2ef4:	62 e0       	ldi	r22, 0x02	; 2
    2ef6:	82 e1       	ldi	r24, 0x12	; 18
    2ef8:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:409

  // Initialize the Logical RAM Bank (32KB) to map into the lower half of the Z80 addressing space
  pinMode(BANK0, OUTPUT);                         // Set RAM Logical Bank 1 (Os Bank 0)
    2efc:	61 e0       	ldi	r22, 0x01	; 1
    2efe:	8c e0       	ldi	r24, 0x0C	; 12
    2f00:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:410
  digitalWrite(BANK0, HIGH);
    2f04:	61 e0       	ldi	r22, 0x01	; 1
    2f06:	8c e0       	ldi	r24, 0x0C	; 12
    2f08:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:411
  pinMode(BANK1, OUTPUT);
    2f0c:	61 e0       	ldi	r22, 0x01	; 1
    2f0e:	8b e0       	ldi	r24, 0x0B	; 11
    2f10:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:412
  digitalWrite(BANK1, LOW);
    2f14:	60 e0       	ldi	r22, 0x00	; 0
    2f16:	8b e0       	ldi	r24, 0x0B	; 11
    2f18:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:415

  // Initialize CLK (single clock pulses mode) and reset the Z80 CPU
  pinMode(CLK, OUTPUT);                           // Set CLK as output
    2f1c:	61 e0       	ldi	r22, 0x01	; 1
    2f1e:	8f e0       	ldi	r24, 0x0F	; 15
    2f20:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
singlePulsesResetZ80():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2628
// ------------------------------------------------------------------------------

void singlePulsesResetZ80()
// Reset the Z80 CPU using single pulses clock
{
  digitalWrite(RESET_, LOW);          // Set RESET_ active
    2f24:	60 e0       	ldi	r22, 0x00	; 0
    2f26:	86 e1       	ldi	r24, 0x16	; 22
    2f28:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2629
  pulseClock(6);                      // Generate twice the needed clock pulses to reset the Z80
    2f2c:	86 e0       	ldi	r24, 0x06	; 6
    2f2e:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2630
  digitalWrite(RESET_, HIGH);         // Set RESET_ not active
    2f32:	61 e0       	ldi	r22, 0x01	; 1
    2f34:	86 e1       	ldi	r24, 0x16	; 22
    2f36:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2631
  pulseClock(2);                      // Needed two more clock pulses after RESET_ goes HIGH
    2f3a:	82 e0       	ldi	r24, 0x02	; 2
    2f3c:	0e 94 17 10 	call	0x202e	; 0x202e <pulseClock(unsigned char)>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:419
  // Initialize CLK (single clock pulses mode) and reset the Z80 CPU
  pinMode(CLK, OUTPUT);                           // Set CLK as output
  singlePulsesResetZ80();                         // Reset the Z80 CPU using single clock pulses

  // Initialize MCU_RTS and MCU_CTS and reset uTerm (A071218-R250119) if present
  pinMode(MCU_CTS_, INPUT_PULLUP);                // Parked (not used)
    2f40:	62 e0       	ldi	r22, 0x02	; 2
    2f42:	8a e0       	ldi	r24, 0x0A	; 10
    2f44:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:420
  pinMode(MCU_RTS_, OUTPUT);
    2f48:	61 e0       	ldi	r22, 0x01	; 1
    2f4a:	87 e1       	ldi	r24, 0x17	; 23
    2f4c:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:421
  digitalWrite(MCU_RTS_, LOW);                    // Reset the uTerm optional add-on board
    2f50:	60 e0       	ldi	r22, 0x00	; 0
    2f52:	87 e1       	ldi	r24, 0x17	; 23
    2f54:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:422
  delay(100);
    2f58:	64 e6       	ldi	r22, 0x64	; 100
    2f5a:	70 e0       	ldi	r23, 0x00	; 0
    2f5c:	80 e0       	ldi	r24, 0x00	; 0
    2f5e:	90 e0       	ldi	r25, 0x00	; 0
    2f60:	0e 94 07 07 	call	0xe0e	; 0xe0e <delay>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:423
  digitalWrite(MCU_RTS_, HIGH);
    2f64:	61 e0       	ldi	r22, 0x01	; 1
    2f66:	87 e1       	ldi	r24, 0x17	; 23
    2f68:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:424
  delay(500);
    2f6c:	64 ef       	ldi	r22, 0xF4	; 244
    2f6e:	71 e0       	ldi	r23, 0x01	; 1
    2f70:	80 e0       	ldi	r24, 0x00	; 0
    2f72:	90 e0       	ldi	r25, 0x00	; 0
    2f74:	0e 94 07 07 	call	0xe0e	; 0xe0e <delay>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:427

  // Read the Z80 CPU speed mode
  if (EEPROM.read(clockModeAddr) > 1)             // Check if it is a valid value, otherwise set it to low speed
    2f78:	8d e0       	ldi	r24, 0x0D	; 13
    2f7a:	90 e0       	ldi	r25, 0x00	; 0
    2f7c:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
    2f80:	82 30       	cpi	r24, 0x02	; 2
    2f82:	28 f0       	brcs	.+10     	; 0x2f8e <main+0x18a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:430
    // Not a valid value. Set it to low speed
  {
    EEPROM.update(clockModeAddr, 1);
    2f84:	61 e0       	ldi	r22, 0x01	; 1
    2f86:	8d e0       	ldi	r24, 0x0D	; 13
    2f88:	90 e0       	ldi	r25, 0x00	; 0
    2f8a:	0e 94 b7 13 	call	0x276e	; 0x276e <EEPROMClass::update(int, unsigned char) [clone .isra.2]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:432
  }
  clockMode = EEPROM.read(clockModeAddr);         // Read the previous stored value
    2f8e:	8d e0       	ldi	r24, 0x0D	; 13
    2f90:	90 e0       	ldi	r25, 0x00	; 0
    2f92:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
    2f96:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <clockMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:435

  // Read the stored Disk Set. If not valid set it to 0
  diskSet = EEPROM.read(diskSetAddr);
    2f9a:	8e e0       	ldi	r24, 0x0E	; 14
    2f9c:	90 e0       	ldi	r25, 0x00	; 0
    2f9e:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
    2fa2:	80 93 f6 01 	sts	0x01F6, r24	; 0x8001f6 <diskSet>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:436
  if (diskSet >= maxDiskSet)
    2fa6:	86 30       	cpi	r24, 0x06	; 6
    2fa8:	38 f0       	brcs	.+14     	; 0x2fb8 <main+0x1b4>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:438
  {
    EEPROM.update(diskSetAddr, 0);
    2faa:	60 e0       	ldi	r22, 0x00	; 0
    2fac:	8e e0       	ldi	r24, 0x0E	; 14
    2fae:	90 e0       	ldi	r25, 0x00	; 0
    2fb0:	0e 94 b7 13 	call	0x276e	; 0x276e <EEPROMClass::update(int, unsigned char) [clone .isra.2]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:439
    diskSet = 0;
    2fb4:	10 92 f6 01 	sts	0x01F6, r1	; 0x8001f6 <diskSet>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:443
  }

  // Initialize the EXP_PORT (I2C) and search for "known" optional modules
  Wire.begin();                                   // Wake up I2C bus
    2fb8:	0e 94 70 06 	call	0xce0	; 0xce0 <TwoWire::begin() [clone .constprop.6]>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    2fbc:	80 e2       	ldi	r24, 0x20	; 32
    2fbe:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:445
  Wire.beginTransmission(GPIOEXP_ADDR);
  if (Wire.endTransmission() == 0)
    2fc2:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
    2fc6:	81 11       	cpse	r24, r1
    2fc8:	10 c0       	rjmp	.+32     	; 0x2fea <main+0x1e6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:448
    // Found GPE expansion
  {
    moduleGPIO = 1;                               // Set to 1 if GPIO Module is found
    2fca:	81 e0       	ldi	r24, 0x01	; 1
    2fcc:	80 93 f7 01 	sts	0x01F7, r24	; 0x8001f7 <moduleGPIO>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    2fd0:	80 e2       	ldi	r24, 0x20	; 32
    2fd2:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:453
    // Set pullup enabled for GPA0 and GPA2:
    //  this just in case the SPP adapter is used and a printer is connected and powered on before the Z80-MBC2,
    //  to avoid a possible "strange" behavior of the printer (GPA0 = STROBE_, GPA2 = INIT_. See SPP Adapter schematic)
    Wire.beginTransmission(GPIOEXP_ADDR);
    Wire.write(GPPUA_REG);                        // Select GPPUA
    2fd6:	8c e0       	ldi	r24, 0x0C	; 12
    2fd8:	90 e0       	ldi	r25, 0x00	; 0
    2fda:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:454
    Wire.write(0b00000101);                       // Write value (1 = pullup enabled, 0 = pullup disabled)
    2fde:	85 e0       	ldi	r24, 0x05	; 5
    2fe0:	90 e0       	ldi	r25, 0x00	; 0
    2fe2:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:455
    Wire.endTransmission();
    2fe6:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
begin():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:35
	_charsize = charsize;
	_backlightval = LCD_BACKLIGHT;
}

void LiquidCrystal_I2C::begin() {
	Wire.begin();
    2fea:	0e 94 70 06 	call	0xce0	; 0xce0 <TwoWire::begin() [clone .constprop.6]>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:36
	_displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
    2fee:	10 92 60 03 	sts	0x0360, r1	; 0x800360 <lcd+0x5>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:38

	if (_rows > 1) {
    2ff2:	80 91 64 03 	lds	r24, 0x0364	; 0x800364 <lcd+0x9>
    2ff6:	82 30       	cpi	r24, 0x02	; 2
    2ff8:	18 f0       	brcs	.+6      	; 0x3000 <main+0x1fc>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:39
		_displayfunction |= LCD_2LINE;
    2ffa:	98 e0       	ldi	r25, 0x08	; 8
    2ffc:	90 93 60 03 	sts	0x0360, r25	; 0x800360 <lcd+0x5>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:43
	}

	// for some 1 line displays you can select a 10 pixel high font
	if ((_charsize != 0) && (_rows == 1)) {
    3000:	90 91 65 03 	lds	r25, 0x0365	; 0x800365 <lcd+0xa>
    3004:	99 23       	and	r25, r25
    3006:	39 f0       	breq	.+14     	; 0x3016 <main+0x212>
    3008:	81 30       	cpi	r24, 0x01	; 1
    300a:	29 f4       	brne	.+10     	; 0x3016 <main+0x212>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:44
		_displayfunction |= LCD_5x10DOTS;
    300c:	80 91 60 03 	lds	r24, 0x0360	; 0x800360 <lcd+0x5>
    3010:	84 60       	ori	r24, 0x04	; 4
    3012:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <lcd+0x5>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:50
	}

	// SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
	// according to datasheet, we need at least 40ms after power rises above 2.7V
	// before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50
	delay(50); 
    3016:	62 e3       	ldi	r22, 0x32	; 50
    3018:	70 e0       	ldi	r23, 0x00	; 0
    301a:	80 e0       	ldi	r24, 0x00	; 0
    301c:	90 e0       	ldi	r25, 0x00	; 0
    301e:	0e 94 07 07 	call	0xe0e	; 0xe0e <delay>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:53

	// Now we pull both RS and R/W low to begin commands
	expanderWrite(_backlightval);	// reset expanderand turn backlight off (Bit 8 =1)
    3022:	60 91 66 03 	lds	r22, 0x0366	; 0x800366 <lcd+0xb>
    3026:	8b e5       	ldi	r24, 0x5B	; 91
    3028:	93 e0       	ldi	r25, 0x03	; 3
    302a:	0e 94 ed 07 	call	0xfda	; 0xfda <LiquidCrystal_I2C::expanderWrite(unsigned char)>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:54
	delay(1000);
    302e:	68 ee       	ldi	r22, 0xE8	; 232
    3030:	73 e0       	ldi	r23, 0x03	; 3
    3032:	80 e0       	ldi	r24, 0x00	; 0
    3034:	90 e0       	ldi	r25, 0x00	; 0
    3036:	0e 94 07 07 	call	0xe0e	; 0xe0e <delay>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:61
	//put the LCD into 4 bit mode
	// this is according to the hitachi HD44780 datasheet
	// figure 24, pg 46

	// we start in 8bit mode, try to set 4 bit mode
	write4bits(0x03 << 4);
    303a:	60 e3       	ldi	r22, 0x30	; 48
    303c:	8b e5       	ldi	r24, 0x5B	; 91
    303e:	93 e0       	ldi	r25, 0x03	; 3
    3040:	0e 94 01 08 	call	0x1002	; 0x1002 <LiquidCrystal_I2C::write4bits(unsigned char)>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:62
	delayMicroseconds(4500); // wait min 4.1ms
    3044:	84 e9       	ldi	r24, 0x94	; 148
    3046:	91 e1       	ldi	r25, 0x11	; 17
    3048:	0e 94 d6 06 	call	0xdac	; 0xdac <delayMicroseconds>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:65

	// second try
	write4bits(0x03 << 4);
    304c:	60 e3       	ldi	r22, 0x30	; 48
    304e:	8b e5       	ldi	r24, 0x5B	; 91
    3050:	93 e0       	ldi	r25, 0x03	; 3
    3052:	0e 94 01 08 	call	0x1002	; 0x1002 <LiquidCrystal_I2C::write4bits(unsigned char)>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:66
	delayMicroseconds(4500); // wait min 4.1ms
    3056:	84 e9       	ldi	r24, 0x94	; 148
    3058:	91 e1       	ldi	r25, 0x11	; 17
    305a:	0e 94 d6 06 	call	0xdac	; 0xdac <delayMicroseconds>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:69

	// third go!
	write4bits(0x03 << 4); 
    305e:	60 e3       	ldi	r22, 0x30	; 48
    3060:	8b e5       	ldi	r24, 0x5B	; 91
    3062:	93 e0       	ldi	r25, 0x03	; 3
    3064:	0e 94 01 08 	call	0x1002	; 0x1002 <LiquidCrystal_I2C::write4bits(unsigned char)>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:70
	delayMicroseconds(150);
    3068:	86 e9       	ldi	r24, 0x96	; 150
    306a:	90 e0       	ldi	r25, 0x00	; 0
    306c:	0e 94 d6 06 	call	0xdac	; 0xdac <delayMicroseconds>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:73

	// finally, set to 4-bit interface
	write4bits(0x02 << 4); 
    3070:	60 e2       	ldi	r22, 0x20	; 32
    3072:	8b e5       	ldi	r24, 0x5B	; 91
    3074:	93 e0       	ldi	r25, 0x03	; 3
    3076:	0e 94 01 08 	call	0x1002	; 0x1002 <LiquidCrystal_I2C::write4bits(unsigned char)>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:76

	// set # lines, font size, etc.
	command(LCD_FUNCTIONSET | _displayfunction);  
    307a:	60 91 60 03 	lds	r22, 0x0360	; 0x800360 <lcd+0x5>
    307e:	60 62       	ori	r22, 0x20	; 32
command():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:199
}

/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystal_I2C::command(uint8_t value) {
	send(value, 0);
    3080:	40 e0       	ldi	r20, 0x00	; 0
    3082:	8b e5       	ldi	r24, 0x5B	; 91
    3084:	93 e0       	ldi	r25, 0x03	; 3
    3086:	0e 94 1d 08 	call	0x103a	; 0x103a <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
begin():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:79

	// set # lines, font size, etc.
	command(LCD_FUNCTIONSET | _displayfunction);  
	
	// turn the display on with no cursor or blinking default
	_displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
    308a:	84 e0       	ldi	r24, 0x04	; 4
    308c:	80 93 61 03 	sts	0x0361, r24	; 0x800361 <lcd+0x6>
command():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:199
}

/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystal_I2C::command(uint8_t value) {
	send(value, 0);
    3090:	40 e0       	ldi	r20, 0x00	; 0
    3092:	6c e0       	ldi	r22, 0x0C	; 12
    3094:	8b e5       	ldi	r24, 0x5B	; 91
    3096:	93 e0       	ldi	r25, 0x03	; 3
    3098:	0e 94 1d 08 	call	0x103a	; 0x103a <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
    309c:	40 e0       	ldi	r20, 0x00	; 0
    309e:	61 e0       	ldi	r22, 0x01	; 1
    30a0:	8b e5       	ldi	r24, 0x5B	; 91
    30a2:	93 e0       	ldi	r25, 0x03	; 3
    30a4:	0e 94 1d 08 	call	0x103a	; 0x103a <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
clear():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:97
}

/********** high level commands, for the user! */
void LiquidCrystal_I2C::clear(){
	command(LCD_CLEARDISPLAY);// clear display, set cursor position to zero
	delayMicroseconds(2000);  // this command takes a long time!
    30a8:	80 ed       	ldi	r24, 0xD0	; 208
    30aa:	97 e0       	ldi	r25, 0x07	; 7
    30ac:	0e 94 d6 06 	call	0xdac	; 0xdac <delayMicroseconds>
begin():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:86
	
	// clear it off
	clear();
	
	// Initialize to default text direction (for roman languages)
	_displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
    30b0:	82 e0       	ldi	r24, 0x02	; 2
    30b2:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <lcd+0x7>
command():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:199
}

/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystal_I2C::command(uint8_t value) {
	send(value, 0);
    30b6:	40 e0       	ldi	r20, 0x00	; 0
    30b8:	66 e0       	ldi	r22, 0x06	; 6
    30ba:	8b e5       	ldi	r24, 0x5B	; 91
    30bc:	93 e0       	ldi	r25, 0x03	; 3
    30be:	0e 94 1d 08 	call	0x103a	; 0x103a <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
    30c2:	40 e0       	ldi	r20, 0x00	; 0
    30c4:	62 e0       	ldi	r22, 0x02	; 2
    30c6:	8b e5       	ldi	r24, 0x5B	; 91
    30c8:	93 e0       	ldi	r25, 0x03	; 3
    30ca:	0e 94 1d 08 	call	0x103a	; 0x103a <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
home():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:102
	delayMicroseconds(2000);  // this command takes a long time!
}

void LiquidCrystal_I2C::home(){
	command(LCD_RETURNHOME);  // set cursor position to zero
	delayMicroseconds(2000);  // this command takes a long time!
    30ce:	80 ed       	ldi	r24, 0xD0	; 208
    30d0:	97 e0       	ldi	r25, 0x07	; 7
    30d2:	0e 94 d6 06 	call	0xdac	; 0xdac <delayMicroseconds>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:461
  }

  lcd.begin();

  // Check the serial speed index and set it to the default if needed
  if (EEPROM.read(serBaudAddr) >= maxBaudIndex)
    30d6:	8f e0       	ldi	r24, 0x0F	; 15
    30d8:	90 e0       	ldi	r25, 0x00	; 0
    30da:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
    30de:	8a 30       	cpi	r24, 0x0A	; 10
    30e0:	28 f0       	brcs	.+10     	; 0x30ec <main+0x2e8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:464
    // Invalid value. Set it to the default 115200 index
  {
    EEPROM.update(serBaudAddr, 9);
    30e2:	69 e0       	ldi	r22, 0x09	; 9
    30e4:	8f e0       	ldi	r24, 0x0F	; 15
    30e6:	90 e0       	ldi	r25, 0x00	; 0
    30e8:	0e 94 b7 13 	call	0x276e	; 0x276e <EEPROMClass::update(int, unsigned char) [clone .isra.2]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:468
  }

  // Print some system information
  Serial.begin(indexToBaud(EEPROM.read(serBaudAddr)));
    30ec:	8f e0       	ldi	r24, 0x0F	; 15
    30ee:	90 e0       	ldi	r25, 0x00	; 0
    30f0:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
    30f4:	c1 2c       	mov	r12, r1
    30f6:	22 ec       	ldi	r18, 0xC2	; 194
    30f8:	d2 2e       	mov	r13, r18
    30fa:	ee 24       	eor	r14, r14
    30fc:	e3 94       	inc	r14
    30fe:	f1 2c       	mov	r15, r1
    3100:	89 30       	cpi	r24, 0x09	; 9
    3102:	50 f4       	brcc	.+20     	; 0x3118 <main+0x314>
    3104:	e8 2f       	mov	r30, r24
    3106:	f0 e0       	ldi	r31, 0x00	; 0
    3108:	ee 0f       	add	r30, r30
    310a:	ff 1f       	adc	r31, r31
    310c:	ec 56       	subi	r30, 0x6C	; 108
    310e:	ff 4f       	sbci	r31, 0xFF	; 255
    3110:	c0 80       	ld	r12, Z
    3112:	d1 80       	ldd	r13, Z+1	; 0x01
    3114:	f1 2c       	mov	r15, r1
    3116:	e1 2c       	mov	r14, r1
begin():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:120
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    3118:	60 e0       	ldi	r22, 0x00	; 0
    311a:	79 e0       	ldi	r23, 0x09	; 9
    311c:	8d e3       	ldi	r24, 0x3D	; 61
    311e:	90 e0       	ldi	r25, 0x00	; 0
    3120:	a7 01       	movw	r20, r14
    3122:	96 01       	movw	r18, r12
    3124:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <__udivmodsi4>
    3128:	21 50       	subi	r18, 0x01	; 1
    312a:	31 09       	sbc	r19, r1
    312c:	41 09       	sbc	r20, r1
    312e:	51 09       	sbc	r21, r1
    3130:	56 95       	lsr	r21
    3132:	47 95       	ror	r20
    3134:	37 95       	ror	r19
    3136:	27 95       	ror	r18
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:121
  *_ucsra = 1 << U2X0;
    3138:	e0 91 b6 02 	lds	r30, 0x02B6	; 0x8002b6 <Serial+0x10>
    313c:	f0 91 b7 02 	lds	r31, 0x02B7	; 0x8002b7 <Serial+0x11>
    3140:	82 e0       	ldi	r24, 0x02	; 2
    3142:	80 83       	st	Z, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:128
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3144:	c1 14       	cp	r12, r1
    3146:	41 ee       	ldi	r20, 0xE1	; 225
    3148:	d4 06       	cpc	r13, r20
    314a:	e1 04       	cpc	r14, r1
    314c:	f1 04       	cpc	r15, r1
    314e:	21 f0       	breq	.+8      	; 0x3158 <main+0x354>
    3150:	21 15       	cp	r18, r1
    3152:	50 e1       	ldi	r21, 0x10	; 16
    3154:	35 07       	cpc	r19, r21
    3156:	a8 f0       	brcs	.+42     	; 0x3182 <main+0x37e>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:130
  {
    *_ucsra = 0;
    3158:	e0 91 b6 02 	lds	r30, 0x02B6	; 0x8002b6 <Serial+0x10>
    315c:	f0 91 b7 02 	lds	r31, 0x02B7	; 0x8002b7 <Serial+0x11>
    3160:	10 82       	st	Z, r1
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:131
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    3162:	60 e8       	ldi	r22, 0x80	; 128
    3164:	74 e8       	ldi	r23, 0x84	; 132
    3166:	8e e1       	ldi	r24, 0x1E	; 30
    3168:	90 e0       	ldi	r25, 0x00	; 0
    316a:	a7 01       	movw	r20, r14
    316c:	96 01       	movw	r18, r12
    316e:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <__udivmodsi4>
    3172:	21 50       	subi	r18, 0x01	; 1
    3174:	31 09       	sbc	r19, r1
    3176:	41 09       	sbc	r20, r1
    3178:	51 09       	sbc	r21, r1
    317a:	56 95       	lsr	r21
    317c:	47 95       	ror	r20
    317e:	37 95       	ror	r19
    3180:	27 95       	ror	r18
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:135
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    3182:	e0 91 b2 02 	lds	r30, 0x02B2	; 0x8002b2 <Serial+0xc>
    3186:	f0 91 b3 02 	lds	r31, 0x02B3	; 0x8002b3 <Serial+0xd>
    318a:	30 83       	st	Z, r19
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:136
  *_ubrrl = baud_setting;
    318c:	e0 91 b4 02 	lds	r30, 0x02B4	; 0x8002b4 <Serial+0xe>
    3190:	f0 91 b5 02 	lds	r31, 0x02B5	; 0x8002b5 <Serial+0xf>
    3194:	20 83       	st	Z, r18
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:138

  _written = false;
    3196:	10 92 be 02 	sts	0x02BE, r1	; 0x8002be <Serial+0x18>
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:146
#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega8515__) || defined(__AVR_ATmega162__) \
|| defined(__AVR_ATmega8535__) || defined(__AVR_ATmega16__)|| defined(__AVR_ATmega32__)   \
|| defined(__AVR_ATmega162__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    319a:	e0 91 ba 02 	lds	r30, 0x02BA	; 0x8002ba <Serial+0x14>
    319e:	f0 91 bb 02 	lds	r31, 0x02BB	; 0x8002bb <Serial+0x15>
    31a2:	86 e8       	ldi	r24, 0x86	; 134
    31a4:	80 83       	st	Z, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:148
  
  *_ucsrb |= _BV(RXEN0) | _BV(TXEN0) | _BV(RXCIE0);
    31a6:	e0 91 b8 02 	lds	r30, 0x02B8	; 0x8002b8 <Serial+0x12>
    31aa:	f0 91 b9 02 	lds	r31, 0x02B9	; 0x8002b9 <Serial+0x13>
    31ae:	80 81       	ld	r24, Z
    31b0:	88 69       	ori	r24, 0x98	; 152
    31b2:	80 83       	st	Z, r24
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:149
  *_ucsrb &= ~_BV(UDRIE0);
    31b4:	e0 91 b8 02 	lds	r30, 0x02B8	; 0x8002b8 <Serial+0x12>
    31b8:	f0 91 b9 02 	lds	r31, 0x02B9	; 0x8002b9 <Serial+0x13>
    31bc:	80 81       	ld	r24, Z
    31be:	8f 7d       	andi	r24, 0xDF	; 223
    31c0:	80 83       	st	Z, r24
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:469
  Serial.println(F("\r\n\nZ80-MBC2 - A040618\r\nIOS - I/O Subsystem - S220718-R290823\r\n"));
    31c2:	83 ec       	ldi	r24, 0xC3	; 195
    31c4:	97 e0       	ldi	r25, 0x07	; 7
    31c6:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:475

  // Print if the input serial buffer is 128 bytes wide (this is needed for xmodem protocol support)
  if (SERIAL_RX_BUFFER_SIZE >= 128) Serial.println(F("IOS: Found extended serial Rx buffer"));

  // Print the Z80 clock speed mode
  Serial.print(F("IOS: Z80 clock set at "));
    31ca:	8c ea       	ldi	r24, 0xAC	; 172
    31cc:	97 e0       	ldi	r25, 0x07	; 7
    31ce:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:476
  if (clockMode) Serial.print(CLOCK_LOW);
    31d2:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <clockMode>
    31d6:	63 e0       	ldi	r22, 0x03	; 3
    31d8:	71 e0       	ldi	r23, 0x01	; 1
    31da:	81 11       	cpse	r24, r1
    31dc:	02 c0       	rjmp	.+4      	; 0x31e2 <main+0x3de>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:477
  else Serial.print(CLOCK_HIGH);
    31de:	65 e0       	ldi	r22, 0x05	; 5
    31e0:	71 e0       	ldi	r23, 0x01	; 1
    31e2:	86 ea       	ldi	r24, 0xA6	; 166
    31e4:	92 e0       	ldi	r25, 0x02	; 2
    31e6:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:478
  Serial.println(F("MHz"));
    31ea:	88 ea       	ldi	r24, 0xA8	; 168
    31ec:	97 e0       	ldi	r25, 0x07	; 7
    31ee:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    31f2:	88 e6       	ldi	r24, 0x68	; 104
    31f4:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
autoSetRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2266
// Return value: 0 if RTC not present, 1 if found.
{
  byte    OscStopFlag;

  Wire.beginTransmission(DS3231_RTC);
  if (Wire.endTransmission() != 0) return 0;      // RTC not found
    31f8:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
    31fc:	81 11       	cpse	r24, r1
    31fe:	2f c1       	rjmp	.+606    	; 0x345e <main+0x65a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2267
  Serial.print(F("IOS: Found RTC DS3231 Module ("));
    3200:	81 e8       	ldi	r24, 0x81	; 129
    3202:	94 e0       	ldi	r25, 0x04	; 4
    3204:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2268
  printDateTime(1);
    3208:	81 e0       	ldi	r24, 0x01	; 1
    320a:	0e 94 c5 12 	call	0x258a	; 0x258a <printDateTime(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2269
  Serial.println(")");
    320e:	8c ed       	ldi	r24, 0xDC	; 220
    3210:	90 e0       	ldi	r25, 0x00	; 0
    3212:	0e 94 02 12 	call	0x2404	; 0x2404 <Print::println(char const*) [clone .constprop.48]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2272

  // Print the temperaturefrom the RTC sensor
  Serial.print(F("IOS: RTC DS3231 temperature sensor: "));
    3216:	8c e5       	ldi	r24, 0x5C	; 92
    3218:	94 e0       	ldi	r25, 0x04	; 4
    321a:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2273
  Serial.print((int8_t)tempC);
    321e:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <tempC>
    3222:	08 2e       	mov	r0, r24
    3224:	00 0c       	add	r0, r0
    3226:	99 0b       	sbc	r25, r25
    3228:	0e 94 a8 11 	call	0x2350	; 0x2350 <Print::print(int, int) [clone .constprop.16]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2274
  Serial.println("C");
    322c:	87 e0       	ldi	r24, 0x07	; 7
    322e:	91 e0       	ldi	r25, 0x01	; 1
    3230:	0e 94 02 12 	call	0x2404	; 0x2404 <Print::println(char const*) [clone .constprop.48]>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    3234:	88 e6       	ldi	r24, 0x68	; 104
    3236:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
autoSetRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2278

  // Read the "Oscillator Stop Flag"
  Wire.beginTransmission(DS3231_RTC);
  Wire.write(DS3231_STATRG);                      // Set the DS3231 Status Register
    323a:	8f e0       	ldi	r24, 0x0F	; 15
    323c:	90 e0       	ldi	r25, 0x00	; 0
    323e:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2279
  Wire.endTransmission();
    3242:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2280
  Wire.requestFrom(DS3231_RTC, 1);
    3246:	61 e0       	ldi	r22, 0x01	; 1
    3248:	70 e0       	ldi	r23, 0x00	; 0
    324a:	88 e6       	ldi	r24, 0x68	; 104
    324c:	90 e0       	ldi	r25, 0x00	; 0
    324e:	0e 94 b0 10 	call	0x2160	; 0x2160 <TwoWire::requestFrom(int, int) [clone .constprop.21]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2281
  OscStopFlag = Wire.read() & 0x80;               // Read the "Oscillator Stop Flag"
    3252:	0e 94 b7 04 	call	0x96e	; 0x96e <TwoWire::read() [clone .constprop.26]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2283

  if (OscStopFlag)
    3256:	87 ff       	sbrs	r24, 7
    3258:	de c0       	rjmp	.+444    	; 0x3416 <main+0x612>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2287
    // RTC oscillator stopped. RTC must be set at compile date/time
  {
    // Convert compile time strings to numeric values
    seconds = compTimeStr.substring(6, 8).toInt();
    325a:	28 e0       	ldi	r18, 0x08	; 8
    325c:	30 e0       	ldi	r19, 0x00	; 0
    325e:	46 e0       	ldi	r20, 0x06	; 6
    3260:	50 e0       	ldi	r21, 0x00	; 0
    3262:	65 e5       	ldi	r22, 0x55	; 85
    3264:	73 e0       	ldi	r23, 0x03	; 3
    3266:	ce 01       	movw	r24, r28
    3268:	01 96       	adiw	r24, 0x01	; 1
    326a:	0e 94 50 13 	call	0x26a0	; 0x26a0 <String::substring(unsigned int, unsigned int) const>
    326e:	ce 01       	movw	r24, r28
    3270:	01 96       	adiw	r24, 0x01	; 1
    3272:	0e 94 fe 12 	call	0x25fc	; 0x25fc <String::toInt() const>
    3276:	60 93 27 02 	sts	0x0227, r22	; 0x800227 <seconds>
    327a:	ce 01       	movw	r24, r28
    327c:	01 96       	adiw	r24, 0x01	; 1
    327e:	0e 94 09 13 	call	0x2612	; 0x2612 <String::~String()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2288
    minutes = compTimeStr.substring(3, 5).toInt();
    3282:	25 e0       	ldi	r18, 0x05	; 5
    3284:	30 e0       	ldi	r19, 0x00	; 0
    3286:	43 e0       	ldi	r20, 0x03	; 3
    3288:	50 e0       	ldi	r21, 0x00	; 0
    328a:	65 e5       	ldi	r22, 0x55	; 85
    328c:	73 e0       	ldi	r23, 0x03	; 3
    328e:	ce 01       	movw	r24, r28
    3290:	01 96       	adiw	r24, 0x01	; 1
    3292:	0e 94 50 13 	call	0x26a0	; 0x26a0 <String::substring(unsigned int, unsigned int) const>
    3296:	ce 01       	movw	r24, r28
    3298:	01 96       	adiw	r24, 0x01	; 1
    329a:	0e 94 fe 12 	call	0x25fc	; 0x25fc <String::toInt() const>
    329e:	60 93 26 02 	sts	0x0226, r22	; 0x800226 <minutes>
    32a2:	ce 01       	movw	r24, r28
    32a4:	01 96       	adiw	r24, 0x01	; 1
    32a6:	0e 94 09 13 	call	0x2612	; 0x2612 <String::~String()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2289
    hours = compTimeStr.substring(0, 2).toInt();
    32aa:	22 e0       	ldi	r18, 0x02	; 2
    32ac:	30 e0       	ldi	r19, 0x00	; 0
    32ae:	50 e0       	ldi	r21, 0x00	; 0
    32b0:	40 e0       	ldi	r20, 0x00	; 0
    32b2:	65 e5       	ldi	r22, 0x55	; 85
    32b4:	73 e0       	ldi	r23, 0x03	; 3
    32b6:	ce 01       	movw	r24, r28
    32b8:	01 96       	adiw	r24, 0x01	; 1
    32ba:	0e 94 50 13 	call	0x26a0	; 0x26a0 <String::substring(unsigned int, unsigned int) const>
    32be:	ce 01       	movw	r24, r28
    32c0:	01 96       	adiw	r24, 0x01	; 1
    32c2:	0e 94 fe 12 	call	0x25fc	; 0x25fc <String::toInt() const>
    32c6:	60 93 25 02 	sts	0x0225, r22	; 0x800225 <hours>
    32ca:	ce 01       	movw	r24, r28
    32cc:	01 96       	adiw	r24, 0x01	; 1
    32ce:	0e 94 09 13 	call	0x2612	; 0x2612 <String::~String()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2290
    day = compDateStr.substring(4, 6).toInt();
    32d2:	26 e0       	ldi	r18, 0x06	; 6
    32d4:	30 e0       	ldi	r19, 0x00	; 0
    32d6:	44 e0       	ldi	r20, 0x04	; 4
    32d8:	50 e0       	ldi	r21, 0x00	; 0
    32da:	6f e4       	ldi	r22, 0x4F	; 79
    32dc:	73 e0       	ldi	r23, 0x03	; 3
    32de:	ce 01       	movw	r24, r28
    32e0:	01 96       	adiw	r24, 0x01	; 1
    32e2:	0e 94 50 13 	call	0x26a0	; 0x26a0 <String::substring(unsigned int, unsigned int) const>
    32e6:	ce 01       	movw	r24, r28
    32e8:	01 96       	adiw	r24, 0x01	; 1
    32ea:	0e 94 fe 12 	call	0x25fc	; 0x25fc <String::toInt() const>
    32ee:	60 93 02 02 	sts	0x0202, r22	; 0x800202 <day>
    32f2:	ce 01       	movw	r24, r28
    32f4:	01 96       	adiw	r24, 0x01	; 1
    32f6:	0e 94 09 13 	call	0x2612	; 0x2612 <String::~String()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2291
    switch (compDateStr[0])
    32fa:	90 e0       	ldi	r25, 0x00	; 0
    32fc:	80 e0       	ldi	r24, 0x00	; 0
    32fe:	0e 94 ca 04 	call	0x994	; 0x994 <String::operator[](unsigned int) const [clone .constprop.14]>
    3302:	ef eb       	ldi	r30, 0xBF	; 191
    3304:	e8 0f       	add	r30, r24
    3306:	e3 31       	cpi	r30, 0x13	; 19
    3308:	58 f5       	brcc	.+86     	; 0x3360 <main+0x55c>
    330a:	0e 2e       	mov	r0, r30
    330c:	00 0c       	add	r0, r0
    330e:	ff 0b       	sbc	r31, r31
    3310:	e4 57       	subi	r30, 0x74	; 116
    3312:	f6 4e       	sbci	r31, 0xE6	; 230
    3314:	0c 94 9c 25 	jmp	0x4b38	; 0x4b38 <__tablejump2__>
    3318:	13 1a       	sub	r1, r19
    331a:	b0 19       	sub	r27, r0
    331c:	b0 19       	sub	r27, r0
    331e:	2d 1a       	sub	r2, r29
    3320:	b0 19       	sub	r27, r0
    3322:	11 1a       	sub	r1, r17
    3324:	b0 19       	sub	r27, r0
    3326:	b0 19       	sub	r27, r0
    3328:	b0 19       	sub	r27, r0
    332a:	9f 19       	sub	r25, r15
    332c:	b0 19       	sub	r27, r0
    332e:	b0 19       	sub	r27, r0
    3330:	1d 1a       	sub	r1, r29
    3332:	2b 1a       	sub	r2, r27
    3334:	29 1a       	sub	r2, r25
    3336:	b0 19       	sub	r27, r0
    3338:	b0 19       	sub	r27, r0
    333a:	b0 19       	sub	r27, r0
    333c:	27 1a       	sub	r2, r23
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2293
    {
      case 'J': month = compDateStr[1] == 'a' ? 1 : month = compDateStr[2] == 'n' ? 6 : 7; break;
    333e:	81 e0       	ldi	r24, 0x01	; 1
    3340:	90 e0       	ldi	r25, 0x00	; 0
    3342:	0e 94 ca 04 	call	0x994	; 0x994 <String::operator[](unsigned int) const [clone .constprop.14]>
    3346:	81 36       	cpi	r24, 0x61	; 97
    3348:	09 f4       	brne	.+2      	; 0x334c <main+0x548>
    334a:	67 c0       	rjmp	.+206    	; 0x341a <main+0x616>
    334c:	82 e0       	ldi	r24, 0x02	; 2
    334e:	90 e0       	ldi	r25, 0x00	; 0
    3350:	0e 94 ca 04 	call	0x994	; 0x994 <String::operator[](unsigned int) const [clone .constprop.14]>
    3354:	8e 36       	cpi	r24, 0x6E	; 110
    3356:	09 f0       	breq	.+2      	; 0x335a <main+0x556>
    3358:	62 c0       	rjmp	.+196    	; 0x341e <main+0x61a>
main():
    335a:	86 e0       	ldi	r24, 0x06	; 6
autoSetRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2300
      case 'A': month = compDateStr[2] == 'r' ? 4 : 8; break;
      case 'M': month = compDateStr[2] == 'r' ? 3 : 5; break;
      case 'S': month = 9; break;
      case 'O': month = 10; break;
      case 'N': month = 11; break;
      case 'D': month = 12; break;
    335c:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <month>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2302
    };
    year = compDateStr.substring(9, 11).toInt();
    3360:	2b e0       	ldi	r18, 0x0B	; 11
    3362:	30 e0       	ldi	r19, 0x00	; 0
    3364:	49 e0       	ldi	r20, 0x09	; 9
    3366:	50 e0       	ldi	r21, 0x00	; 0
    3368:	6f e4       	ldi	r22, 0x4F	; 79
    336a:	73 e0       	ldi	r23, 0x03	; 3
    336c:	ce 01       	movw	r24, r28
    336e:	01 96       	adiw	r24, 0x01	; 1
    3370:	0e 94 50 13 	call	0x26a0	; 0x26a0 <String::substring(unsigned int, unsigned int) const>
    3374:	ce 01       	movw	r24, r28
    3376:	01 96       	adiw	r24, 0x01	; 1
    3378:	0e 94 fe 12 	call	0x25fc	; 0x25fc <String::toInt() const>
    337c:	60 93 00 02 	sts	0x0200, r22	; 0x800200 <year>
    3380:	ce 01       	movw	r24, r28
    3382:	01 96       	adiw	r24, 0x01	; 1
    3384:	0e 94 09 13 	call	0x2612	; 0x2612 <String::~String()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2305

    // Ask for RTC setting al compile date/time
    Serial.println(F("IOS: RTC clock failure!"));
    3388:	84 e4       	ldi	r24, 0x44	; 68
    338a:	94 e0       	ldi	r25, 0x04	; 4
    338c:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2306
    Serial.print(F("\nDo you want set RTC at IOS compile time ("));
    3390:	89 e1       	ldi	r24, 0x19	; 25
    3392:	94 e0       	ldi	r25, 0x04	; 4
    3394:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2307
    printDateTime(0);
    3398:	80 e0       	ldi	r24, 0x00	; 0
    339a:	0e 94 c5 12 	call	0x258a	; 0x258a <printDateTime(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2308
    Serial.print(F(")? [Y/N] >"));
    339e:	8e e0       	ldi	r24, 0x0E	; 14
    33a0:	94 e0       	ldi	r25, 0x04	; 4
    33a2:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2311
    do
    {
      WaitAndBlink(BLK);
    33a6:	0e 94 cd 13 	call	0x279a	; 0x279a <WaitAndBlink(baudRecCheck) [clone .constprop.33]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2312
      inChar = Serial.read();
    33aa:	86 ea       	ldi	r24, 0xA6	; 166
    33ac:	92 e0       	ldi	r25, 0x02	; 2
    33ae:	0e 94 1d 05 	call	0xa3a	; 0xa3a <HardwareSerial::read()>
    33b2:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <inChar>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2314
    }
    while ((inChar != 'y') && (inChar != 'Y') && (inChar != 'n') && (inChar != 'N'));
    33b6:	98 2f       	mov	r25, r24
    33b8:	9f 7d       	andi	r25, 0xDF	; 223
    33ba:	99 35       	cpi	r25, 0x59	; 89
    33bc:	11 f0       	breq	.+4      	; 0x33c2 <main+0x5be>
    33be:	9e 34       	cpi	r25, 0x4E	; 78
    33c0:	91 f7       	brne	.-28     	; 0x33a6 <main+0x5a2>
print():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:69
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
    33c2:	68 2f       	mov	r22, r24
    33c4:	86 ea       	ldi	r24, 0xA6	; 166
    33c6:	92 e0       	ldi	r25, 0x02	; 2
    33c8:	0e 94 76 05 	call	0xaec	; 0xaec <HardwareSerial::write(unsigned char)>
println():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:148
}

size_t Print::println(char c)
{
  size_t n = print(c);
  n += println();
    33cc:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
autoSetRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2318
    Serial.println(inChar);

    // Set the RTC at the compile date/time and print a message
    if ((inChar == 'y') || (inChar == 'Y'))
    33d0:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <inChar>
    33d4:	8f 7d       	andi	r24, 0xDF	; 223
    33d6:	89 35       	cpi	r24, 0x59	; 89
    33d8:	89 f4       	brne	.+34     	; 0x33fc <main+0x5f8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2320
    {
      writeRTC(seconds, minutes, hours, day, month, year);
    33da:	40 91 00 02 	lds	r20, 0x0200	; 0x800200 <year>
    33de:	60 91 01 02 	lds	r22, 0x0201	; 0x800201 <month>
    33e2:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <day>
    33e6:	0e 94 3a 08 	call	0x1074	; 0x1074 <writeRTC(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char) [clone .constprop.27]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2321
      Serial.print(F("IOS: RTC set at compile time - Now: "));
    33ea:	89 ee       	ldi	r24, 0xE9	; 233
    33ec:	93 e0       	ldi	r25, 0x03	; 3
    33ee:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2322
      printDateTime(1);
    33f2:	81 e0       	ldi	r24, 0x01	; 1
    33f4:	0e 94 c5 12 	call	0x258a	; 0x258a <printDateTime(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2323
      Serial.println();
    33f8:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    33fc:	88 e6       	ldi	r24, 0x68	; 104
    33fe:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
autoSetRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2328
    }

    // Reset the "Oscillator Stop Flag"
    Wire.beginTransmission(DS3231_RTC);
    Wire.write(DS3231_STATRG);                    // Set the DS3231 Status Register
    3402:	8f e0       	ldi	r24, 0x0F	; 15
    3404:	90 e0       	ldi	r25, 0x00	; 0
    3406:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2329
    Wire.write(0x08);                             // Reset the "Oscillator Stop Flag" (32KHz output left enabled)
    340a:	88 e0       	ldi	r24, 0x08	; 8
    340c:	90 e0       	ldi	r25, 0x00	; 0
    340e:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2330
    Wire.endTransmission();
    3412:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2283
  Wire.write(DS3231_STATRG);                      // Set the DS3231 Status Register
  Wire.endTransmission();
  Wire.requestFrom(DS3231_RTC, 1);
  OscStopFlag = Wire.read() & 0x80;               // Read the "Oscillator Stop Flag"

  if (OscStopFlag)
    3416:	81 e0       	ldi	r24, 0x01	; 1
    3418:	23 c0       	rjmp	.+70     	; 0x3460 <main+0x65c>
main():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2293
    minutes = compTimeStr.substring(3, 5).toInt();
    hours = compTimeStr.substring(0, 2).toInt();
    day = compDateStr.substring(4, 6).toInt();
    switch (compDateStr[0])
    {
      case 'J': month = compDateStr[1] == 'a' ? 1 : month = compDateStr[2] == 'n' ? 6 : 7; break;
    341a:	81 e0       	ldi	r24, 0x01	; 1
    341c:	9f cf       	rjmp	.-194    	; 0x335c <main+0x558>
    341e:	87 e0       	ldi	r24, 0x07	; 7
    3420:	9d cf       	rjmp	.-198    	; 0x335c <main+0x558>
autoSetRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2294
      case 'F': month = 2; break;
    3422:	82 e0       	ldi	r24, 0x02	; 2
    3424:	9b cf       	rjmp	.-202    	; 0x335c <main+0x558>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2295
      case 'A': month = compDateStr[2] == 'r' ? 4 : 8; break;
    3426:	82 e0       	ldi	r24, 0x02	; 2
    3428:	90 e0       	ldi	r25, 0x00	; 0
    342a:	0e 94 ca 04 	call	0x994	; 0x994 <String::operator[](unsigned int) const [clone .constprop.14]>
    342e:	82 37       	cpi	r24, 0x72	; 114
    3430:	11 f4       	brne	.+4      	; 0x3436 <main+0x632>
main():
    3432:	84 e0       	ldi	r24, 0x04	; 4
    3434:	93 cf       	rjmp	.-218    	; 0x335c <main+0x558>
    3436:	88 e0       	ldi	r24, 0x08	; 8
    3438:	91 cf       	rjmp	.-222    	; 0x335c <main+0x558>
autoSetRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2296
      case 'M': month = compDateStr[2] == 'r' ? 3 : 5; break;
    343a:	82 e0       	ldi	r24, 0x02	; 2
    343c:	90 e0       	ldi	r25, 0x00	; 0
    343e:	0e 94 ca 04 	call	0x994	; 0x994 <String::operator[](unsigned int) const [clone .constprop.14]>
    3442:	82 37       	cpi	r24, 0x72	; 114
    3444:	11 f4       	brne	.+4      	; 0x344a <main+0x646>
main():
    3446:	83 e0       	ldi	r24, 0x03	; 3
    3448:	89 cf       	rjmp	.-238    	; 0x335c <main+0x558>
    344a:	85 e0       	ldi	r24, 0x05	; 5
    344c:	87 cf       	rjmp	.-242    	; 0x335c <main+0x558>
autoSetRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2297
      case 'S': month = 9; break;
    344e:	89 e0       	ldi	r24, 0x09	; 9
    3450:	85 cf       	rjmp	.-246    	; 0x335c <main+0x558>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2298
      case 'O': month = 10; break;
    3452:	8a e0       	ldi	r24, 0x0A	; 10
    3454:	83 cf       	rjmp	.-250    	; 0x335c <main+0x558>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2299
      case 'N': month = 11; break;
    3456:	8b e0       	ldi	r24, 0x0B	; 11
    3458:	81 cf       	rjmp	.-254    	; 0x335c <main+0x558>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2300
      case 'D': month = 12; break;
    345a:	8c e0       	ldi	r24, 0x0C	; 12
    345c:	7f cf       	rjmp	.-258    	; 0x335c <main+0x558>
main():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2266
// Return value: 0 if RTC not present, 1 if found.
{
  byte    OscStopFlag;

  Wire.beginTransmission(DS3231_RTC);
  if (Wire.endTransmission() != 0) return 0;      // RTC not found
    345e:	80 e0       	ldi	r24, 0x00	; 0
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:481
  if (clockMode) Serial.print(CLOCK_LOW);
  else Serial.print(CLOCK_HIGH);
  Serial.println(F("MHz"));

  // Print RTC and GPIO informations if found
  foundRTC = autoSetRTC();                        // Check if RTC is present and initialize it as needed
    3460:	80 93 d7 01 	sts	0x01D7, r24	; 0x8001d7 <foundRTC>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:482
  if (moduleGPIO) Serial.println(F("IOS: Found GPE Option"));
    3464:	80 91 f7 01 	lds	r24, 0x01F7	; 0x8001f7 <moduleGPIO>
    3468:	88 23       	and	r24, r24
    346a:	21 f0       	breq	.+8      	; 0x3474 <main+0x670>
    346c:	82 e9       	ldi	r24, 0x92	; 146
    346e:	97 e0       	ldi	r25, 0x07	; 7
    3470:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:485

  // Print CP/M Autoexec on cold boot status
  Serial.print(F("IOS: CP/M Autoexec is "));
    3474:	8b e7       	ldi	r24, 0x7B	; 123
    3476:	97 e0       	ldi	r25, 0x07	; 7
    3478:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:486
  if (EEPROM.read(autoexecFlagAddr) > 1) EEPROM.update(autoexecFlagAddr, 0); // Reset AUTOEXEC flag to OFF if invalid
    347c:	8c e0       	ldi	r24, 0x0C	; 12
    347e:	90 e0       	ldi	r25, 0x00	; 0
    3480:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
    3484:	82 30       	cpi	r24, 0x02	; 2
    3486:	28 f0       	brcs	.+10     	; 0x3492 <main+0x68e>
    3488:	60 e0       	ldi	r22, 0x00	; 0
    348a:	8c e0       	ldi	r24, 0x0C	; 12
    348c:	90 e0       	ldi	r25, 0x00	; 0
    348e:	0e 94 b7 13 	call	0x276e	; 0x276e <EEPROMClass::update(int, unsigned char) [clone .isra.2]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:487
  autoexecFlag = EEPROM.read(autoexecFlagAddr);   // Read the previous stored AUTOEXEC flag
    3492:	8c e0       	ldi	r24, 0x0C	; 12
    3494:	90 e0       	ldi	r25, 0x00	; 0
    3496:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
    349a:	80 93 d6 01 	sts	0x01D6, r24	; 0x8001d6 <autoexecFlag>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:488
  if (autoexecFlag) Serial.println(F("ON"));
    349e:	88 23       	and	r24, r24
    34a0:	f9 f0       	breq	.+62     	; 0x34e0 <main+0x6dc>
    34a2:	88 e7       	ldi	r24, 0x78	; 120
    34a4:	97 e0       	ldi	r25, 0x07	; 7
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:489
  else Serial.println(F("OFF"));
    34a6:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
mountSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2648
byte mountSD(FATFS* fatFs)
// Mount a volume on SD:
// *  "fatFs" is a pointer to a FATFS object (PetitFS library)
// The returned value is the resulting status (0 = ok, otherwise see printErrSD())
{
  return pf_mount(fatFs);
    34aa:	0e 94 4e 0a 	call	0x149c	; 0x149c <pf_mount.constprop.41>
    34ae:	0e 94 4e 0a 	call	0x149c	; 0x149c <pf_mount.constprop.41>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:497
  // BOOT SELECTION AND SYS PARAMETERS MENU
  // ----------------------------------------

  // Boot selection and system parameters menu if requested
  mountSD(&filesysSD); mountSD(&filesysSD);       // Try to muont the SD volume
  bootMode = EEPROM.read(bootModeAddr);           // Read the previous stored boot mode
    34b2:	8a e0       	ldi	r24, 0x0A	; 10
    34b4:	90 e0       	ldi	r25, 0x00	; 0
    34b6:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
    34ba:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <bootMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:498
  if ((bootSelection == 1 ) || (bootMode > maxBootMode))
    34be:	01 2b       	or	r16, r17
    34c0:	19 f0       	breq	.+6      	; 0x34c8 <main+0x6c4>
    34c2:	85 30       	cpi	r24, 0x05	; 5
    34c4:	08 f4       	brcc	.+2      	; 0x34c8 <main+0x6c4>
    34c6:	c3 c0       	rjmp	.+390    	; 0x364e <main+0x84a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:502
    // Enter in the boot selection menu if USER key was pressed at startup
    //   or an invalid bootMode code was read from internal EEPROM
  {
    while (Serial.available() > 0)                // Flush input serial Rx buffer
    34c8:	86 ea       	ldi	r24, 0xA6	; 166
    34ca:	92 e0       	ldi	r25, 0x02	; 2
    34cc:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
    34d0:	18 16       	cp	r1, r24
    34d2:	19 06       	cpc	r1, r25
    34d4:	44 f4       	brge	.+16     	; 0x34e6 <main+0x6e2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:504
    {
      Serial.read();
    34d6:	86 ea       	ldi	r24, 0xA6	; 166
    34d8:	92 e0       	ldi	r25, 0x02	; 2
    34da:	0e 94 1d 05 	call	0xa3a	; 0xa3a <HardwareSerial::read()>
    34de:	f4 cf       	rjmp	.-24     	; 0x34c8 <main+0x6c4>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:489
  // Print CP/M Autoexec on cold boot status
  Serial.print(F("IOS: CP/M Autoexec is "));
  if (EEPROM.read(autoexecFlagAddr) > 1) EEPROM.update(autoexecFlagAddr, 0); // Reset AUTOEXEC flag to OFF if invalid
  autoexecFlag = EEPROM.read(autoexecFlagAddr);   // Read the previous stored AUTOEXEC flag
  if (autoexecFlag) Serial.println(F("ON"));
  else Serial.println(F("OFF"));
    34e0:	84 e7       	ldi	r24, 0x74	; 116
    34e2:	97 e0       	ldi	r25, 0x07	; 7
    34e4:	e0 cf       	rjmp	.-64     	; 0x34a6 <main+0x6a2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:506
  {
    while (Serial.available() > 0)                // Flush input serial Rx buffer
    {
      Serial.read();
    }
    Serial.println();
    34e6:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:507
    Serial.println(F("IOS: Select boot mode or system parameters:"));
    34ea:	88 e4       	ldi	r24, 0x48	; 72
    34ec:	97 e0       	ldi	r25, 0x07	; 7
    34ee:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:508
    Serial.println();
    34f2:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:509
    if (bootMode <= maxBootMode)
    34f6:	10 91 cd 01 	lds	r17, 0x01CD	; 0x8001cd <bootMode>
main():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:366
  //
  // ------------------------------------------------------------------------------

  byte          data;                       // External RAM data byte
  word          address;                    // External RAM current address;
  char          minBootChar   = '1';        // Minimum allowed ASCII value selection (boot selection)
    34fa:	01 e3       	ldi	r16, 0x31	; 49
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:509
      Serial.read();
    }
    Serial.println();
    Serial.println(F("IOS: Select boot mode or system parameters:"));
    Serial.println();
    if (bootMode <= maxBootMode)
    34fc:	15 30       	cpi	r17, 0x05	; 5
    34fe:	70 f4       	brcc	.+28     	; 0x351c <main+0x718>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:513
      // Previous valid boot mode read, so enable '0' selection
    {
      minBootChar = '0';
      Serial.print(F(" 0: No change ("));
    3500:	88 e3       	ldi	r24, 0x38	; 56
    3502:	97 e0       	ldi	r25, 0x07	; 7
    3504:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:514
      Serial.print(bootMode + 1);
    3508:	81 2f       	mov	r24, r17
    350a:	90 e0       	ldi	r25, 0x00	; 0
    350c:	01 96       	adiw	r24, 0x01	; 1
    350e:	0e 94 a8 11 	call	0x2350	; 0x2350 <Print::print(int, int) [clone .constprop.16]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:515
      Serial.println(")");
    3512:	8c ed       	ldi	r24, 0xDC	; 220
    3514:	90 e0       	ldi	r25, 0x00	; 0
    3516:	0e 94 02 12 	call	0x2404	; 0x2404 <Print::println(char const*) [clone .constprop.48]>
main():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:512
    Serial.println(F("IOS: Select boot mode or system parameters:"));
    Serial.println();
    if (bootMode <= maxBootMode)
      // Previous valid boot mode read, so enable '0' selection
    {
      minBootChar = '0';
    351a:	00 e3       	ldi	r16, 0x30	; 48
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:517
      Serial.print(F(" 0: No change ("));
      Serial.print(bootMode + 1);
      Serial.println(")");
    }
    Serial.println(F(" 1: Basic"));
    351c:	8e e2       	ldi	r24, 0x2E	; 46
    351e:	97 e0       	ldi	r25, 0x07	; 7
    3520:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:518
    Serial.println(F(" 2: Forth"));
    3524:	84 e2       	ldi	r24, 0x24	; 36
    3526:	97 e0       	ldi	r25, 0x07	; 7
    3528:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:519
    Serial.print(F(" 3: Load/set OS "));
    352c:	83 e1       	ldi	r24, 0x13	; 19
    352e:	97 e0       	ldi	r25, 0x07	; 7
    3530:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:520
    printOsName(diskSet);
    3534:	80 91 f6 01 	lds	r24, 0x01F6	; 0x8001f6 <diskSet>
    3538:	0e 94 77 12 	call	0x24ee	; 0x24ee <printOsName(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:521
    Serial.println(F("\r\n 4: Autoboot"));
    353c:	84 e0       	ldi	r24, 0x04	; 4
    353e:	97 e0       	ldi	r25, 0x07	; 7
    3540:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:522
    Serial.println(F(" 5: iLoad"));
    3544:	8a ef       	ldi	r24, 0xFA	; 250
    3546:	96 e0       	ldi	r25, 0x06	; 6
    3548:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:523
    Serial.print(F(" 6: Change Z80 clock speed (->"));
    354c:	8b ed       	ldi	r24, 0xDB	; 219
    354e:	96 e0       	ldi	r25, 0x06	; 6
    3550:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:524
    if (clockMode) Serial.print(CLOCK_HIGH);
    3554:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <clockMode>
    3558:	65 e0       	ldi	r22, 0x05	; 5
    355a:	71 e0       	ldi	r23, 0x01	; 1
    355c:	81 11       	cpse	r24, r1
    355e:	02 c0       	rjmp	.+4      	; 0x3564 <main+0x760>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:525
    else Serial.print(CLOCK_LOW);
    3560:	63 e0       	ldi	r22, 0x03	; 3
    3562:	71 e0       	ldi	r23, 0x01	; 1
    3564:	86 ea       	ldi	r24, 0xA6	; 166
    3566:	92 e0       	ldi	r25, 0x02	; 2
    3568:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:526
    Serial.println(F("MHz)"));
    356c:	86 ed       	ldi	r24, 0xD6	; 214
    356e:	96 e0       	ldi	r25, 0x06	; 6
    3570:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:527
    Serial.print(F(" 7: Toggle CP/M Autoexec (->"));
    3574:	89 eb       	ldi	r24, 0xB9	; 185
    3576:	96 e0       	ldi	r25, 0x06	; 6
    3578:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:528
    if (!autoexecFlag) Serial.print("ON");
    357c:	80 91 d6 01 	lds	r24, 0x01D6	; 0x8001d6 <autoexecFlag>
    3580:	81 11       	cpse	r24, r1
    3582:	ba c0       	rjmp	.+372    	; 0x36f8 <main+0x8f4>
    3584:	69 e0       	ldi	r22, 0x09	; 9
    3586:	71 e0       	ldi	r23, 0x01	; 1
    3588:	86 ea       	ldi	r24, 0xA6	; 166
    358a:	92 e0       	ldi	r25, 0x02	; 2
    358c:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:530
    else Serial.print(F("OFF"));
    Serial.println(")");
    3590:	8c ed       	ldi	r24, 0xDC	; 220
    3592:	90 e0       	ldi	r25, 0x00	; 0
    3594:	0e 94 02 12 	call	0x2404	; 0x2404 <Print::println(char const*) [clone .constprop.48]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:531
    Serial.print(F(" 8: Set serial port speed ("));
    3598:	89 e9       	ldi	r24, 0x99	; 153
    359a:	96 e0       	ldi	r25, 0x06	; 6
    359c:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:532
    Serial.print(indexToBaud(EEPROM.read(serBaudAddr)));
    35a0:	8f e0       	ldi	r24, 0x0F	; 15
    35a2:	90 e0       	ldi	r25, 0x00	; 0
    35a4:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
    35a8:	89 30       	cpi	r24, 0x09	; 9
    35aa:	08 f0       	brcs	.+2      	; 0x35ae <main+0x7aa>
    35ac:	aa c0       	rjmp	.+340    	; 0x3702 <main+0x8fe>
    35ae:	e8 2f       	mov	r30, r24
    35b0:	f0 e0       	ldi	r31, 0x00	; 0
    35b2:	ee 0f       	add	r30, r30
    35b4:	ff 1f       	adc	r31, r31
    35b6:	ec 56       	subi	r30, 0x6C	; 108
    35b8:	ff 4f       	sbci	r31, 0xFF	; 255
    35ba:	60 81       	ld	r22, Z
    35bc:	71 81       	ldd	r23, Z+1	; 0x01
    35be:	90 e0       	ldi	r25, 0x00	; 0
    35c0:	80 e0       	ldi	r24, 0x00	; 0
print():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    35c2:	4a e0       	ldi	r20, 0x0A	; 10
    35c4:	0e 94 62 11 	call	0x22c4	; 0x22c4 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:533
    Serial.println(")");
    35c8:	8c ed       	ldi	r24, 0xDC	; 220
    35ca:	90 e0       	ldi	r25, 0x00	; 0
    35cc:	0e 94 02 12 	call	0x2404	; 0x2404 <Print::println(char const*) [clone .constprop.48]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:536

    // If RTC module is present add a menu choice
    if (foundRTC)
    35d0:	80 91 d7 01 	lds	r24, 0x01D7	; 0x8001d7 <foundRTC>
main():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:367
  // ------------------------------------------------------------------------------

  byte          data;                       // External RAM data byte
  word          address;                    // External RAM current address;
  char          minBootChar   = '1';        // Minimum allowed ASCII value selection (boot selection)
  char          maxSelChar    = '8';        // Maximum allowed ASCII value selection (boot selection)
    35d4:	18 e3       	ldi	r17, 0x38	; 56
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:536
    Serial.print(F(" 8: Set serial port speed ("));
    Serial.print(indexToBaud(EEPROM.read(serBaudAddr)));
    Serial.println(")");

    // If RTC module is present add a menu choice
    if (foundRTC)
    35d6:	88 23       	and	r24, r24
    35d8:	29 f0       	breq	.+10     	; 0x35e4 <main+0x7e0>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:538
    {
      Serial.println(F(" 9: Set RTC time/date"));
    35da:	83 e8       	ldi	r24, 0x83	; 131
    35dc:	96 e0       	ldi	r25, 0x06	; 6
    35de:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
main():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:539
      maxSelChar = '9';
    35e2:	19 e3       	ldi	r17, 0x39	; 57
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:543
    }

    // Ask a choice
    Serial.println();
    35e4:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:544
    Serial.print(F("Enter your choice >"));
    35e8:	8f e6       	ldi	r24, 0x6F	; 111
    35ea:	96 e0       	ldi	r25, 0x06	; 6
    35ec:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:547
    do
    {
      WaitAndBlink(CHECK);
    35f0:	0e 94 cd 13 	call	0x279a	; 0x279a <WaitAndBlink(baudRecCheck) [clone .constprop.33]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:548
      inChar = Serial.read();
    35f4:	86 ea       	ldi	r24, 0xA6	; 166
    35f6:	92 e0       	ldi	r25, 0x02	; 2
    35f8:	0e 94 1d 05 	call	0xa3a	; 0xa3a <HardwareSerial::read()>
    35fc:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <inChar>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:550
    }
    while ((inChar < minBootChar) || (inChar > maxSelChar));
    3600:	80 17       	cp	r24, r16
    3602:	b4 f3       	brlt	.-20     	; 0x35f0 <main+0x7ec>
    3604:	18 17       	cp	r17, r24
    3606:	a4 f3       	brlt	.-24     	; 0x35f0 <main+0x7ec>
print():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:69
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
    3608:	68 2f       	mov	r22, r24
    360a:	86 ea       	ldi	r24, 0xA6	; 166
    360c:	92 e0       	ldi	r25, 0x02	; 2
    360e:	0e 94 76 05 	call	0xaec	; 0xaec <HardwareSerial::write(unsigned char)>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:552
    Serial.print(inChar);
    Serial.println(F("  Ok"));
    3612:	8a e6       	ldi	r24, 0x6A	; 106
    3614:	96 e0       	ldi	r25, 0x06	; 6
    3616:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:555

    // Make the selected action for the system parameters choice
    switch (inChar)
    361a:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <inChar>
    361e:	87 33       	cpi	r24, 0x37	; 55
    3620:	09 f4       	brne	.+2      	; 0x3624 <main+0x820>
    3622:	1d c1       	rjmp	.+570    	; 0x385e <main+0xa5a>
    3624:	0c f0       	brlt	.+2      	; 0x3628 <main+0x824>
    3626:	72 c0       	rjmp	.+228    	; 0x370c <main+0x908>
    3628:	83 33       	cpi	r24, 0x33	; 51
    362a:	09 f4       	brne	.+2      	; 0x362e <main+0x82a>
    362c:	b9 c0       	rjmp	.+370    	; 0x37a0 <main+0x99c>
    362e:	86 33       	cpi	r24, 0x36	; 54
    3630:	09 f4       	brne	.+2      	; 0x3634 <main+0x830>
    3632:	09 c1       	rjmp	.+530    	; 0x3846 <main+0xa42>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:625
        ChangeRTC();                              // Change RTC Date/Time if requested
        break;
    };

    // Save selectd boot program if changed
    bootMode = inChar - '1';                      // Calculate bootMode from inChar
    3634:	60 91 cc 01 	lds	r22, 0x01CC	; 0x8001cc <inChar>
    3638:	61 53       	subi	r22, 0x31	; 49
    363a:	60 93 cd 01 	sts	0x01CD, r22	; 0x8001cd <bootMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:626
    if (bootMode <= maxBootMode) EEPROM.update(bootModeAddr, bootMode); // Save to the internal EEPROM if required
    363e:	65 30       	cpi	r22, 0x05	; 5
    3640:	10 f0       	brcs	.+4      	; 0x3646 <main+0x842>
    3642:	0c 94 b1 24 	jmp	0x4962	; 0x4962 <main+0x1b5e>
    3646:	8a e0       	ldi	r24, 0x0A	; 10
    3648:	90 e0       	ldi	r25, 0x00	; 0
    364a:	0e 94 b7 13 	call	0x276e	; 0x276e <EEPROMClass::update(int, unsigned char) [clone .isra.2]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:631
    else bootMode = EEPROM.read(bootModeAddr);    // Reload boot mode if '0' or > '5' choice selected
  }

  // Print current Disk Set and OS name (if OS boot is enabled)
  if (bootMode == 2)
    364e:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <bootMode>
    3652:	82 30       	cpi	r24, 0x02	; 2
    3654:	51 f4       	brne	.+20     	; 0x366a <main+0x866>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:633
  {
    Serial.print(F("IOS: Current "));
    3656:	84 e0       	ldi	r24, 0x04	; 4
    3658:	96 e0       	ldi	r25, 0x06	; 6
    365a:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:634
    printOsName(diskSet);
    365e:	80 91 f6 01 	lds	r24, 0x01F6	; 0x8001f6 <diskSet>
    3662:	0e 94 77 12 	call	0x24ee	; 0x24ee <printOsName(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:635
    Serial.println();
    3666:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:643
  // ----------------------------------------
  // Z80 PROGRAM LOAD
  // ----------------------------------------

  // Get the starting address of the program to load and boot, and its size if stored in the flash
  switch (bootMode)
    366a:	10 91 cd 01 	lds	r17, 0x01CD	; 0x8001cd <bootMode>
    366e:	12 30       	cpi	r17, 0x02	; 2
    3670:	09 f4       	brne	.+2      	; 0x3674 <main+0x870>
    3672:	f7 c2       	rjmp	.+1518   	; 0x3c62 <main+0xe5e>
    3674:	08 f0       	brcs	.+2      	; 0x3678 <main+0x874>
    3676:	d0 c2       	rjmp	.+1440   	; 0x3c18 <main+0xe14>
    3678:	11 23       	and	r17, r17
    367a:	09 f4       	brne	.+2      	; 0x367e <main+0x87a>
    367c:	e4 c2       	rjmp	.+1480   	; 0x3c46 <main+0xe42>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:652
      BootStrAddr = BASSTRADDR;
      Z80IntRx = 1;                               // Enable Z80 Rx INT_ interrupt signal generation (Z80 M1 INT I/O)
      break;

    case 1:                                       // Load Forth from SD
      fileNameSD = FORTHFN;
    367e:	88 e1       	ldi	r24, 0x18	; 24
    3680:	91 e0       	ldi	r25, 0x01	; 1
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:643
  // ----------------------------------------
  // Z80 PROGRAM LOAD
  // ----------------------------------------

  // Get the starting address of the program to load and boot, and its size if stored in the flash
  switch (bootMode)
    3682:	11 30       	cpi	r17, 0x01	; 1
    3684:	09 f4       	brne	.+2      	; 0x3688 <main+0x884>
    3686:	25 c3       	rjmp	.+1610   	; 0x3cd2 <main+0xece>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:704
      BootImage = (byte *) pgm_read_word (&flahBootTable[0]);
      BootImageSize = sizeof(boot_A_);
      BootStrAddr = boot_A_StrAddr;
      break;
  }
  digitalWrite(WAIT_RES_, HIGH);                  // Set WAIT_RES_ HIGH (Led LED_0 ON)
    3688:	61 e0       	ldi	r22, 0x01	; 1
    368a:	80 e0       	ldi	r24, 0x00	; 0
    368c:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:707

  // Load a JP instruction if the boot program starting addr is > 0x0000
  if (BootStrAddr > 0x0000)                       // Check if the boot program starting addr > 0x0000
    3690:	e0 90 c7 01 	lds	r14, 0x01C7	; 0x8001c7 <BootStrAddr>
    3694:	f0 90 c8 01 	lds	r15, 0x01C8	; 0x8001c8 <BootStrAddr+0x1>
    3698:	e1 14       	cp	r14, r1
    369a:	f1 04       	cpc	r15, r1
    369c:	69 f0       	breq	.+26     	; 0x36b8 <main+0x8b4>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:710
    // Inject a "JP <BootStrAddr>" instruction to jump at boot starting address
  {
    loadHL(0x0000);                               // HL = 0x0000 (used as pointer to RAM)
    369e:	90 e0       	ldi	r25, 0x00	; 0
    36a0:	80 e0       	ldi	r24, 0x00	; 0
    36a2:	0e 94 29 10 	call	0x2052	; 0x2052 <loadHL(unsigned int)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:711
    loadByteToRAM(JP_nn);                         // Write the JP instruction @ 0x0000;
    36a6:	83 ec       	ldi	r24, 0xC3	; 195
    36a8:	0e 94 53 10 	call	0x20a6	; 0x20a6 <loadByteToRAM(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:712
    loadByteToRAM(lowByte(BootStrAddr));          // Write LSB to jump @ 0x0001
    36ac:	8e 2d       	mov	r24, r14
    36ae:	0e 94 53 10 	call	0x20a6	; 0x20a6 <loadByteToRAM(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:713
    loadByteToRAM(highByte(BootStrAddr));         // Write MSB to jump @ 0x0002
    36b2:	8f 2d       	mov	r24, r15
    36b4:	0e 94 53 10 	call	0x20a6	; 0x20a6 <loadByteToRAM(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:728
    //

  }

  // Execute the load of the selected file on SD or image on flash
  loadHL(BootStrAddr);                            // Set Z80 HL = boot starting address (used as pointer to RAM);
    36b8:	c7 01       	movw	r24, r14
    36ba:	0e 94 29 10 	call	0x2052	; 0x2052 <loadHL(unsigned int)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:742
    Serial.println(BootStrAddr, HEX);
  }
  // DEBUG END ------------------------------
  //

  if (bootMode < maxBootMode)
    36be:	14 30       	cpi	r17, 0x04	; 4
    36c0:	08 f0       	brcs	.+2      	; 0x36c4 <main+0x8c0>
    36c2:	ca c3       	rjmp	.+1940   	; 0x3e58 <main+0x1054>
mountSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2648
byte mountSD(FATFS* fatFs)
// Mount a volume on SD:
// *  "fatFs" is a pointer to a FATFS object (PetitFS library)
// The returned value is the resulting status (0 = ok, otherwise see printErrSD())
{
  return pf_mount(fatFs);
    36c4:	0e 94 4e 0a 	call	0x149c	; 0x149c <pf_mount.constprop.41>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:746

  if (bootMode < maxBootMode)
    // Load from SD
  {
    // Mount a volume on SD
    if (mountSD(&filesysSD))
    36c8:	88 23       	and	r24, r24
    36ca:	09 f4       	brne	.+2      	; 0x36ce <main+0x8ca>
    36cc:	1a c3       	rjmp	.+1588   	; 0x3d02 <main+0xefe>
mountSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2648
byte mountSD(FATFS* fatFs)
// Mount a volume on SD:
// *  "fatFs" is a pointer to a FATFS object (PetitFS library)
// The returned value is the resulting status (0 = ok, otherwise see printErrSD())
{
  return pf_mount(fatFs);
    36ce:	0e 94 4e 0a 	call	0x149c	; 0x149c <pf_mount.constprop.41>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:749
  {
    // Mount a volume on SD
    if (mountSD(&filesysSD))
      // Error mounting. Try again
    {
      errCodeSD = mountSD(&filesysSD);
    36d2:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <errCodeSD>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:750
      if (errCodeSD)
    36d6:	88 23       	and	r24, r24
    36d8:	09 f4       	brne	.+2      	; 0x36dc <main+0x8d8>
    36da:	13 c3       	rjmp	.+1574   	; 0x3d02 <main+0xefe>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:754
        // Error again. Repeat until error disappears (or the user forces a reset)
        do
        {
          printErrSD(0, errCodeSD, NULL);
    36dc:	60 91 c2 01 	lds	r22, 0x01C2	; 0x8001c2 <errCodeSD>
printErrSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2782
// NOT_OPENED
//     The file has not been opened.
//
// ........................................................................
{
  if (errCode)
    36e0:	66 23       	and	r22, r22
    36e2:	29 f0       	breq	.+10     	; 0x36ee <main+0x8ea>
    36e4:	50 e0       	ldi	r21, 0x00	; 0
    36e6:	40 e0       	ldi	r20, 0x00	; 0
    36e8:	80 e0       	ldi	r24, 0x00	; 0
    36ea:	0e 94 19 12 	call	0x2432	; 0x2432 <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:755
      if (errCodeSD)
        // Error again. Repeat until error disappears (or the user forces a reset)
        do
        {
          printErrSD(0, errCodeSD, NULL);
          waitKey();                                // Wait a key to repeat
    36ee:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <waitKey()>
mountSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2648
byte mountSD(FATFS* fatFs)
// Mount a volume on SD:
// *  "fatFs" is a pointer to a FATFS object (PetitFS library)
// The returned value is the resulting status (0 = ok, otherwise see printErrSD())
{
  return pf_mount(fatFs);
    36f2:	0e 94 4e 0a 	call	0x149c	; 0x149c <pf_mount.constprop.41>
    36f6:	eb cf       	rjmp	.-42     	; 0x36ce <main+0x8ca>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:529
    if (clockMode) Serial.print(CLOCK_HIGH);
    else Serial.print(CLOCK_LOW);
    Serial.println(F("MHz)"));
    Serial.print(F(" 7: Toggle CP/M Autoexec (->"));
    if (!autoexecFlag) Serial.print("ON");
    else Serial.print(F("OFF"));
    36f8:	85 eb       	ldi	r24, 0xB5	; 181
    36fa:	96 e0       	ldi	r25, 0x06	; 6
    36fc:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
    3700:	47 cf       	rjmp	.-370    	; 0x3590 <main+0x78c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:532
    Serial.println(")");
    Serial.print(F(" 8: Set serial port speed ("));
    Serial.print(indexToBaud(EEPROM.read(serBaudAddr)));
    3702:	60 e0       	ldi	r22, 0x00	; 0
    3704:	72 ec       	ldi	r23, 0xC2	; 194
    3706:	81 e0       	ldi	r24, 0x01	; 1
    3708:	90 e0       	ldi	r25, 0x00	; 0
    370a:	5b cf       	rjmp	.-330    	; 0x35c2 <main+0x7be>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:555
    while ((inChar < minBootChar) || (inChar > maxSelChar));
    Serial.print(inChar);
    Serial.println(F("  Ok"));

    // Make the selected action for the system parameters choice
    switch (inChar)
    370c:	88 33       	cpi	r24, 0x38	; 56
    370e:	09 f4       	brne	.+2      	; 0x3712 <main+0x90e>
    3710:	b0 c0       	rjmp	.+352    	; 0x3872 <main+0xa6e>
    3712:	89 33       	cpi	r24, 0x39	; 57
    3714:	09 f0       	breq	.+2      	; 0x3718 <main+0x914>
    3716:	8e cf       	rjmp	.-228    	; 0x3634 <main+0x830>
ChangeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2386
// Change manually the RTC Date/Time from keyboard
{
  byte    leapYear;   //  Set to 1 if the selected year is bissextile, 0 otherwise [0..1]

  // Read RTC
  readRTC(&seconds, &minutes, &hours, &day,  &month,  &year, &tempC);
    3718:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <readRTC(unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*) [clone .constprop.20]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2389

  // Change RTC date/time from keyboard
  tempByte = 0;
    371c:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <tempByte>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2390
  Serial.println(F("\nIOS: RTC manual setting:"));
    3720:	87 e8       	ldi	r24, 0x87	; 135
    3722:	95 e0       	ldi	r25, 0x05	; 5
    3724:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2391
  Serial.println(F("\nPress T/U to increment +10/+1 or CR to accept"));
    3728:	88 e5       	ldi	r24, 0x58	; 88
    372a:	95 e0       	ldi	r25, 0x05	; 5
    372c:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2496
            else if (month < 3) month = month + 10;
            break;

          case 2:
            day = day + 10;
            if (day > (daysOfMonth[month - 1] + isLeapYear(year))) day = day - (day / 10) * 10;
    3730:	6a e0       	ldi	r22, 0x0A	; 10
    3732:	f6 2e       	mov	r15, r22
    3734:	76 ef       	ldi	r23, 0xF6	; 246
    3736:	e7 2e       	mov	r14, r23
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2497
            if (day == 0) day = 1;
    3738:	dd 24       	eor	r13, r13
    373a:	d3 94       	inc	r13
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2396
  Serial.println(F("\nPress T/U to increment +10/+1 or CR to accept"));
  do
  {
    do
    {
      Serial.print(F(" "));
    373c:	86 e5       	ldi	r24, 0x56	; 86
    373e:	95 e0       	ldi	r25, 0x05	; 5
    3740:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2397
      switch (tempByte)
    3744:	80 91 f2 01 	lds	r24, 0x01F2	; 0x8001f2 <tempByte>
    3748:	82 30       	cpi	r24, 0x02	; 2
    374a:	09 f4       	brne	.+2      	; 0x374e <main+0x94a>
    374c:	1c c1       	rjmp	.+568    	; 0x3986 <main+0xb82>
    374e:	08 f0       	brcs	.+2      	; 0x3752 <main+0x94e>
    3750:	fd c0       	rjmp	.+506    	; 0x394c <main+0xb48>
    3752:	88 23       	and	r24, r24
    3754:	09 f4       	brne	.+2      	; 0x3758 <main+0x954>
    3756:	07 c1       	rjmp	.+526    	; 0x3966 <main+0xb62>
    3758:	81 30       	cpi	r24, 0x01	; 1
    375a:	09 f4       	brne	.+2      	; 0x375e <main+0x95a>
    375c:	0d c1       	rjmp	.+538    	; 0x3978 <main+0xb74>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2434
          break;
      }

      do
      {
        WaitAndBlink(BLK);
    375e:	0e 94 cd 13 	call	0x279a	; 0x279a <WaitAndBlink(baudRecCheck) [clone .constprop.33]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2435
        inChar = Serial.read();
    3762:	86 ea       	ldi	r24, 0xA6	; 166
    3764:	92 e0       	ldi	r25, 0x02	; 2
    3766:	0e 94 1d 05 	call	0xa3a	; 0xa3a <HardwareSerial::read()>
    376a:	08 2f       	mov	r16, r24
    376c:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <inChar>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2437
      }
      while ((inChar != 'u') && (inChar != 'U') && (inChar != 't') && (inChar != 'T') && (inChar != 13));
    3770:	85 37       	cpi	r24, 0x75	; 117
    3772:	09 f4       	brne	.+2      	; 0x3776 <main+0x972>
    3774:	26 c1       	rjmp	.+588    	; 0x39c2 <main+0xbbe>
    3776:	85 35       	cpi	r24, 0x55	; 85
    3778:	09 f4       	brne	.+2      	; 0x377c <main+0x978>
    377a:	23 c1       	rjmp	.+582    	; 0x39c2 <main+0xbbe>
    377c:	84 37       	cpi	r24, 0x74	; 116
    377e:	11 f4       	brne	.+4      	; 0x3784 <main+0x980>
    3780:	0c 94 b9 24 	jmp	0x4972	; 0x4972 <main+0x1b6e>
    3784:	84 35       	cpi	r24, 0x54	; 84
    3786:	11 f4       	brne	.+4      	; 0x378c <main+0x988>
    3788:	0c 94 b9 24 	jmp	0x4972	; 0x4972 <main+0x1b6e>
    378c:	8d 30       	cpi	r24, 0x0D	; 13
    378e:	39 f7       	brne	.-50     	; 0x375e <main+0x95a>
    3790:	10 91 f2 01 	lds	r17, 0x01F2	; 0x8001f2 <tempByte>
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.h:133
    virtual void flush(void);
    virtual size_t write(uint8_t);
    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
    3794:	6d e0       	ldi	r22, 0x0D	; 13
    3796:	86 ea       	ldi	r24, 0xA6	; 166
    3798:	92 e0       	ldi	r25, 0x02	; 2
    379a:	0e 94 76 05 	call	0xaec	; 0xaec <HardwareSerial::write(unsigned char)>
    379e:	36 c1       	rjmp	.+620    	; 0x3a0c <main+0xc08>
printMsg1():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2101

// ------------------------------------------------------------------------------

void printMsg1()
{
  Serial.println(F("\r\nPress CR to accept, ESC to exit or any other key to change"));
    37a0:	80 ea       	ldi	r24, 0xA0	; 160
    37a2:	94 e0       	ldi	r25, 0x04	; 4
    37a4:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:559
    // Make the selected action for the system parameters choice
    switch (inChar)
    {
      case '3':                                   // Load/change current Disk Set
        printMsg1();
        iCount = (byte) (diskSet - 1); // Set the previous Disk Set
    37a8:	80 91 f6 01 	lds	r24, 0x01F6	; 0x8001f6 <diskSet>
    37ac:	81 50       	subi	r24, 0x01	; 1
    37ae:	80 93 cb 01 	sts	0x01CB, r24	; 0x8001cb <iCount>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:563
        do
        {
          // Print the OS name of the next Disk Set
          iCount = (byte)(iCount + 1) % maxDiskSet;
    37b2:	06 e0       	ldi	r16, 0x06	; 6
    37b4:	80 91 cb 01 	lds	r24, 0x01CB	; 0x8001cb <iCount>
    37b8:	8f 5f       	subi	r24, 0xFF	; 255
    37ba:	60 2f       	mov	r22, r16
    37bc:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    37c0:	19 2f       	mov	r17, r25
    37c2:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <iCount>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:564
          Serial.print(F("\r ->"));
    37c6:	85 e6       	ldi	r24, 0x65	; 101
    37c8:	96 e0       	ldi	r25, 0x06	; 6
    37ca:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:565
          printOsName(iCount);
    37ce:	81 2f       	mov	r24, r17
    37d0:	0e 94 77 12 	call	0x24ee	; 0x24ee <printOsName(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:566
          Serial.print(F("                 \r"));
    37d4:	82 e5       	ldi	r24, 0x52	; 82
    37d6:	96 e0       	ldi	r25, 0x06	; 6
    37d8:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:567
          while (Serial.available() > 0) Serial.read(); // Flush serial Rx buffer
    37dc:	86 ea       	ldi	r24, 0xA6	; 166
    37de:	92 e0       	ldi	r25, 0x02	; 2
    37e0:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
    37e4:	18 16       	cp	r1, r24
    37e6:	19 06       	cpc	r1, r25
    37e8:	2c f4       	brge	.+10     	; 0x37f4 <main+0x9f0>
    37ea:	86 ea       	ldi	r24, 0xA6	; 166
    37ec:	92 e0       	ldi	r25, 0x02	; 2
    37ee:	0e 94 1d 05 	call	0xa3a	; 0xa3a <HardwareSerial::read()>
    37f2:	f4 cf       	rjmp	.-24     	; 0x37dc <main+0x9d8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:568
          while (Serial.available() < 1) WaitAndBlink(BLK); // Wait a key
    37f4:	86 ea       	ldi	r24, 0xA6	; 166
    37f6:	92 e0       	ldi	r25, 0x02	; 2
    37f8:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
    37fc:	18 16       	cp	r1, r24
    37fe:	19 06       	cpc	r1, r25
    3800:	1c f0       	brlt	.+6      	; 0x3808 <main+0xa04>
    3802:	0e 94 cd 13 	call	0x279a	; 0x279a <WaitAndBlink(baudRecCheck) [clone .constprop.33]>
    3806:	f6 cf       	rjmp	.-20     	; 0x37f4 <main+0x9f0>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:569
          inChar = Serial.read();
    3808:	86 ea       	ldi	r24, 0xA6	; 166
    380a:	92 e0       	ldi	r25, 0x02	; 2
    380c:	0e 94 1d 05 	call	0xa3a	; 0xa3a <HardwareSerial::read()>
    3810:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <inChar>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:571
        }
        while ((inChar != 13) && (inChar != 27)); // Continue until a CR or ESC is pressed
    3814:	8d 30       	cpi	r24, 0x0D	; 13
    3816:	11 f0       	breq	.+4      	; 0x381c <main+0xa18>
    3818:	8b 31       	cpi	r24, 0x1B	; 27
    381a:	61 f6       	brne	.-104    	; 0x37b4 <main+0x9b0>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:572
        Serial.println();
    381c:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:573
        Serial.println();
    3820:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:574
        if (inChar == 13)                         // Set and store the new Disk Set if required
    3824:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <inChar>
    3828:	8d 30       	cpi	r24, 0x0D	; 13
    382a:	09 f0       	breq	.+2      	; 0x382e <main+0xa2a>
    382c:	03 cf       	rjmp	.-506    	; 0x3634 <main+0x830>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:576
        {
          diskSet = iCount;
    382e:	60 91 cb 01 	lds	r22, 0x01CB	; 0x8001cb <iCount>
    3832:	60 93 f6 01 	sts	0x01F6, r22	; 0x8001f6 <diskSet>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:577
          EEPROM.update(diskSetAddr, iCount);
    3836:	8e e0       	ldi	r24, 0x0E	; 14
    3838:	90 e0       	ldi	r25, 0x00	; 0
    383a:	0e 94 b7 13 	call	0x276e	; 0x276e <EEPROMClass::update(int, unsigned char) [clone .isra.2]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:578
          inChar = '3';                          // Set to boot the current selected OS
    383e:	83 e3       	ldi	r24, 0x33	; 51
    3840:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <inChar>
    3844:	f7 ce       	rjmp	.-530    	; 0x3634 <main+0x830>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:583
        }
        break;

      case '6':                                   // Change the clock speed of the Z80 CPU
        clockMode = !clockMode;                   // Toggle Z80 clock speed mode (High/Low)
    3846:	61 e0       	ldi	r22, 0x01	; 1
    3848:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <clockMode>
    384c:	81 11       	cpse	r24, r1
    384e:	60 e0       	ldi	r22, 0x00	; 0
    3850:	60 93 ce 01 	sts	0x01CE, r22	; 0x8001ce <clockMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:584
        EEPROM.update(clockModeAddr, clockMode);  // Save it to the internal EEPROM
    3854:	8d e0       	ldi	r24, 0x0D	; 13
    3856:	90 e0       	ldi	r25, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:589
        break;

      case '7':                                   // Toggle CP/M AUTOEXEC execution on cold boot
        autoexecFlag = !autoexecFlag;             // Toggle AUTOEXEC executiont status
        EEPROM.update(autoexecFlagAddr, autoexecFlag); // Save it to the internal EEPROM
    3858:	0e 94 b7 13 	call	0x276e	; 0x276e <EEPROMClass::update(int, unsigned char) [clone .isra.2]>
    385c:	eb ce       	rjmp	.-554    	; 0x3634 <main+0x830>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:588
        clockMode = !clockMode;                   // Toggle Z80 clock speed mode (High/Low)
        EEPROM.update(clockModeAddr, clockMode);  // Save it to the internal EEPROM
        break;

      case '7':                                   // Toggle CP/M AUTOEXEC execution on cold boot
        autoexecFlag = !autoexecFlag;             // Toggle AUTOEXEC executiont status
    385e:	61 e0       	ldi	r22, 0x01	; 1
    3860:	80 91 d6 01 	lds	r24, 0x01D6	; 0x8001d6 <autoexecFlag>
    3864:	81 11       	cpse	r24, r1
    3866:	60 e0       	ldi	r22, 0x00	; 0
    3868:	60 93 d6 01 	sts	0x01D6, r22	; 0x8001d6 <autoexecFlag>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:589
        EEPROM.update(autoexecFlagAddr, autoexecFlag); // Save it to the internal EEPROM
    386c:	8c e0       	ldi	r24, 0x0C	; 12
    386e:	90 e0       	ldi	r25, 0x00	; 0
    3870:	f3 cf       	rjmp	.-26     	; 0x3858 <main+0xa54>
printMsg1():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2101

// ------------------------------------------------------------------------------

void printMsg1()
{
  Serial.println(F("\r\nPress CR to accept, ESC to exit or any other key to change"));
    3872:	80 ea       	ldi	r24, 0xA0	; 160
    3874:	94 e0       	ldi	r25, 0x04	; 4
    3876:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:594
        EEPROM.update(autoexecFlagAddr, autoexecFlag); // Save it to the internal EEPROM
        break;

      case '8':                                   // Change serial port speed
        printMsg1();
        iCount = EEPROM.read(serBaudAddr);        // Read the serial speed index
    387a:	8f e0       	ldi	r24, 0x0F	; 15
    387c:	90 e0       	ldi	r25, 0x00	; 0
    387e:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:595
        iCount = (byte) (iCount - 1);             // Set the previous speed index
    3882:	81 50       	subi	r24, 0x01	; 1
    3884:	80 93 cb 01 	sts	0x01CB, r24	; 0x8001cb <iCount>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:599
        do
        {
          // Print the current serial speed
          iCount = (byte)(iCount + 1) % maxBaudIndex;
    3888:	0a e0       	ldi	r16, 0x0A	; 10
    388a:	80 91 cb 01 	lds	r24, 0x01CB	; 0x8001cb <iCount>
    388e:	8f 5f       	subi	r24, 0xFF	; 255
    3890:	60 2f       	mov	r22, r16
    3892:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    3896:	19 2f       	mov	r17, r25
    3898:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <iCount>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:600
          Serial.print(F("\r ->"));
    389c:	8d e4       	ldi	r24, 0x4D	; 77
    389e:	96 e0       	ldi	r25, 0x06	; 6
    38a0:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
    38a4:	60 e0       	ldi	r22, 0x00	; 0
    38a6:	72 ec       	ldi	r23, 0xC2	; 194
    38a8:	81 e0       	ldi	r24, 0x01	; 1
    38aa:	90 e0       	ldi	r25, 0x00	; 0
    38ac:	19 30       	cpi	r17, 0x09	; 9
    38ae:	51 f0       	breq	.+20     	; 0x38c4 <main+0xac0>
    38b0:	e1 2f       	mov	r30, r17
    38b2:	f0 e0       	ldi	r31, 0x00	; 0
    38b4:	ee 0f       	add	r30, r30
    38b6:	ff 1f       	adc	r31, r31
    38b8:	ec 56       	subi	r30, 0x6C	; 108
    38ba:	ff 4f       	sbci	r31, 0xFF	; 255
    38bc:	60 81       	ld	r22, Z
    38be:	71 81       	ldd	r23, Z+1	; 0x01
    38c0:	90 e0       	ldi	r25, 0x00	; 0
    38c2:	80 e0       	ldi	r24, 0x00	; 0
print():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    38c4:	4a e0       	ldi	r20, 0x0A	; 10
    38c6:	0e 94 62 11 	call	0x22c4	; 0x22c4 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.53]>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:602
          Serial.print(indexToBaud(iCount));      // Print current serial speed
          Serial.print(F("   \r"));
    38ca:	88 e4       	ldi	r24, 0x48	; 72
    38cc:	96 e0       	ldi	r25, 0x06	; 6
    38ce:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:603
          while (Serial.available() > 0) Serial.read(); // Flush serial Rx buffer
    38d2:	86 ea       	ldi	r24, 0xA6	; 166
    38d4:	92 e0       	ldi	r25, 0x02	; 2
    38d6:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
    38da:	18 16       	cp	r1, r24
    38dc:	19 06       	cpc	r1, r25
    38de:	2c f4       	brge	.+10     	; 0x38ea <main+0xae6>
    38e0:	86 ea       	ldi	r24, 0xA6	; 166
    38e2:	92 e0       	ldi	r25, 0x02	; 2
    38e4:	0e 94 1d 05 	call	0xa3a	; 0xa3a <HardwareSerial::read()>
    38e8:	f4 cf       	rjmp	.-24     	; 0x38d2 <main+0xace>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:604
          while (Serial.available() < 1) WaitAndBlink(BLK); // Wait a key
    38ea:	86 ea       	ldi	r24, 0xA6	; 166
    38ec:	92 e0       	ldi	r25, 0x02	; 2
    38ee:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
    38f2:	18 16       	cp	r1, r24
    38f4:	19 06       	cpc	r1, r25
    38f6:	1c f0       	brlt	.+6      	; 0x38fe <main+0xafa>
    38f8:	0e 94 cd 13 	call	0x279a	; 0x279a <WaitAndBlink(baudRecCheck) [clone .constprop.33]>
    38fc:	f6 cf       	rjmp	.-20     	; 0x38ea <main+0xae6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:605
          inChar = Serial.read();
    38fe:	86 ea       	ldi	r24, 0xA6	; 166
    3900:	92 e0       	ldi	r25, 0x02	; 2
    3902:	0e 94 1d 05 	call	0xa3a	; 0xa3a <HardwareSerial::read()>
    3906:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <inChar>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:607
        }
        while ((inChar != 13) && (inChar != 27)); // Continue until a CR or ESC is pressed
    390a:	8d 30       	cpi	r24, 0x0D	; 13
    390c:	19 f0       	breq	.+6      	; 0x3914 <main+0xb10>
    390e:	8b 31       	cpi	r24, 0x1B	; 27
    3910:	09 f0       	breq	.+2      	; 0x3914 <main+0xb10>
    3912:	bb cf       	rjmp	.-138    	; 0x388a <main+0xa86>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:608
        Serial.println();
    3914:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:609
        Serial.println();
    3918:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:610
        if ((inChar == 13) && (iCount != EEPROM.read(serBaudAddr)))
    391c:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <inChar>
    3920:	8d 30       	cpi	r24, 0x0D	; 13
    3922:	09 f0       	breq	.+2      	; 0x3926 <main+0xb22>
    3924:	87 ce       	rjmp	.-754    	; 0x3634 <main+0x830>
    3926:	8f e0       	ldi	r24, 0x0F	; 15
    3928:	90 e0       	ldi	r25, 0x00	; 0
    392a:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
    392e:	60 91 cb 01 	lds	r22, 0x01CB	; 0x8001cb <iCount>
    3932:	86 17       	cp	r24, r22
    3934:	11 f4       	brne	.+4      	; 0x393a <main+0xb36>
    3936:	0c 94 ae 24 	jmp	0x495c	; 0x495c <main+0x1b58>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:613
          // Store new serial speed index
        {
          EEPROM.update(serBaudAddr, iCount);
    393a:	8f e0       	ldi	r24, 0x0F	; 15
    393c:	90 e0       	ldi	r25, 0x00	; 0
    393e:	0e 94 b7 13 	call	0x276e	; 0x276e <EEPROMClass::update(int, unsigned char) [clone .isra.2]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:614
          Serial.println(F("Changed speed will be effective after next reboot!\r\n\n"));
    3942:	82 e1       	ldi	r24, 0x12	; 18
    3944:	96 e0       	ldi	r25, 0x06	; 6
    3946:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
    394a:	74 ce       	rjmp	.-792    	; 0x3634 <main+0x830>
ChangeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2397
  do
  {
    do
    {
      Serial.print(F(" "));
      switch (tempByte)
    394c:	84 30       	cpi	r24, 0x04	; 4
    394e:	91 f1       	breq	.+100    	; 0x39b4 <main+0xbb0>
    3950:	50 f1       	brcs	.+84     	; 0x39a6 <main+0xba2>
    3952:	85 30       	cpi	r24, 0x05	; 5
    3954:	09 f0       	breq	.+2      	; 0x3958 <main+0xb54>
    3956:	03 cf       	rjmp	.-506    	; 0x375e <main+0x95a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2427
          Serial.print(F("Minutes -> "));
          print2digit(minutes);
          break;

        case 5:
          Serial.print(F("Seconds -> "));
    3958:	8a e0       	ldi	r24, 0x0A	; 10
    395a:	95 e0       	ldi	r25, 0x05	; 5
    395c:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2428
          print2digit(seconds);
    3960:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <seconds>
    3964:	06 c0       	rjmp	.+12     	; 0x3972 <main+0xb6e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2400
    {
      Serial.print(F(" "));
      switch (tempByte)
      {
        case 0:
          Serial.print(F("Year -> "));
    3966:	8d e4       	ldi	r24, 0x4D	; 77
    3968:	95 e0       	ldi	r25, 0x05	; 5
    396a:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2401
          print2digit(year);
    396e:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <year>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2428
          print2digit(minutes);
          break;

        case 5:
          Serial.print(F("Seconds -> "));
          print2digit(seconds);
    3972:	0e 94 b3 12 	call	0x2566	; 0x2566 <print2digit(unsigned char)>
    3976:	f3 ce       	rjmp	.-538    	; 0x375e <main+0x95a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2405
          Serial.print(F("Year -> "));
          print2digit(year);
          break;

        case 1:
          Serial.print(F("Month -> "));
    3978:	83 e4       	ldi	r24, 0x43	; 67
    397a:	95 e0       	ldi	r25, 0x05	; 5
    397c:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2406
          print2digit(month);
    3980:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <month>
    3984:	f6 cf       	rjmp	.-20     	; 0x3972 <main+0xb6e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2410
          break;

        case 2:
          Serial.print(F("             "));
    3986:	85 e3       	ldi	r24, 0x35	; 53
    3988:	95 e0       	ldi	r25, 0x05	; 5
    398a:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.h:133
    398e:	6d e0       	ldi	r22, 0x0D	; 13
    3990:	86 ea       	ldi	r24, 0xA6	; 166
    3992:	92 e0       	ldi	r25, 0x02	; 2
    3994:	0e 94 76 05 	call	0xaec	; 0xaec <HardwareSerial::write(unsigned char)>
ChangeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2412
          Serial.write(13);
          Serial.print(F(" Day -> "));
    3998:	8c e2       	ldi	r24, 0x2C	; 44
    399a:	95 e0       	ldi	r25, 0x05	; 5
    399c:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2413
          print2digit(day);
    39a0:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <day>
    39a4:	e6 cf       	rjmp	.-52     	; 0x3972 <main+0xb6e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2417
          break;

        case 3:
          Serial.print(F("Hours -> "));
    39a6:	82 e2       	ldi	r24, 0x22	; 34
    39a8:	95 e0       	ldi	r25, 0x05	; 5
    39aa:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2418
          print2digit(hours);
    39ae:	80 91 25 02 	lds	r24, 0x0225	; 0x800225 <hours>
    39b2:	df cf       	rjmp	.-66     	; 0x3972 <main+0xb6e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2422
          break;

        case 4:
          Serial.print(F("Minutes -> "));
    39b4:	86 e1       	ldi	r24, 0x16	; 22
    39b6:	95 e0       	ldi	r25, 0x05	; 5
    39b8:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2423
          print2digit(minutes);
    39bc:	80 91 26 02 	lds	r24, 0x0226	; 0x800226 <minutes>
    39c0:	d8 cf       	rjmp	.-80     	; 0x3972 <main+0xb6e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2441
      }
      while ((inChar != 'u') && (inChar != 'U') && (inChar != 't') && (inChar != 'T') && (inChar != 13));

      if ((inChar == 'u') || (inChar == 'U'))
        // Change units
        switch (tempByte)
    39c2:	10 91 f2 01 	lds	r17, 0x01F2	; 0x8001f2 <tempByte>
    39c6:	12 30       	cpi	r17, 0x02	; 2
    39c8:	09 f4       	brne	.+2      	; 0x39cc <main+0xbc8>
    39ca:	66 c0       	rjmp	.+204    	; 0x3a98 <main+0xc94>
    39cc:	e8 f5       	brcc	.+122    	; 0x3a48 <main+0xc44>
    39ce:	11 23       	and	r17, r17
    39d0:	09 f4       	brne	.+2      	; 0x39d4 <main+0xbd0>
    39d2:	4c c0       	rjmp	.+152    	; 0x3a6c <main+0xc68>
    39d4:	11 30       	cpi	r17, 0x01	; 1
    39d6:	09 f4       	brne	.+2      	; 0x39da <main+0xbd6>
    39d8:	54 c0       	rjmp	.+168    	; 0x3a82 <main+0xc7e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2480
          case 5:
            seconds++;
            if (seconds > 59) seconds = 0;
            break;
        }
      if ((inChar == 't') || (inChar == 'T'))
    39da:	80 2f       	mov	r24, r16
    39dc:	8f 7d       	andi	r24, 0xDF	; 223
    39de:	84 35       	cpi	r24, 0x54	; 84
    39e0:	11 f0       	breq	.+4      	; 0x39e6 <main+0xbe2>
    39e2:	0c 94 bd 24 	jmp	0x497a	; 0x497a <main+0x1b76>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2482
        // Change tens
        switch (tempByte)
    39e6:	12 30       	cpi	r17, 0x02	; 2
    39e8:	09 f4       	brne	.+2      	; 0x39ec <main+0xbe8>
    39ea:	c7 c0       	rjmp	.+398    	; 0x3b7a <main+0xd76>
    39ec:	08 f0       	brcs	.+2      	; 0x39f0 <main+0xbec>
    39ee:	8c c0       	rjmp	.+280    	; 0x3b08 <main+0xd04>
    39f0:	11 23       	and	r17, r17
    39f2:	09 f4       	brne	.+2      	; 0x39f6 <main+0xbf2>
    39f4:	a3 c0       	rjmp	.+326    	; 0x3b3c <main+0xd38>
    39f6:	11 30       	cpi	r17, 0x01	; 1
    39f8:	09 f4       	brne	.+2      	; 0x39fc <main+0xbf8>
    39fa:	b2 c0       	rjmp	.+356    	; 0x3b60 <main+0xd5c>
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.h:133
    39fc:	6d e0       	ldi	r22, 0x0D	; 13
    39fe:	86 ea       	ldi	r24, 0xA6	; 166
    3a00:	92 e0       	ldi	r25, 0x02	; 2
    3a02:	0e 94 76 05 	call	0xaec	; 0xaec <HardwareSerial::write(unsigned char)>
ChangeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2517
            if (seconds > 59) seconds = seconds - (seconds / 10 ) * 10;
            break;
        }
      Serial.write(13);
    }
    while (inChar != 13);
    3a06:	0d 30       	cpi	r16, 0x0D	; 13
    3a08:	09 f0       	breq	.+2      	; 0x3a0c <main+0xc08>
    3a0a:	98 ce       	rjmp	.-720    	; 0x373c <main+0x938>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2518
    tempByte++;
    3a0c:	1f 5f       	subi	r17, 0xFF	; 255
    3a0e:	10 93 f2 01 	sts	0x01F2, r17	; 0x8001f2 <tempByte>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2520
  }
  while (tempByte < 6);
    3a12:	16 30       	cpi	r17, 0x06	; 6
    3a14:	08 f4       	brcc	.+2      	; 0x3a18 <main+0xc14>
    3a16:	92 ce       	rjmp	.-732    	; 0x373c <main+0x938>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2523

  // Write new date/time into the RTC
  writeRTC(seconds, minutes, hours, day, month, year);
    3a18:	40 91 00 02 	lds	r20, 0x0200	; 0x800200 <year>
    3a1c:	60 91 01 02 	lds	r22, 0x0201	; 0x800201 <month>
    3a20:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <day>
    3a24:	0e 94 3a 08 	call	0x1074	; 0x1074 <writeRTC(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char) [clone .constprop.27]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2524
  Serial.println(F(" ...done      \n"));
    3a28:	8a ef       	ldi	r24, 0xFA	; 250
    3a2a:	94 e0       	ldi	r25, 0x04	; 4
    3a2c:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2525
  Serial.print(F("IOS: RTC date/time updated ("));
    3a30:	8d ed       	ldi	r24, 0xDD	; 221
    3a32:	94 e0       	ldi	r25, 0x04	; 4
    3a34:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2526
  printDateTime(1);
    3a38:	81 e0       	ldi	r24, 0x01	; 1
    3a3a:	0e 94 c5 12 	call	0x258a	; 0x258a <printDateTime(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2527
  Serial.println(")");
    3a3e:	8c ed       	ldi	r24, 0xDC	; 220
    3a40:	90 e0       	ldi	r25, 0x00	; 0
    3a42:	0e 94 02 12 	call	0x2404	; 0x2404 <Print::println(char const*) [clone .constprop.48]>
    3a46:	f6 cd       	rjmp	.-1044   	; 0x3634 <main+0x830>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2441
      }
      while ((inChar != 'u') && (inChar != 'U') && (inChar != 't') && (inChar != 'T') && (inChar != 13));

      if ((inChar == 'u') || (inChar == 'U'))
        // Change units
        switch (tempByte)
    3a48:	14 30       	cpi	r17, 0x04	; 4
    3a4a:	09 f4       	brne	.+2      	; 0x3a4e <main+0xc4a>
    3a4c:	52 c0       	rjmp	.+164    	; 0x3af2 <main+0xcee>
    3a4e:	08 f4       	brcc	.+2      	; 0x3a52 <main+0xc4e>
    3a50:	45 c0       	rjmp	.+138    	; 0x3adc <main+0xcd8>
    3a52:	15 30       	cpi	r17, 0x05	; 5
    3a54:	11 f6       	brne	.-124    	; 0x39da <main+0xbd6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2476
            minutes++;
            if (minutes > 59) minutes = 0;
            break;

          case 5:
            seconds++;
    3a56:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <seconds>
    3a5a:	8f 5f       	subi	r24, 0xFF	; 255
    3a5c:	80 93 27 02 	sts	0x0227, r24	; 0x800227 <seconds>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2477
            if (seconds > 59) seconds = 0;
    3a60:	8c 33       	cpi	r24, 0x3C	; 60
    3a62:	08 f4       	brcc	.+2      	; 0x3a66 <main+0xc62>
    3a64:	ba cf       	rjmp	.-140    	; 0x39da <main+0xbd6>
    3a66:	10 92 27 02 	sts	0x0227, r1	; 0x800227 <seconds>
    3a6a:	b7 cf       	rjmp	.-146    	; 0x39da <main+0xbd6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2444
      if ((inChar == 'u') || (inChar == 'U'))
        // Change units
        switch (tempByte)
        {
          case 0:
            year++;
    3a6c:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <year>
    3a70:	8f 5f       	subi	r24, 0xFF	; 255
    3a72:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <year>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2445
            if (year > 99) year = 0;
    3a76:	84 36       	cpi	r24, 0x64	; 100
    3a78:	08 f4       	brcc	.+2      	; 0x3a7c <main+0xc78>
    3a7a:	af cf       	rjmp	.-162    	; 0x39da <main+0xbd6>
    3a7c:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <year>
    3a80:	ac cf       	rjmp	.-168    	; 0x39da <main+0xbd6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2449
            break;

          case 1:
            month++;
    3a82:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <month>
    3a86:	8f 5f       	subi	r24, 0xFF	; 255
    3a88:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <month>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2450
            if (month > 12) month = 1;
    3a8c:	8d 30       	cpi	r24, 0x0D	; 13
    3a8e:	08 f4       	brcc	.+2      	; 0x3a92 <main+0xc8e>
    3a90:	a4 cf       	rjmp	.-184    	; 0x39da <main+0xbd6>
    3a92:	10 93 01 02 	sts	0x0201, r17	; 0x800201 <month>
    3a96:	a1 cf       	rjmp	.-190    	; 0x39da <main+0xbd6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2454
            break;

          case 2:
            day++;
    3a98:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <day>
    3a9c:	8f 5f       	subi	r24, 0xFF	; 255
    3a9e:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <day>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2455
            if (month == 2)
    3aa2:	e0 91 01 02 	lds	r30, 0x0201	; 0x800201 <month>
    3aa6:	e2 30       	cpi	r30, 0x02	; 2
    3aa8:	89 f4       	brne	.+34     	; 0x3acc <main+0xcc8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2457
            {
              if (day > (daysOfMonth[month - 1] + isLeapYear(year))) day = 1;
    3aaa:	90 e0       	ldi	r25, 0x00	; 0
    3aac:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <year>
    3ab0:	23 70       	andi	r18, 0x03	; 3
    3ab2:	49 f4       	brne	.+18     	; 0x3ac6 <main+0xcc2>
    3ab4:	2d e1       	ldi	r18, 0x1D	; 29
    3ab6:	30 e0       	ldi	r19, 0x00	; 0
    3ab8:	28 17       	cp	r18, r24
    3aba:	39 07       	cpc	r19, r25
    3abc:	0c f0       	brlt	.+2      	; 0x3ac0 <main+0xcbc>
    3abe:	8d cf       	rjmp	.-230    	; 0x39da <main+0xbd6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2461
            }
            else
            {
              if (day > (daysOfMonth[month - 1])) day = 1;
    3ac0:	d0 92 02 02 	sts	0x0202, r13	; 0x800202 <day>
    3ac4:	8a cf       	rjmp	.-236    	; 0x39da <main+0xbd6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2457

          case 2:
            day++;
            if (month == 2)
            {
              if (day > (daysOfMonth[month - 1] + isLeapYear(year))) day = 1;
    3ac6:	2c e1       	ldi	r18, 0x1C	; 28
    3ac8:	30 e0       	ldi	r19, 0x00	; 0
    3aca:	f6 cf       	rjmp	.-20     	; 0x3ab8 <main+0xcb4>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2461
            }
            else
            {
              if (day > (daysOfMonth[month - 1])) day = 1;
    3acc:	f0 e0       	ldi	r31, 0x00	; 0
    3ace:	e9 57       	subi	r30, 0x79	; 121
    3ad0:	ff 4f       	sbci	r31, 0xFF	; 255
    3ad2:	90 81       	ld	r25, Z
    3ad4:	98 17       	cp	r25, r24
    3ad6:	08 f0       	brcs	.+2      	; 0x3ada <main+0xcd6>
    3ad8:	80 cf       	rjmp	.-256    	; 0x39da <main+0xbd6>
    3ada:	f2 cf       	rjmp	.-28     	; 0x3ac0 <main+0xcbc>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2466
            }
            break;

          case 3:
            hours++;
    3adc:	80 91 25 02 	lds	r24, 0x0225	; 0x800225 <hours>
    3ae0:	8f 5f       	subi	r24, 0xFF	; 255
    3ae2:	80 93 25 02 	sts	0x0225, r24	; 0x800225 <hours>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2467
            if (hours > 23) hours = 0;
    3ae6:	88 31       	cpi	r24, 0x18	; 24
    3ae8:	08 f4       	brcc	.+2      	; 0x3aec <main+0xce8>
    3aea:	77 cf       	rjmp	.-274    	; 0x39da <main+0xbd6>
    3aec:	10 92 25 02 	sts	0x0225, r1	; 0x800225 <hours>
    3af0:	74 cf       	rjmp	.-280    	; 0x39da <main+0xbd6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2471
            break;

          case 4:
            minutes++;
    3af2:	80 91 26 02 	lds	r24, 0x0226	; 0x800226 <minutes>
    3af6:	8f 5f       	subi	r24, 0xFF	; 255
    3af8:	80 93 26 02 	sts	0x0226, r24	; 0x800226 <minutes>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2472
            if (minutes > 59) minutes = 0;
    3afc:	8c 33       	cpi	r24, 0x3C	; 60
    3afe:	08 f4       	brcc	.+2      	; 0x3b02 <main+0xcfe>
    3b00:	6c cf       	rjmp	.-296    	; 0x39da <main+0xbd6>
    3b02:	10 92 26 02 	sts	0x0226, r1	; 0x800226 <minutes>
    3b06:	69 cf       	rjmp	.-302    	; 0x39da <main+0xbd6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2482
            if (seconds > 59) seconds = 0;
            break;
        }
      if ((inChar == 't') || (inChar == 'T'))
        // Change tens
        switch (tempByte)
    3b08:	14 30       	cpi	r17, 0x04	; 4
    3b0a:	09 f4       	brne	.+2      	; 0x3b0e <main+0xd0a>
    3b0c:	73 c0       	rjmp	.+230    	; 0x3bf4 <main+0xdf0>
    3b0e:	08 f4       	brcc	.+2      	; 0x3b12 <main+0xd0e>
    3b10:	5f c0       	rjmp	.+190    	; 0x3bd0 <main+0xdcc>
    3b12:	15 30       	cpi	r17, 0x05	; 5
    3b14:	09 f0       	breq	.+2      	; 0x3b18 <main+0xd14>
    3b16:	72 cf       	rjmp	.-284    	; 0x39fc <main+0xbf8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2511
            minutes = minutes + 10;
            if (minutes > 59) minutes = minutes - (minutes / 10 ) * 10;
            break;

          case 5:
            seconds = seconds + 10;
    3b18:	20 91 27 02 	lds	r18, 0x0227	; 0x800227 <seconds>
    3b1c:	26 5f       	subi	r18, 0xF6	; 246
    3b1e:	20 93 27 02 	sts	0x0227, r18	; 0x800227 <seconds>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2512
            if (seconds > 59) seconds = seconds - (seconds / 10 ) * 10;
    3b22:	2c 33       	cpi	r18, 0x3C	; 60
    3b24:	08 f4       	brcc	.+2      	; 0x3b28 <main+0xd24>
    3b26:	29 c7       	rjmp	.+3666   	; 0x497a <main+0x1b76>
    3b28:	82 2f       	mov	r24, r18
    3b2a:	6f 2d       	mov	r22, r15
    3b2c:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    3b30:	8e 9d       	mul	r24, r14
    3b32:	20 0d       	add	r18, r0
    3b34:	11 24       	eor	r1, r1
    3b36:	20 93 27 02 	sts	0x0227, r18	; 0x800227 <seconds>
    3b3a:	60 cf       	rjmp	.-320    	; 0x39fc <main+0xbf8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2485
      if ((inChar == 't') || (inChar == 'T'))
        // Change tens
        switch (tempByte)
        {
          case 0:
            year = year + 10;
    3b3c:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <year>
    3b40:	26 5f       	subi	r18, 0xF6	; 246
    3b42:	20 93 00 02 	sts	0x0200, r18	; 0x800200 <year>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2486
            if (year > 99) year = year - (year / 10) * 10;
    3b46:	24 36       	cpi	r18, 0x64	; 100
    3b48:	08 f4       	brcc	.+2      	; 0x3b4c <main+0xd48>
    3b4a:	17 c7       	rjmp	.+3630   	; 0x497a <main+0x1b76>
    3b4c:	82 2f       	mov	r24, r18
    3b4e:	6f 2d       	mov	r22, r15
    3b50:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    3b54:	8e 9d       	mul	r24, r14
    3b56:	20 0d       	add	r18, r0
    3b58:	11 24       	eor	r1, r1
    3b5a:	20 93 00 02 	sts	0x0200, r18	; 0x800200 <year>
    3b5e:	4e cf       	rjmp	.-356    	; 0x39fc <main+0xbf8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2490
            break;

          case 1:
            if (month > 10) month = month - 10;
    3b60:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <month>
    3b64:	8b 30       	cpi	r24, 0x0B	; 11
    3b66:	20 f0       	brcs	.+8      	; 0x3b70 <main+0xd6c>
    3b68:	8a 50       	subi	r24, 0x0A	; 10
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2491
            else if (month < 3) month = month + 10;
    3b6a:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <month>
    3b6e:	46 cf       	rjmp	.-372    	; 0x39fc <main+0xbf8>
    3b70:	83 30       	cpi	r24, 0x03	; 3
    3b72:	08 f0       	brcs	.+2      	; 0x3b76 <main+0xd72>
    3b74:	02 c7       	rjmp	.+3588   	; 0x497a <main+0x1b76>
    3b76:	86 5f       	subi	r24, 0xF6	; 246
    3b78:	f8 cf       	rjmp	.-16     	; 0x3b6a <main+0xd66>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2495
            break;

          case 2:
            day = day + 10;
    3b7a:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <day>
    3b7e:	26 5f       	subi	r18, 0xF6	; 246
    3b80:	20 93 02 02 	sts	0x0202, r18	; 0x800202 <day>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2496
            if (day > (daysOfMonth[month - 1] + isLeapYear(year))) day = day - (day / 10) * 10;
    3b84:	42 2f       	mov	r20, r18
    3b86:	50 e0       	ldi	r21, 0x00	; 0
    3b88:	e0 91 01 02 	lds	r30, 0x0201	; 0x800201 <month>
    3b8c:	f0 e0       	ldi	r31, 0x00	; 0
    3b8e:	e9 57       	subi	r30, 0x79	; 121
    3b90:	ff 4f       	sbci	r31, 0xFF	; 255
    3b92:	80 81       	ld	r24, Z
    3b94:	90 e0       	ldi	r25, 0x00	; 0
isLeapYear():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2374
byte isLeapYear(byte yearXX)
// Check if the year 2000+XX (where XX is the argument yearXX [00..99]) is a leap year.
// Returns 1 if it is leap, 0 otherwise.
// This function works in the [2000..2099] years range. It should be enough...
{
  if (((2000 + yearXX) % 4) == 0) return 1;
    3b96:	30 91 00 02 	lds	r19, 0x0200	; 0x800200 <year>
    3b9a:	33 70       	andi	r19, 0x03	; 3
    3b9c:	61 e0       	ldi	r22, 0x01	; 1
    3b9e:	70 e0       	ldi	r23, 0x00	; 0
    3ba0:	11 f0       	breq	.+4      	; 0x3ba6 <main+0xda2>
    3ba2:	70 e0       	ldi	r23, 0x00	; 0
    3ba4:	60 e0       	ldi	r22, 0x00	; 0
ChangeRTC():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2496
            else if (month < 3) month = month + 10;
            break;

          case 2:
            day = day + 10;
            if (day > (daysOfMonth[month - 1] + isLeapYear(year))) day = day - (day / 10) * 10;
    3ba6:	86 0f       	add	r24, r22
    3ba8:	97 1f       	adc	r25, r23
    3baa:	84 17       	cp	r24, r20
    3bac:	95 07       	cpc	r25, r21
    3bae:	4c f4       	brge	.+18     	; 0x3bc2 <main+0xdbe>
    3bb0:	82 2f       	mov	r24, r18
    3bb2:	6f 2d       	mov	r22, r15
    3bb4:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    3bb8:	8e 9d       	mul	r24, r14
    3bba:	20 0d       	add	r18, r0
    3bbc:	11 24       	eor	r1, r1
    3bbe:	20 93 02 02 	sts	0x0202, r18	; 0x800202 <day>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2497
            if (day == 0) day = 1;
    3bc2:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <day>
    3bc6:	81 11       	cpse	r24, r1
    3bc8:	d8 c6       	rjmp	.+3504   	; 0x497a <main+0x1b76>
    3bca:	d0 92 02 02 	sts	0x0202, r13	; 0x800202 <day>
    3bce:	16 cf       	rjmp	.-468    	; 0x39fc <main+0xbf8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2501
            break;

          case 3:
            hours = hours + 10;
    3bd0:	20 91 25 02 	lds	r18, 0x0225	; 0x800225 <hours>
    3bd4:	26 5f       	subi	r18, 0xF6	; 246
    3bd6:	20 93 25 02 	sts	0x0225, r18	; 0x800225 <hours>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2502
            if (hours > 23) hours = hours - (hours / 10 ) * 10;
    3bda:	28 31       	cpi	r18, 0x18	; 24
    3bdc:	08 f4       	brcc	.+2      	; 0x3be0 <main+0xddc>
    3bde:	cd c6       	rjmp	.+3482   	; 0x497a <main+0x1b76>
    3be0:	82 2f       	mov	r24, r18
    3be2:	6f 2d       	mov	r22, r15
    3be4:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    3be8:	8e 9d       	mul	r24, r14
    3bea:	20 0d       	add	r18, r0
    3bec:	11 24       	eor	r1, r1
    3bee:	20 93 25 02 	sts	0x0225, r18	; 0x800225 <hours>
    3bf2:	04 cf       	rjmp	.-504    	; 0x39fc <main+0xbf8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2506
            break;

          case 4:
            minutes = minutes + 10;
    3bf4:	20 91 26 02 	lds	r18, 0x0226	; 0x800226 <minutes>
    3bf8:	26 5f       	subi	r18, 0xF6	; 246
    3bfa:	20 93 26 02 	sts	0x0226, r18	; 0x800226 <minutes>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2507
            if (minutes > 59) minutes = minutes - (minutes / 10 ) * 10;
    3bfe:	2c 33       	cpi	r18, 0x3C	; 60
    3c00:	08 f4       	brcc	.+2      	; 0x3c04 <main+0xe00>
    3c02:	bb c6       	rjmp	.+3446   	; 0x497a <main+0x1b76>
    3c04:	82 2f       	mov	r24, r18
    3c06:	6f 2d       	mov	r22, r15
    3c08:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    3c0c:	8e 9d       	mul	r24, r14
    3c0e:	20 0d       	add	r18, r0
    3c10:	11 24       	eor	r1, r1
    3c12:	20 93 26 02 	sts	0x0226, r18	; 0x800226 <minutes>
    3c16:	f2 ce       	rjmp	.-540    	; 0x39fc <main+0xbf8>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:643
  // ----------------------------------------
  // Z80 PROGRAM LOAD
  // ----------------------------------------

  // Get the starting address of the program to load and boot, and its size if stored in the flash
  switch (bootMode)
    3c18:	13 30       	cpi	r17, 0x03	; 3
    3c1a:	09 f4       	brne	.+2      	; 0x3c1e <main+0xe1a>
    3c1c:	6f c0       	rjmp	.+222    	; 0x3cfc <main+0xef8>
    3c1e:	14 30       	cpi	r17, 0x04	; 4
    3c20:	09 f0       	breq	.+2      	; 0x3c24 <main+0xe20>
    3c22:	32 cd       	rjmp	.-1436   	; 0x3688 <main+0x884>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:699
      fileNameSD = AUTOFN;
      BootStrAddr = AUTSTRADDR;
      break;

    case 4:                                       // Load iLoad from flash
      BootImage = (byte *) pgm_read_word (&flahBootTable[0]);
    3c24:	e2 e0       	ldi	r30, 0x02	; 2
    3c26:	f6 e0       	ldi	r31, 0x06	; 6
    3c28:	85 91       	lpm	r24, Z+
    3c2a:	94 91       	lpm	r25, Z
    3c2c:	90 93 c6 01 	sts	0x01C6, r25	; 0x8001c6 <BootImage+0x1>
    3c30:	80 93 c5 01 	sts	0x01C5, r24	; 0x8001c5 <BootImage>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:700
      BootImageSize = sizeof(boot_A_);
    3c34:	8a e6       	ldi	r24, 0x6A	; 106
    3c36:	92 e0       	ldi	r25, 0x02	; 2
    3c38:	90 93 c4 01 	sts	0x01C4, r25	; 0x8001c4 <BootImageSize+0x1>
    3c3c:	80 93 c3 01 	sts	0x01C3, r24	; 0x8001c3 <BootImageSize>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:701
      BootStrAddr = boot_A_StrAddr;
    3c40:	80 e1       	ldi	r24, 0x10	; 16
    3c42:	9d ef       	ldi	r25, 0xFD	; 253
    3c44:	3f c0       	rjmp	.+126    	; 0x3cc4 <main+0xec0>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:646

  // Get the starting address of the program to load and boot, and its size if stored in the flash
  switch (bootMode)
  {
    case 0:                                       // Load Basic from SD
      fileNameSD = BASICFN;
    3c46:	8c e0       	ldi	r24, 0x0C	; 12
    3c48:	91 e0       	ldi	r25, 0x01	; 1
    3c4a:	90 93 ca 01 	sts	0x01CA, r25	; 0x8001ca <fileNameSD+0x1>
    3c4e:	80 93 c9 01 	sts	0x01C9, r24	; 0x8001c9 <fileNameSD>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:647
      BootStrAddr = BASSTRADDR;
    3c52:	10 92 c8 01 	sts	0x01C8, r1	; 0x8001c8 <BootStrAddr+0x1>
    3c56:	10 92 c7 01 	sts	0x01C7, r1	; 0x8001c7 <BootStrAddr>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:648
      Z80IntRx = 1;                               // Enable Z80 Rx INT_ interrupt signal generation (Z80 M1 INT I/O)
    3c5a:	81 e0       	ldi	r24, 0x01	; 1
    3c5c:	80 93 f0 01 	sts	0x01F0, r24	; 0x8001f0 <Z80IntRx>
    3c60:	13 cd       	rjmp	.-1498   	; 0x3688 <main+0x884>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:657
      fileNameSD = FORTHFN;
      BootStrAddr = FORSTRADDR;
      break;

    case 2:                                       // Load an OS from current Disk Set on SD
      switch (diskSet)
    3c62:	80 91 f6 01 	lds	r24, 0x01F6	; 0x8001f6 <diskSet>
    3c66:	82 30       	cpi	r24, 0x02	; 2
    3c68:	91 f1       	breq	.+100    	; 0x3cce <main+0xeca>
    3c6a:	70 f4       	brcc	.+28     	; 0x3c88 <main+0xe84>
    3c6c:	88 23       	and	r24, r24
    3c6e:	11 f1       	breq	.+68     	; 0x3cb4 <main+0xeb0>
    3c70:	81 30       	cpi	r24, 0x01	; 1
    3c72:	09 f0       	breq	.+2      	; 0x3c76 <main+0xe72>
    3c74:	09 cd       	rjmp	.-1518   	; 0x3688 <main+0x884>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:665
          fileNameSD = CPMFN;
          BootStrAddr = CPMSTRADDR;
          break;

        case 1:                                     // QP/M 2.71
          fileNameSD = QPMFN;
    3c76:	8e e2       	ldi	r24, 0x2E	; 46
    3c78:	91 e0       	ldi	r25, 0x01	; 1
    3c7a:	90 93 ca 01 	sts	0x01CA, r25	; 0x8001ca <fileNameSD+0x1>
    3c7e:	80 93 c9 01 	sts	0x01C9, r24	; 0x8001c9 <fileNameSD>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:666
          BootStrAddr = QPMSTRADDR;
    3c82:	80 e8       	ldi	r24, 0x80	; 128
    3c84:	90 e0       	ldi	r25, 0x00	; 0
    3c86:	1e c0       	rjmp	.+60     	; 0x3cc4 <main+0xec0>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:657
      fileNameSD = FORTHFN;
      BootStrAddr = FORSTRADDR;
      break;

    case 2:                                       // Load an OS from current Disk Set on SD
      switch (diskSet)
    3c88:	84 30       	cpi	r24, 0x04	; 4
    3c8a:	a9 f1       	breq	.+106    	; 0x3cf6 <main+0xef2>
    3c8c:	48 f1       	brcs	.+82     	; 0x3ce0 <main+0xedc>
    3c8e:	85 30       	cpi	r24, 0x05	; 5
    3c90:	09 f0       	breq	.+2      	; 0x3c94 <main+0xe90>
    3c92:	fa cc       	rjmp	.-1548   	; 0x3688 <main+0x884>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:685
          fileNameSD = COSFN;
          BootStrAddr = COSSTRADDR;
          break;

        case 5:                                     // Fuzix OS
          fileNameSD = FUZIXFN;
    3c94:	88 e5       	ldi	r24, 0x58	; 88
    3c96:	91 e0       	ldi	r25, 0x01	; 1
    3c98:	90 93 ca 01 	sts	0x01CA, r25	; 0x8001ca <fileNameSD+0x1>
    3c9c:	80 93 c9 01 	sts	0x01C9, r24	; 0x8001c9 <fileNameSD>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:686
          BootStrAddr = FUZSTRADDR;
    3ca0:	10 92 c8 01 	sts	0x01C8, r1	; 0x8001c8 <BootStrAddr+0x1>
    3ca4:	10 92 c7 01 	sts	0x01C7, r1	; 0x8001c7 <BootStrAddr>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:687
          Z80IntRx = 1;                             // Enable Z80 Rx INT_ interrupt signal generation (Z80 M1 INT I/O)
    3ca8:	81 e0       	ldi	r24, 0x01	; 1
    3caa:	80 93 f0 01 	sts	0x01F0, r24	; 0x8001f0 <Z80IntRx>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:688
          Z80IntSysTick = 1;                        // Enable Z80 Systick INT_ interrupt signal generation (Z80 M1 INT I/O)
    3cae:	80 93 ef 01 	sts	0x01EF, r24	; 0x8001ef <Z80IntSysTick>
    3cb2:	ea cc       	rjmp	.-1580   	; 0x3688 <main+0x884>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:660

    case 2:                                       // Load an OS from current Disk Set on SD
      switch (diskSet)
      {
        case 0:                                     // CP/M 2.2
          fileNameSD = CPMFN;
    3cb4:	84 e2       	ldi	r24, 0x24	; 36
    3cb6:	91 e0       	ldi	r25, 0x01	; 1
    3cb8:	90 93 ca 01 	sts	0x01CA, r25	; 0x8001ca <fileNameSD+0x1>
    3cbc:	80 93 c9 01 	sts	0x01C9, r24	; 0x8001c9 <fileNameSD>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:661
          BootStrAddr = CPMSTRADDR;
    3cc0:	80 ee       	ldi	r24, 0xE0	; 224
    3cc2:	91 ed       	ldi	r25, 0xD1	; 209
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:701
      break;

    case 4:                                       // Load iLoad from flash
      BootImage = (byte *) pgm_read_word (&flahBootTable[0]);
      BootImageSize = sizeof(boot_A_);
      BootStrAddr = boot_A_StrAddr;
    3cc4:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <BootStrAddr+0x1>
    3cc8:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <BootStrAddr>
    3ccc:	dd cc       	rjmp	.-1606   	; 0x3688 <main+0x884>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:670
          fileNameSD = QPMFN;
          BootStrAddr = QPMSTRADDR;
          break;

        case 2:                                     // CP/M 3.0
          fileNameSD = CPM3FN;
    3cce:	89 e3       	ldi	r24, 0x39	; 57
    3cd0:	91 e0       	ldi	r25, 0x01	; 1
    3cd2:	90 93 ca 01 	sts	0x01CA, r25	; 0x8001ca <fileNameSD+0x1>
    3cd6:	80 93 c9 01 	sts	0x01C9, r24	; 0x8001c9 <fileNameSD>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:671
          BootStrAddr = CPM3STRADDR;
    3cda:	80 e0       	ldi	r24, 0x00	; 0
    3cdc:	91 e0       	ldi	r25, 0x01	; 1
    3cde:	f2 cf       	rjmp	.-28     	; 0x3cc4 <main+0xec0>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:675
          break;

        case 3:                                     // UCSD Pascal
          fileNameSD = UCSDFN;
    3ce0:	84 e4       	ldi	r24, 0x44	; 68
    3ce2:	91 e0       	ldi	r25, 0x01	; 1
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:694
          break;
      }
      break;

    case 3:                                       // Load AUTOBOOT.BIN from SD (load an user executable binary file)
      fileNameSD = AUTOFN;
    3ce4:	90 93 ca 01 	sts	0x01CA, r25	; 0x8001ca <fileNameSD+0x1>
    3ce8:	80 93 c9 01 	sts	0x01C9, r24	; 0x8001c9 <fileNameSD>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:695
      BootStrAddr = AUTSTRADDR;
    3cec:	10 92 c8 01 	sts	0x01C8, r1	; 0x8001c8 <BootStrAddr+0x1>
    3cf0:	10 92 c7 01 	sts	0x01C7, r1	; 0x8001c7 <BootStrAddr>
    3cf4:	c9 cc       	rjmp	.-1646   	; 0x3688 <main+0x884>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:680
          fileNameSD = UCSDFN;
          BootStrAddr = UCSDSTRADDR;
          break;

        case 4:                                     // Collapse OS
          fileNameSD = COSFN;
    3cf6:	80 e5       	ldi	r24, 0x50	; 80
    3cf8:	91 e0       	ldi	r25, 0x01	; 1
    3cfa:	f4 cf       	rjmp	.-24     	; 0x3ce4 <main+0xee0>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:694
          break;
      }
      break;

    case 3:                                       // Load AUTOBOOT.BIN from SD (load an user executable binary file)
      fileNameSD = AUTOFN;
    3cfc:	82 e6       	ldi	r24, 0x62	; 98
    3cfe:	91 e0       	ldi	r25, 0x01	; 1
    3d00:	f1 cf       	rjmp	.-30     	; 0x3ce4 <main+0xee0>
openSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2658
byte openSD(const char* fileName)
// Open an existing file on SD:
// *  "fileName" is the pointer to the string holding the file name (8.3 format)
// The returned value is the resulting status (0 = ok, otherwise see printErrSD())
{
  return pf_open(fileName);
    3d02:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <fileNameSD>
    3d06:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <fileNameSD+0x1>
    3d0a:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <pf_open>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:763
        }
        while (errCodeSD);
    }

    // Open the selected file to load
    errCodeSD = openSD(fileNameSD);
    3d0e:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <errCodeSD>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:764
    if (errCodeSD)
    3d12:	88 23       	and	r24, r24
    3d14:	21 f1       	breq	.+72     	; 0x3d5e <main+0xf5a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:768
      // Error opening the required file. Repeat until error disappears (or the user forces a reset)
      do
      {
        printErrSD(1, errCodeSD, fileNameSD);
    3d16:	60 91 c2 01 	lds	r22, 0x01C2	; 0x8001c2 <errCodeSD>
printErrSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2782
// NOT_OPENED
//     The file has not been opened.
//
// ........................................................................
{
  if (errCode)
    3d1a:	66 23       	and	r22, r22
    3d1c:	39 f0       	breq	.+14     	; 0x3d2c <main+0xf28>
    3d1e:	40 91 c9 01 	lds	r20, 0x01C9	; 0x8001c9 <fileNameSD>
    3d22:	50 91 ca 01 	lds	r21, 0x01CA	; 0x8001ca <fileNameSD+0x1>
    3d26:	81 e0       	ldi	r24, 0x01	; 1
    3d28:	0e 94 19 12 	call	0x2432	; 0x2432 <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:769
    if (errCodeSD)
      // Error opening the required file. Repeat until error disappears (or the user forces a reset)
      do
      {
        printErrSD(1, errCodeSD, fileNameSD);
        waitKey();                                  // Wait a key to repeat
    3d2c:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <waitKey()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:770
        errCodeSD = openSD(fileNameSD);
    3d30:	00 91 c9 01 	lds	r16, 0x01C9	; 0x8001c9 <fileNameSD>
    3d34:	10 91 ca 01 	lds	r17, 0x01CA	; 0x8001ca <fileNameSD+0x1>
openSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2658
byte openSD(const char* fileName)
// Open an existing file on SD:
// *  "fileName" is the pointer to the string holding the file name (8.3 format)
// The returned value is the resulting status (0 = ok, otherwise see printErrSD())
{
  return pf_open(fileName);
    3d38:	c8 01       	movw	r24, r16
    3d3a:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <pf_open>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:770
      // Error opening the required file. Repeat until error disappears (or the user forces a reset)
      do
      {
        printErrSD(1, errCodeSD, fileNameSD);
        waitKey();                                  // Wait a key to repeat
        errCodeSD = openSD(fileNameSD);
    3d3e:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <errCodeSD>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:771
        if (errCodeSD != 3)
    3d42:	83 30       	cpi	r24, 0x03	; 3
    3d44:	49 f0       	breq	.+18     	; 0x3d58 <main+0xf54>
mountSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2648
byte mountSD(FATFS* fatFs)
// Mount a volume on SD:
// *  "fatFs" is a pointer to a FATFS object (PetitFS library)
// The returned value is the resulting status (0 = ok, otherwise see printErrSD())
{
  return pf_mount(fatFs);
    3d46:	0e 94 4e 0a 	call	0x149c	; 0x149c <pf_mount.constprop.41>
    3d4a:	0e 94 4e 0a 	call	0x149c	; 0x149c <pf_mount.constprop.41>
openSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2658
byte openSD(const char* fileName)
// Open an existing file on SD:
// *  "fileName" is the pointer to the string holding the file name (8.3 format)
// The returned value is the resulting status (0 = ok, otherwise see printErrSD())
{
  return pf_open(fileName);
    3d4e:	c8 01       	movw	r24, r16
    3d50:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <pf_open>
    3d54:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <errCodeSD>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:779
          mountSD(&filesysSD);
          mountSD(&filesysSD);
          errCodeSD = openSD(fileNameSD);
        }
      }
      while (errCodeSD);
    3d58:	80 91 c2 01 	lds	r24, 0x01C2	; 0x8001c2 <errCodeSD>
    3d5c:	da cf       	rjmp	.-76     	; 0x3d12 <main+0xf0e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:782

    // Read the selected file from SD and load it into RAM until an EOF is reached
    Serial.print(F("IOS: Loading boot program ("));
    3d5e:	86 ee       	ldi	r24, 0xE6	; 230
    3d60:	95 e0       	ldi	r25, 0x05	; 5
    3d62:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:783
    Serial.print(fileNameSD);
    3d66:	60 91 c9 01 	lds	r22, 0x01C9	; 0x8001c9 <fileNameSD>
    3d6a:	70 91 ca 01 	lds	r23, 0x01CA	; 0x8001ca <fileNameSD+0x1>
    3d6e:	86 ea       	ldi	r24, 0xA6	; 166
    3d70:	92 e0       	ldi	r25, 0x02	; 2
    3d72:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:784
    Serial.print(F(")..."));
    3d76:	81 ee       	ldi	r24, 0xE1	; 225
    3d78:	95 e0       	ldi	r25, 0x05	; 5
    3d7a:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
readSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2678
// NOTE2: Past current sector boundary, the next sector will be pointed. So to read a whole file it is sufficient
//        call readSD() consecutively until EOF is reached
{
  UINT  numBytes;
  byte  errcode;
  errcode = pf_read(buffSD, 32, &numBytes);
    3d7e:	ce 01       	movw	r24, r28
    3d80:	01 96       	adiw	r24, 0x01	; 1
    3d82:	0e 94 9c 0c 	call	0x1938	; 0x1938 <pf_read.constprop.36>
    3d86:	08 2f       	mov	r16, r24
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2679
  *numReadBytes = (byte) numBytes;
    3d88:	89 81       	ldd	r24, Y+1	; 0x01
    3d8a:	80 93 d5 01 	sts	0x01D5, r24	; 0x8001d5 <numReadBytes>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:791
      // If an error occurs repeat until error disappears (or the user forces a reset)
    {
      do
        // Read a "segment" of a SD sector and load it into RAM
      {
        errCodeSD = readSD(bufferSD, &numReadBytes);  // Read current "segment" (32 bytes) of the current SD serctor
    3d8e:	00 93 c2 01 	sts	0x01C2, r16	; 0x8001c2 <errCodeSD>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:792
        for (iCount = 0; iCount < numReadBytes; iCount++)
    3d92:	10 92 cb 01 	sts	0x01CB, r1	; 0x8001cb <iCount>
    3d96:	10 91 cb 01 	lds	r17, 0x01CB	; 0x8001cb <iCount>
    3d9a:	80 91 d5 01 	lds	r24, 0x01D5	; 0x8001d5 <numReadBytes>
    3d9e:	18 17       	cp	r17, r24
    3da0:	58 f4       	brcc	.+22     	; 0x3db8 <main+0xfb4>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:795
          // Load the read "segment" into RAM
        {
          loadByteToRAM(bufferSD[iCount]);        // Write current data byte into RAM
    3da2:	e1 2f       	mov	r30, r17
    3da4:	f0 e0       	ldi	r31, 0x00	; 0
    3da6:	e7 5a       	subi	r30, 0xA7	; 167
    3da8:	fd 4f       	sbci	r31, 0xFD	; 253
    3daa:	80 81       	ld	r24, Z
    3dac:	0e 94 53 10 	call	0x20a6	; 0x20a6 <loadByteToRAM(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:792
    {
      do
        // Read a "segment" of a SD sector and load it into RAM
      {
        errCodeSD = readSD(bufferSD, &numReadBytes);  // Read current "segment" (32 bytes) of the current SD serctor
        for (iCount = 0; iCount < numReadBytes; iCount++)
    3db0:	1f 5f       	subi	r17, 0xFF	; 255
    3db2:	10 93 cb 01 	sts	0x01CB, r17	; 0x8001cb <iCount>
    3db6:	ef cf       	rjmp	.-34     	; 0x3d96 <main+0xf92>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:798
          // Load the read "segment" into RAM
        {
          loadByteToRAM(bufferSD[iCount]);        // Write current data byte into RAM
        }
      }
      while ((numReadBytes == 32) && (!errCodeSD)); // If numReadBytes < 32 -> EOF reached
    3db8:	80 32       	cpi	r24, 0x20	; 32
    3dba:	91 f4       	brne	.+36     	; 0x3de0 <main+0xfdc>
    3dbc:	00 23       	and	r16, r16
    3dbe:	f9 f2       	breq	.-66     	; 0x3d7e <main+0xf7a>
printErrSD():
    3dc0:	40 91 c9 01 	lds	r20, 0x01C9	; 0x8001c9 <fileNameSD>
    3dc4:	50 91 ca 01 	lds	r21, 0x01CA	; 0x8001ca <fileNameSD+0x1>
    3dc8:	60 2f       	mov	r22, r16
    3dca:	82 e0       	ldi	r24, 0x02	; 2
    3dcc:	0e 94 19 12 	call	0x2432	; 0x2432 <printErrSD(unsigned char, unsigned char, char const*) [clone .part.3]>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:802
      if (errCodeSD)
      {
        printErrSD(2, errCodeSD, fileNameSD);
        waitKey();                                // Wait a key to repeat
    3dd0:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <waitKey()>
seekSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2726
// NOTE: "secNum" is in the range [0..16383], and the sector addressing is continuos inside a "disk file";
//       16383 = (512 * 32) - 1, where 512 is the number of emulated tracks, 32 is the number of emulated sectors
//
{
  byte i;
  return pf_lseek(((unsigned long) sectNum) << 9);
    3dd4:	60 e0       	ldi	r22, 0x00	; 0
    3dd6:	70 e0       	ldi	r23, 0x00	; 0
    3dd8:	cb 01       	movw	r24, r22
    3dda:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <pf_lseek>
    3dde:	02 c0       	rjmp	.+4      	; 0x3de4 <main+0xfe0>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:799
        {
          loadByteToRAM(bufferSD[iCount]);        // Write current data byte into RAM
        }
      }
      while ((numReadBytes == 32) && (!errCodeSD)); // If numReadBytes < 32 -> EOF reached
      if (errCodeSD)
    3de0:	01 11       	cpse	r16, r1
    3de2:	ee cf       	rjmp	.-36     	; 0x3dc0 <main+0xfbc>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:806
        printErrSD(2, errCodeSD, fileNameSD);
        waitKey();                                // Wait a key to repeat
        seekSD(0);                                // Reset the sector pointer
      }
    }
    while (errCodeSD);
    3de4:	80 91 c2 01 	lds	r24, 0x01C2	; 0x8001c2 <errCodeSD>
    3de8:	81 11       	cpse	r24, r1
    3dea:	c9 cf       	rjmp	.-110    	; 0x3d7e <main+0xf7a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:818
      // Write boot program into external RAM
    {
      loadByteToRAM(pgm_read_byte(BootImage + i));// Write current data byte into RAM
    }
  }
  Serial.println(F(" Done"));
    3dec:	8e eb       	ldi	r24, 0xBE	; 190
    3dee:	95 e0       	ldi	r25, 0x05	; 5
    3df0:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:824

  // ----------------------------------------
  // Z80 BOOT
  // ----------------------------------------

  digitalWrite(RESET_, LOW);                      // Activate the RESET_ signal
    3df4:	60 e0       	ldi	r22, 0x00	; 0
    3df6:	86 e1       	ldi	r24, 0x16	; 22
    3df8:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:829

#if defined(__AVR_ATmega32__)
  // Atmega32 MCU
  // Initialize CLK @ 4/8MHz (@ Fosc = 16MHz). Z80 clock_freq = (Atmega_clock) / ((OCR2 + 1) * 2)
  ASSR &= ~(1 << AS2);                          // Set Timer2 clock from system clock
    3dfc:	82 b5       	in	r24, 0x22	; 34
    3dfe:	87 7f       	andi	r24, 0xF7	; 247
    3e00:	82 bd       	out	0x22, r24	; 34
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:830
  TCCR2 |= (1 << CS20);                         // Set Timer2 clock to "no prescaling"
    3e02:	85 b5       	in	r24, 0x25	; 37
    3e04:	81 60       	ori	r24, 0x01	; 1
    3e06:	85 bd       	out	0x25, r24	; 37
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:831
  TCCR2 &= ~((1 << CS21) | (1 << CS22));
    3e08:	85 b5       	in	r24, 0x25	; 37
    3e0a:	89 7f       	andi	r24, 0xF9	; 249
    3e0c:	85 bd       	out	0x25, r24	; 37
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:832
  TCCR2 |= (1 << WGM21);                        // Set Timer2 CTC mode
    3e0e:	85 b5       	in	r24, 0x25	; 37
    3e10:	88 60       	ori	r24, 0x08	; 8
    3e12:	85 bd       	out	0x25, r24	; 37
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:833
  TCCR2 &= ~(1 << WGM20);
    3e14:	85 b5       	in	r24, 0x25	; 37
    3e16:	8f 7b       	andi	r24, 0xBF	; 191
    3e18:	85 bd       	out	0x25, r24	; 37
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:834
  TCCR2 |= (1 <<  COM20);                       // Set "toggle OC2 on compare match"
    3e1a:	85 b5       	in	r24, 0x25	; 37
    3e1c:	80 61       	ori	r24, 0x10	; 16
    3e1e:	85 bd       	out	0x25, r24	; 37
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:835
  TCCR2 &= ~(1 << COM21);
    3e20:	85 b5       	in	r24, 0x25	; 37
    3e22:	8f 7d       	andi	r24, 0xDF	; 223
    3e24:	85 bd       	out	0x25, r24	; 37
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:836
  OCR2 = clockMode;                             // Set the compare value to toggle OC2 (0 = low or 1 = high)
    3e26:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <clockMode>
    3e2a:	83 bd       	out	0x23, r24	; 35
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:853
#else
  Serial.print(F("IOS: Current MCU is not supported. Aborted!"));
  while (1);
#endif

  pinMode(CLK, OUTPUT);                           // Set OC2 as output and start to output the clock
    3e2c:	61 e0       	ldi	r22, 0x01	; 1
    3e2e:	8f e0       	ldi	r24, 0x0F	; 15
    3e30:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:854
  Serial.println(F("IOS: Z80 is running from now"));
    3e34:	81 ea       	ldi	r24, 0xA1	; 161
    3e36:	95 e0       	ldi	r25, 0x05	; 5
    3e38:	0e 94 de 11 	call	0x23bc	; 0x23bc <Print::println(__FlashStringHelper const*) [clone .constprop.43]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:855
  Serial.println();
    3e3c:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <Print::println() [clone .constprop.49]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:858

  // Flush serial Rx buffer
  while (Serial.available() > 0)
    3e40:	86 ea       	ldi	r24, 0xA6	; 166
    3e42:	92 e0       	ldi	r25, 0x02	; 2
    3e44:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
    3e48:	18 16       	cp	r1, r24
    3e4a:	19 06       	cpc	r1, r25
    3e4c:	fc f4       	brge	.+62     	; 0x3e8c <main+0x1088>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:860
  {
    Serial.read();
    3e4e:	86 ea       	ldi	r24, 0xA6	; 166
    3e50:	92 e0       	ldi	r25, 0x02	; 2
    3e52:	0e 94 1d 05 	call	0xa3a	; 0xa3a <HardwareSerial::read()>
    3e56:	f4 cf       	rjmp	.-24     	; 0x3e40 <main+0x103c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:811
    while (errCodeSD);
  }
  else
    // Load from flash
  {
    Serial.print(F("IOS: Loading boot program..."));
    3e58:	84 ec       	ldi	r24, 0xC4	; 196
    3e5a:	95 e0       	ldi	r25, 0x05	; 5
    3e5c:	0e 94 c2 05 	call	0xb84	; 0xb84 <Print::print(__FlashStringHelper const*) [clone .constprop.54]>
main():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:812
    for (word i = 0; i < BootImageSize; i++)
    3e60:	10 e0       	ldi	r17, 0x00	; 0
    3e62:	00 e0       	ldi	r16, 0x00	; 0
setup():
    3e64:	80 91 c3 01 	lds	r24, 0x01C3	; 0x8001c3 <BootImageSize>
    3e68:	90 91 c4 01 	lds	r25, 0x01C4	; 0x8001c4 <BootImageSize+0x1>
    3e6c:	08 17       	cp	r16, r24
    3e6e:	19 07       	cpc	r17, r25
    3e70:	08 f0       	brcs	.+2      	; 0x3e74 <main+0x1070>
    3e72:	bc cf       	rjmp	.-136    	; 0x3dec <main+0xfe8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:815
      // Write boot program into external RAM
    {
      loadByteToRAM(pgm_read_byte(BootImage + i));// Write current data byte into RAM
    3e74:	e0 91 c5 01 	lds	r30, 0x01C5	; 0x8001c5 <BootImage>
    3e78:	f0 91 c6 01 	lds	r31, 0x01C6	; 0x8001c6 <BootImage+0x1>
    3e7c:	e0 0f       	add	r30, r16
    3e7e:	f1 1f       	adc	r31, r17
    3e80:	84 91       	lpm	r24, Z
    3e82:	0e 94 53 10 	call	0x20a6	; 0x20a6 <loadByteToRAM(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:812
  }
  else
    // Load from flash
  {
    Serial.print(F("IOS: Loading boot program..."));
    for (word i = 0; i < BootImageSize; i++)
    3e86:	0f 5f       	subi	r16, 0xFF	; 255
    3e88:	1f 4f       	sbci	r17, 0xFF	; 255
    3e8a:	ec cf       	rjmp	.-40     	; 0x3e64 <main+0x1060>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:864
  {
    Serial.read();
  }

  // Leave the Z80 CPU running
  delay(1);                                       // Just to be sure...
    3e8c:	61 e0       	ldi	r22, 0x01	; 1
    3e8e:	70 e0       	ldi	r23, 0x00	; 0
    3e90:	80 e0       	ldi	r24, 0x00	; 0
    3e92:	90 e0       	ldi	r25, 0x00	; 0
    3e94:	0e 94 07 07 	call	0xe0e	; 0xe0e <delay>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:865
  digitalWrite(RESET_, HIGH);                     // Release Z80 from reset and let it run
    3e98:	61 e0       	ldi	r22, 0x01	; 1
    3e9a:	86 e1       	ldi	r24, 0x16	; 22
    3e9c:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1209
              diskErr = 0;                        // No errors
            }
            else
              // Sector or track invalid number
            {
              if (sectSel < 32) diskErr = 17;     // Illegal track number
    3ea0:	51 e1       	ldi	r21, 0x11	; 17
    3ea2:	c5 2e       	mov	r12, r21
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2026
            break;
        }
        if ((ioOpcode != 0x84) && (ioOpcode != 0x86)) ioOpcode = 0xFF;  // All done for the single byte Opcodes.
        //  Set ioOpcode = "No operation"
      }
      DDRA = 0xFF;                              // Configure Z80 data bus D0-D7 (PA0-PA7) as output
    3ea4:	dd 24       	eor	r13, r13
    3ea6:	da 94       	dec	r13
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:872

// ------------------------------------------------------------------------------

void loop()
{
  if (!digitalRead(WAIT_))
    3ea8:	83 e0       	ldi	r24, 0x03	; 3
    3eaa:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
    3eae:	89 2b       	or	r24, r25
    3eb0:	09 f0       	breq	.+2      	; 0x3eb4 <main+0x10b0>
    3eb2:	d0 c3       	rjmp	.+1952   	; 0x4654 <main+0x1850>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:875
    // I/O operaton requested
  {
    if (!digitalRead(WR_))
    3eb4:	83 e1       	ldi	r24, 0x13	; 19
    3eb6:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
    3eba:	89 2b       	or	r24, r25
    3ebc:	09 f0       	breq	.+2      	; 0x3ec0 <main+0x10bc>
    3ebe:	82 c3       	rjmp	.+1796   	; 0x45c4 <main+0x17c0>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:883
      // ----------------------------------------
      // VIRTUAL I/O WRITE OPERATIONS ENGINE
      // ----------------------------------------

    {
      ioAddress = digitalRead(AD0);               // Read Z80 address bus line AD0 (PC2)
    3ec0:	82 e1       	ldi	r24, 0x12	; 18
    3ec2:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:884
      ioData = PINA;                              // Read Z80 data bus D0-D7 (PA0-PA7)
    3ec6:	f9 b2       	in	r15, 0x19	; 25
    3ec8:	f0 92 fa 01 	sts	0x01FA, r15	; 0x8001fa <ioData>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:885
      if (ioAddress)                              // Check the I/O address (only AD0 is checked!)
    3ecc:	88 23       	and	r24, r24
    3ece:	79 f0       	breq	.+30     	; 0x3eee <main+0x10ea>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:952
        //
        // See the following lines for the Opcodes details.
        //
        // .........................................................................................................
      {
        ioOpcode = ioData;                        // Store the I/O operation code (Opcode)
    3ed0:	f0 92 79 00 	sts	0x0079, r15	; 0x800079 <ioOpcode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:953
        ioByteCnt = 0;                            // Reset the exchanged bytes counter
    3ed4:	10 92 f9 01 	sts	0x01F9, r1	; 0x8001f9 <ioByteCnt+0x1>
    3ed8:	10 92 f8 01 	sts	0x01F8, r1	; 0x8001f8 <ioByteCnt>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2061
      }
      // DEBUG END ------------------------------
      //

      // Control bus sequence to exit from a wait state (M interrupt cycle)
      digitalWrite(BUSREQ_, LOW);               // Request for a DMA
    3edc:	60 e0       	ldi	r22, 0x00	; 0
    3ede:	8e e0       	ldi	r24, 0x0E	; 14
    3ee0:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2062
      digitalWrite(WAIT_RES_, LOW);             // Reset WAIT FF exiting from WAIT state
    3ee4:	60 e0       	ldi	r22, 0x00	; 0
    3ee6:	80 e0       	ldi	r24, 0x00	; 0
    3ee8:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
    3eec:	ab c3       	rjmp	.+1878   	; 0x4644 <main+0x1840>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:965
        // Execute the previously stored I/O write Opcode with the current data.
        // The code of the I/O write operation (Opcode) must be previously stored with a STORE Opcode operation.
        // .........................................................................................................
        //
      {
        switch (ioOpcode)
    3eee:	e0 91 79 00 	lds	r30, 0x0079	; 0x800079 <ioOpcode>
    3ef2:	e4 32       	cpi	r30, 0x24	; 36
    3ef4:	08 f0       	brcs	.+2      	; 0x3ef8 <main+0x10f4>
    3ef6:	2f c0       	rjmp	.+94     	; 0x3f56 <main+0x1152>
    3ef8:	f0 e0       	ldi	r31, 0x00	; 0
    3efa:	ef 57       	subi	r30, 0x7F	; 127
    3efc:	f0 4e       	sbci	r31, 0xE0	; 224
    3efe:	0c 94 9c 25 	jmp	0x4b38	; 0x4b38 <__tablejump2__>
    3f02:	a5 1f       	adc	r26, r21
    3f04:	ba 1f       	adc	r27, r26
    3f06:	ab 1f       	adc	r26, r27
    3f08:	c0 1f       	adc	r28, r16
    3f0a:	d3 1f       	adc	r29, r19
    3f0c:	dd 1f       	adc	r29, r29
    3f0e:	e7 1f       	adc	r30, r23
    3f10:	f2 1f       	adc	r31, r18
    3f12:	fd 1f       	adc	r31, r29
    3f14:	08 20       	and	r0, r8
    3f16:	2b 20       	and	r2, r11
    3f18:	59 20       	and	r5, r9
    3f1a:	70 20       	and	r7, r0
    3f1c:	c0 21       	and	r28, r0
    3f1e:	d7 21       	and	r29, r7
    3f20:	e1 21       	and	r30, r1
    3f22:	e7 21       	and	r30, r7
    3f24:	ec 21       	and	r30, r12
    3f26:	4a 22       	and	r4, r26
    3f28:	ab 1f       	adc	r26, r27
    3f2a:	ab 1f       	adc	r26, r27
    3f2c:	ab 1f       	adc	r26, r27
    3f2e:	ab 1f       	adc	r26, r27
    3f30:	ab 1f       	adc	r26, r27
    3f32:	ab 1f       	adc	r26, r27
    3f34:	ab 1f       	adc	r26, r27
    3f36:	ab 1f       	adc	r26, r27
    3f38:	ab 1f       	adc	r26, r27
    3f3a:	ab 1f       	adc	r26, r27
    3f3c:	ab 1f       	adc	r26, r27
    3f3e:	ab 1f       	adc	r26, r27
    3f40:	ab 1f       	adc	r26, r27
    3f42:	7b 22       	and	r7, r27
    3f44:	88 22       	and	r8, r24
    3f46:	bf 22       	and	r11, r31
    3f48:	c5 22       	and	r12, r21
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:975
            //                I/O DATA:    D7 D6 D5 D4 D3 D2 D1 D0
            //                            ---------------------------------------------------------
            //                              x  x  x  x  x  x  x  0    USER Led off
            //                              x  x  x  x  x  x  x  1    USER Led on

            if (ioData & 0x01) digitalWrite(USER, LOW);
    3f4a:	60 e0       	ldi	r22, 0x00	; 0
    3f4c:	f0 fe       	sbrs	r15, 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:976
            else digitalWrite(USER, HIGH);
    3f4e:	61 e0       	ldi	r22, 0x01	; 1
    3f50:	8d e0       	ldi	r24, 0x0D	; 13
    3f52:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1609
            }
            break;
        }

        
        if ((ioOpcode != 0x0A) && (ioOpcode != 0x0C) && (ioOpcode != 0x21) && (ioOpcode != 0x23)) ioOpcode = 0xFF;  // All done for the single byte Opcodes.
    3f56:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <ioOpcode>
    3f5a:	8a 30       	cpi	r24, 0x0A	; 10
    3f5c:	09 f4       	brne	.+2      	; 0x3f60 <main+0x115c>
    3f5e:	be cf       	rjmp	.-132    	; 0x3edc <main+0x10d8>
    3f60:	8c 30       	cpi	r24, 0x0C	; 12
    3f62:	09 f4       	brne	.+2      	; 0x3f66 <main+0x1162>
    3f64:	bb cf       	rjmp	.-138    	; 0x3edc <main+0x10d8>
    3f66:	8d 7f       	andi	r24, 0xFD	; 253
    3f68:	81 32       	cpi	r24, 0x21	; 33
    3f6a:	09 f4       	brne	.+2      	; 0x3f6e <main+0x116a>
    3f6c:	b7 cf       	rjmp	.-146    	; 0x3edc <main+0x10d8>
    3f6e:	d0 92 79 00 	sts	0x0079, r13	; 0x800079 <ioOpcode>
    3f72:	b4 cf       	rjmp	.-152    	; 0x3edc <main+0x10d8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:985
            // SERIAL TX:
            //                I/O DATA:    D7 D6 D5 D4 D3 D2 D1 D0
            //                            ---------------------------------------------------------
            //                             D7 D6 D5 D4 D3 D2 D1 D0    ASCII char to be sent to serial

            Serial.write(ioData);
    3f74:	6f 2d       	mov	r22, r15
    3f76:	86 ea       	ldi	r24, 0xA6	; 166
    3f78:	92 e0       	ldi	r25, 0x02	; 2
    3f7a:	0e 94 76 05 	call	0xaec	; 0xaec <HardwareSerial::write(unsigned char)>
    3f7e:	eb cf       	rjmp	.-42     	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:995
            //
            //                I/O DATA:    D7 D6 D5 D4 D3 D2 D1 D0
            //                            ---------------------------------------------------------
            //                             D7 D6 D5 D4 D3 D2 D1 D0    GPIOA value (see MCP23017 datasheet)

            if (moduleGPIO)
    3f80:	80 91 f7 01 	lds	r24, 0x01F7	; 0x8001f7 <moduleGPIO>
    3f84:	88 23       	and	r24, r24
    3f86:	39 f3       	breq	.-50     	; 0x3f56 <main+0x1152>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    3f88:	80 e2       	ldi	r24, 0x20	; 32
    3f8a:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:998
            {
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOA_REG);              // Select GPIOA
    3f8e:	82 e1       	ldi	r24, 0x12	; 18
    3f90:	90 e0       	ldi	r25, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1014
            //                             D7 D6 D5 D4 D3 D2 D1 D0    GPIOB value (see MCP23017 datasheet)

            if (moduleGPIO)
            {
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOB_REG);              // Select GPIOB
    3f92:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1015
              Wire.write(ioData);                 // Write value
    3f96:	6f 2d       	mov	r22, r15
    3f98:	83 e4       	ldi	r24, 0x43	; 67
    3f9a:	93 e0       	ldi	r25, 0x03	; 3
    3f9c:	0e 94 b9 07 	call	0xf72	; 0xf72 <TwoWire::write(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1016
              Wire.endTransmission();
    3fa0:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
    3fa4:	d8 cf       	rjmp	.-80     	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1011
            //
            //                I/O DATA:    D7 D6 D5 D4 D3 D2 D1 D0
            //                            ---------------------------------------------------------
            //                             D7 D6 D5 D4 D3 D2 D1 D0    GPIOB value (see MCP23017 datasheet)

            if (moduleGPIO)
    3fa6:	80 91 f7 01 	lds	r24, 0x01F7	; 0x8001f7 <moduleGPIO>
    3faa:	88 23       	and	r24, r24
    3fac:	a1 f2       	breq	.-88     	; 0x3f56 <main+0x1152>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    3fae:	80 e2       	ldi	r24, 0x20	; 32
    3fb0:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1014
            {
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOB_REG);              // Select GPIOB
    3fb4:	83 e1       	ldi	r24, 0x13	; 19
    3fb6:	90 e0       	ldi	r25, 0x00	; 0
    3fb8:	ec cf       	rjmp	.-40     	; 0x3f92 <main+0x118e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1027
            //
            //                I/O DATA:    D7 D6 D5 D4 D3 D2 D1 D0
            //                            ---------------------------------------------------------
            //                             D7 D6 D5 D4 D3 D2 D1 D0    IODIRA value (see MCP23017 datasheet)

            if (moduleGPIO)
    3fba:	80 91 f7 01 	lds	r24, 0x01F7	; 0x8001f7 <moduleGPIO>
    3fbe:	88 23       	and	r24, r24
    3fc0:	51 f2       	breq	.-108    	; 0x3f56 <main+0x1152>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    3fc2:	80 e2       	ldi	r24, 0x20	; 32
    3fc4:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1030
            {
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(IODIRA_REG);             // Select IODIRA
    3fc8:	90 e0       	ldi	r25, 0x00	; 0
    3fca:	80 e0       	ldi	r24, 0x00	; 0
    3fcc:	e2 cf       	rjmp	.-60     	; 0x3f92 <main+0x118e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1043
            //
            //                I/O DATA:    D7 D6 D5 D4 D3 D2 D1 D0
            //                            ---------------------------------------------------------
            //                             D7 D6 D5 D4 D3 D2 D1 D0    IODIRB value (see MCP23017 datasheet)

            if (moduleGPIO)
    3fce:	80 91 f7 01 	lds	r24, 0x01F7	; 0x8001f7 <moduleGPIO>
    3fd2:	88 23       	and	r24, r24
    3fd4:	09 f4       	brne	.+2      	; 0x3fd8 <main+0x11d4>
    3fd6:	bf cf       	rjmp	.-130    	; 0x3f56 <main+0x1152>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    3fd8:	80 e2       	ldi	r24, 0x20	; 32
    3fda:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1046
            {
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(IODIRB_REG);             // Select IODIRB
    3fde:	81 e0       	ldi	r24, 0x01	; 1
    3fe0:	90 e0       	ldi	r25, 0x00	; 0
    3fe2:	d7 cf       	rjmp	.-82     	; 0x3f92 <main+0x118e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1059
            //
            //                I/O DATA:    D7 D6 D5 D4 D3 D2 D1 D0
            //                            ---------------------------------------------------------
            //                             D7 D6 D5 D4 D3 D2 D1 D0    GPPUA value (see MCP23017 datasheet)

            if (moduleGPIO)
    3fe4:	80 91 f7 01 	lds	r24, 0x01F7	; 0x8001f7 <moduleGPIO>
    3fe8:	88 23       	and	r24, r24
    3fea:	09 f4       	brne	.+2      	; 0x3fee <main+0x11ea>
    3fec:	b4 cf       	rjmp	.-152    	; 0x3f56 <main+0x1152>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    3fee:	80 e2       	ldi	r24, 0x20	; 32
    3ff0:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1062
            {
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPPUA_REG);              // Select GPPUA
    3ff4:	8c e0       	ldi	r24, 0x0C	; 12
    3ff6:	90 e0       	ldi	r25, 0x00	; 0
    3ff8:	cc cf       	rjmp	.-104    	; 0x3f92 <main+0x118e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1075
            //
            //                I/O DATA:    D7 D6 D5 D4 D3 D2 D1 D0
            //                            ---------------------------------------------------------
            //                             D7 D6 D5 D4 D3 D2 D1 D0    GPPUB value (see MCP23017 datasheet)

            if (moduleGPIO)
    3ffa:	80 91 f7 01 	lds	r24, 0x01F7	; 0x8001f7 <moduleGPIO>
    3ffe:	88 23       	and	r24, r24
    4000:	09 f4       	brne	.+2      	; 0x4004 <main+0x1200>
    4002:	a9 cf       	rjmp	.-174    	; 0x3f56 <main+0x1152>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    4004:	80 e2       	ldi	r24, 0x20	; 32
    4006:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1078
            {
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPPUB_REG);              // Select GPPUB
    400a:	8d e0       	ldi	r24, 0x0D	; 13
    400c:	90 e0       	ldi	r25, 0x00	; 0
    400e:	c1 cf       	rjmp	.-126    	; 0x3f92 <main+0x118e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1118
            // NOTE 1: The maximum disks number may be lower due the limitations of the used OS (e.g. CP/M 2.2 supports
            //         a maximum of 16 disks)
            // NOTE 2: Because SELDISK opens the "disk file" used for disk emulation, before using WRITESECT or READSECT
            //         a SELDISK must be performed at first.

            if (ioData <= maxDiskNum)             // Valid disk number
    4010:	83 e6       	ldi	r24, 0x63	; 99
    4012:	8f 15       	cp	r24, r15
    4014:	e0 f0       	brcs	.+56     	; 0x404e <main+0x124a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1121
              // Set the name of the file to open as virtual disk, and open it
            {
              diskName[2] = diskSet + 48;         // Set the current Disk Set
    4016:	80 91 f6 01 	lds	r24, 0x01F6	; 0x8001f6 <diskSet>
    401a:	80 5d       	subi	r24, 0xD0	; 208
    401c:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <diskName+0x2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1122
              diskName[4] = (ioData / 10) + 48;   // Set the disk number
    4020:	8f 2d       	mov	r24, r15
    4022:	6a e0       	ldi	r22, 0x0A	; 10
    4024:	0e 94 6e 25 	call	0x4adc	; 0x4adc <__udivmodqi4>
    4028:	90 e3       	ldi	r25, 0x30	; 48
    402a:	98 0f       	add	r25, r24
    402c:	90 93 72 00 	sts	0x0072, r25	; 0x800072 <diskName+0x4>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1123
              diskName[5] = ioData - ((ioData / 10) * 10) + 48;
    4030:	90 e3       	ldi	r25, 0x30	; 48
    4032:	f9 0e       	add	r15, r25
    4034:	e6 ef       	ldi	r30, 0xF6	; 246
    4036:	8e 9f       	mul	r24, r30
    4038:	f0 0c       	add	r15, r0
    403a:	11 24       	eor	r1, r1
    403c:	f0 92 73 00 	sts	0x0073, r15	; 0x800073 <diskName+0x5>
openSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2658
byte openSD(const char* fileName)
// Open an existing file on SD:
// *  "fileName" is the pointer to the string holding the file name (8.3 format)
// The returned value is the resulting status (0 = ok, otherwise see printErrSD())
{
  return pf_open(fileName);
    4040:	8e e6       	ldi	r24, 0x6E	; 110
    4042:	90 e0       	ldi	r25, 0x00	; 0
    4044:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <pf_open>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1210
            }
            else
              // Sector or track invalid number
            {
              if (sectSel < 32) diskErr = 17;     // Illegal track number
              else diskErr = 18;                  // Illegal sector number
    4048:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <diskErr>
    404c:	84 cf       	rjmp	.-248    	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1126
              diskName[2] = diskSet + 48;         // Set the current Disk Set
              diskName[4] = (ioData / 10) + 48;   // Set the disk number
              diskName[5] = ioData - ((ioData / 10) * 10) + 48;
              diskErr = openSD(diskName);         // Open the "disk file" corresponding to the given disk number
            }
            else diskErr = 16;                    // Illegal disk number
    404e:	f0 e1       	ldi	r31, 0x10	; 16
    4050:	f0 93 6d 00 	sts	0x006D, r31	; 0x80006d <diskErr>
    4054:	80 cf       	rjmp	.-256    	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1154
            //
            // NOTE 1: Allowed track numbers are in the range [0..511] (512 tracks)
            // NOTE 2: Before a WRITESECT or READSECT operation at least a SELSECT or a SELTRAK operation
            //         must be performed

            if (!ioByteCnt)
    4056:	80 91 f8 01 	lds	r24, 0x01F8	; 0x8001f8 <ioByteCnt>
    405a:	90 91 f9 01 	lds	r25, 0x01F9	; 0x8001f9 <ioByteCnt+0x1>
    405e:	4f 2d       	mov	r20, r15
    4060:	50 e0       	ldi	r21, 0x00	; 0
    4062:	00 97       	sbiw	r24, 0x00	; 0
    4064:	51 f4       	brne	.+20     	; 0x407a <main+0x1276>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1157
              // LSB
            {
              trackSel = ioData;
    4066:	50 93 f5 01 	sts	0x01F5, r21	; 0x8001f5 <trackSel+0x1>
    406a:	40 93 f4 01 	sts	0x01F4, r20	; 0x8001f4 <trackSel>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1176
                if (sectSel < 32) diskErr = 17;   // Illegal track number
                else diskErr = 18;                // Illegal sector number
              }
              ioOpcode = 0xFF;                    // All done. Set ioOpcode = "No operation"
            }
            ioByteCnt++;
    406e:	01 96       	adiw	r24, 0x01	; 1
    4070:	90 93 f9 01 	sts	0x01F9, r25	; 0x8001f9 <ioByteCnt+0x1>
    4074:	80 93 f8 01 	sts	0x01F8, r24	; 0x8001f8 <ioByteCnt>
    4078:	6e cf       	rjmp	.-292    	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1162
              trackSel = ioData;
            }
            else
              // MSB
            {
              trackSel = (((word) ioData) << 8) | lowByte(trackSel);
    407a:	20 91 f4 01 	lds	r18, 0x01F4	; 0x8001f4 <trackSel>
    407e:	3f 2d       	mov	r19, r15
    4080:	30 93 f5 01 	sts	0x01F5, r19	; 0x8001f5 <trackSel+0x1>
    4084:	20 93 f4 01 	sts	0x01F4, r18	; 0x8001f4 <trackSel>
    4088:	40 91 f3 01 	lds	r20, 0x01F3	; 0x8001f3 <sectSel>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1163
              if ((trackSel < 512) && (sectSel < 32))
    408c:	21 15       	cp	r18, r1
    408e:	32 40       	sbci	r19, 0x02	; 2
    4090:	38 f4       	brcc	.+14     	; 0x40a0 <main+0x129c>
    4092:	40 32       	cpi	r20, 0x20	; 32
    4094:	50 f4       	brcc	.+20     	; 0x40aa <main+0x12a6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1166
                // Sector and track numbers valid
              {
                diskErr = 0;                      // No errors
    4096:	10 92 6d 00 	sts	0x006D, r1	; 0x80006d <diskErr>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1174
                // Sector or track invalid number
              {
                if (sectSel < 32) diskErr = 17;   // Illegal track number
                else diskErr = 18;                // Illegal sector number
              }
              ioOpcode = 0xFF;                    // All done. Set ioOpcode = "No operation"
    409a:	d0 92 79 00 	sts	0x0079, r13	; 0x800079 <ioOpcode>
    409e:	e7 cf       	rjmp	.-50     	; 0x406e <main+0x126a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1171
                diskErr = 0;                      // No errors
              }
              else
                // Sector or track invalid number
              {
                if (sectSel < 32) diskErr = 17;   // Illegal track number
    40a0:	40 32       	cpi	r20, 0x20	; 32
    40a2:	18 f4       	brcc	.+6      	; 0x40aa <main+0x12a6>
    40a4:	c0 92 6d 00 	sts	0x006D, r12	; 0x80006d <diskErr>
    40a8:	f8 cf       	rjmp	.-16     	; 0x409a <main+0x1296>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1172
                else diskErr = 18;                // Illegal sector number
    40aa:	22 e1       	ldi	r18, 0x12	; 18
    40ac:	20 93 6d 00 	sts	0x006D, r18	; 0x80006d <diskErr>
    40b0:	f4 cf       	rjmp	.-24     	; 0x409a <main+0x1296>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1200
            //
            // NOTE 1: Allowed sector numbers are in the range [0..31] (32 sectors)
            // NOTE 2: Before a WRITESECT or READSECT operation at least a SELSECT or a SELTRAK operation
            //         must be performed

            sectSel = ioData;
    40b2:	f0 92 f3 01 	sts	0x01F3, r15	; 0x8001f3 <sectSel>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1201
            if ((trackSel < 512) && (sectSel < 32))
    40b6:	80 91 f4 01 	lds	r24, 0x01F4	; 0x8001f4 <trackSel>
    40ba:	90 91 f5 01 	lds	r25, 0x01F5	; 0x8001f5 <trackSel+0x1>
    40be:	81 15       	cp	r24, r1
    40c0:	92 40       	sbci	r25, 0x02	; 2
    40c2:	30 f4       	brcc	.+12     	; 0x40d0 <main+0x12cc>
    40c4:	ff e1       	ldi	r31, 0x1F	; 31
    40c6:	ff 15       	cp	r31, r15
    40c8:	48 f0       	brcs	.+18     	; 0x40dc <main+0x12d8>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1204
              // Sector and track numbers valid
            {
              diskErr = 0;                        // No errors
    40ca:	10 92 6d 00 	sts	0x006D, r1	; 0x80006d <diskErr>
    40ce:	43 cf       	rjmp	.-378    	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1209
            }
            else
              // Sector or track invalid number
            {
              if (sectSel < 32) diskErr = 17;     // Illegal track number
    40d0:	2f e1       	ldi	r18, 0x1F	; 31
    40d2:	2f 15       	cp	r18, r15
    40d4:	18 f0       	brcs	.+6      	; 0x40dc <main+0x12d8>
    40d6:	c0 92 6d 00 	sts	0x006D, r12	; 0x80006d <diskErr>
    40da:	3d cf       	rjmp	.-390    	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1210
              else diskErr = 18;                  // Illegal sector number
    40dc:	82 e1       	ldi	r24, 0x12	; 18
    40de:	b4 cf       	rjmp	.-152    	; 0x4048 <main+0x1244>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1246
            // NOTE 1: Before a WRITESECT operation at least a SELTRACK or a SELSECT must be always performed
            // NOTE 2: Remember to open the right "disk file" at first using the SELDISK Opcode
            // NOTE 3: The write finalization on SD "disk file" is executed only on the 512th data byte exchange, so be
            //         sure that exactly 512 data bytes are exchanged.

            if (!ioByteCnt)
    40e0:	a0 90 f8 01 	lds	r10, 0x01F8	; 0x8001f8 <ioByteCnt>
    40e4:	b0 90 f9 01 	lds	r11, 0x01F9	; 0x8001f9 <ioByteCnt+0x1>
    40e8:	a1 14       	cp	r10, r1
    40ea:	b1 04       	cpc	r11, r1
    40ec:	19 f5       	brne	.+70     	; 0x4134 <main+0x1330>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1249
              // First byte of 512, so set the right file pointer to the current emulated track/sector first
            {
              if ((trackSel < 512) && (sectSel < 32) && (!diskErr))
    40ee:	60 91 f4 01 	lds	r22, 0x01F4	; 0x8001f4 <trackSel>
    40f2:	70 91 f5 01 	lds	r23, 0x01F5	; 0x8001f5 <trackSel+0x1>
    40f6:	61 15       	cp	r22, r1
    40f8:	32 e0       	ldi	r19, 0x02	; 2
    40fa:	73 07       	cpc	r23, r19
    40fc:	d8 f4       	brcc	.+54     	; 0x4134 <main+0x1330>
    40fe:	80 91 f3 01 	lds	r24, 0x01F3	; 0x8001f3 <sectSel>
    4102:	80 32       	cpi	r24, 0x20	; 32
    4104:	b8 f4       	brcc	.+46     	; 0x4134 <main+0x1330>
    4106:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <diskErr>
    410a:	91 11       	cpse	r25, r1
    410c:	13 c0       	rjmp	.+38     	; 0x4134 <main+0x1330>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1252
                // Sector and track numbers valid and no previous error; set the LBA-like logical sector
              {
                diskErr = seekSD((trackSel << 5) | sectSel);  // Set the starting point inside the "disk file"
    410e:	35 e0       	ldi	r19, 0x05	; 5
    4110:	66 0f       	add	r22, r22
    4112:	77 1f       	adc	r23, r23
    4114:	3a 95       	dec	r19
    4116:	e1 f7       	brne	.-8      	; 0x4110 <main+0x130c>
    4118:	68 2b       	or	r22, r24
seekSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2726
// NOTE: "secNum" is in the range [0..16383], and the sector addressing is continuos inside a "disk file";
//       16383 = (512 * 32) - 1, where 512 is the number of emulated tracks, 32 is the number of emulated sectors
//
{
  byte i;
  return pf_lseek(((unsigned long) sectNum) << 9);
    411a:	90 e0       	ldi	r25, 0x00	; 0
    411c:	80 e0       	ldi	r24, 0x00	; 0
    411e:	49 e0       	ldi	r20, 0x09	; 9
    4120:	66 0f       	add	r22, r22
    4122:	77 1f       	adc	r23, r23
    4124:	88 1f       	adc	r24, r24
    4126:	99 1f       	adc	r25, r25
    4128:	4a 95       	dec	r20
    412a:	d1 f7       	brne	.-12     	; 0x4120 <main+0x131c>
    412c:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <pf_lseek>
    4130:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <diskErr>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1259
                //  logical sector address created as TTTTTTTTTSSSSS
              }
            }


            if (!diskErr)
    4134:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <diskErr>
    4138:	81 11       	cpse	r24, r1
    413a:	80 c0       	rjmp	.+256    	; 0x423c <main+0x1438>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1262
              // No previous error (e.g. selecting disk, track or sector)
            {
              tempByte = ioByteCnt % 32;          // [0..31]
    413c:	8a 2d       	mov	r24, r10
    413e:	8f 71       	andi	r24, 0x1F	; 31
    4140:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <tempByte>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1263
              bufferSD[tempByte] = ioData;        // Store current exchanged data byte in the buffer array
    4144:	e8 2f       	mov	r30, r24
    4146:	f0 e0       	ldi	r31, 0x00	; 0
    4148:	e7 5a       	subi	r30, 0xA7	; 167
    414a:	fd 4f       	sbci	r31, 0xFD	; 253
    414c:	f0 82       	st	Z, r15
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1264
              if (tempByte == 31)
    414e:	8f 31       	cpi	r24, 0x1F	; 31
    4150:	09 f0       	breq	.+2      	; 0x4154 <main+0x1350>
    4152:	74 c0       	rjmp	.+232    	; 0x423c <main+0x1438>
pf_write():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:931
	CLUST clst;
	DWORD sect, remain;
	const BYTE *p = (BYTE*)buff;  // whg
	BYTE cs;
	UINT wcnt;
	FATFS *fs = FatFs;
    4154:	00 91 a4 02 	lds	r16, 0x02A4	; 0x8002a4 <FatFs>
    4158:	10 91 a5 02 	lds	r17, 0x02A5	; 0x8002a5 <FatFs+0x1>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:934


	*bw = 0;
    415c:	81 2c       	mov	r8, r1
main():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:935
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    415e:	85 e0       	ldi	r24, 0x05	; 5
pf_write():
    4160:	01 15       	cp	r16, r1
    4162:	11 05       	cpc	r17, r1
    4164:	09 f4       	brne	.+2      	; 0x4168 <main+0x1364>
    4166:	58 c0       	rjmp	.+176    	; 0x4218 <main+0x1414>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:936
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
    4168:	f8 01       	movw	r30, r16
    416a:	81 81       	ldd	r24, Z+1	; 0x01
    416c:	80 ff       	sbrs	r24, 0
    416e:	dd c0       	rjmp	.+442    	; 0x432a <main+0x1526>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:944
	if (!btw) {		/* Finalize request */
		if ((fs->flag & FA__WIP) && disk_writep(0, 0)) ABORT(FR_DISK_ERR);
		fs->flag &= ~FA__WIP;
		return FR_OK;
	} else {		/* Write data request */
		if (!(fs->flag & FA__WIP))		/* Round-down fptr to the sector boundary */
    4170:	86 fd       	sbrc	r24, 6
    4172:	0a c0       	rjmp	.+20     	; 0x4188 <main+0x1384>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:945
			fs->fptr &= 0xFFFFFE00;
    4174:	86 89       	ldd	r24, Z+22	; 0x16
    4176:	97 89       	ldd	r25, Z+23	; 0x17
    4178:	a0 8d       	ldd	r26, Z+24	; 0x18
    417a:	b1 8d       	ldd	r27, Z+25	; 0x19
    417c:	88 27       	eor	r24, r24
    417e:	9e 7f       	andi	r25, 0xFE	; 254
    4180:	86 8b       	std	Z+22, r24	; 0x16
    4182:	97 8b       	std	Z+23, r25	; 0x17
    4184:	a0 8f       	std	Z+24, r26	; 0x18
    4186:	b1 8f       	std	Z+25, r27	; 0x19
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:947
	}
	remain = fs->fsize - fs->fptr;
    4188:	f8 01       	movw	r30, r16
    418a:	82 8d       	ldd	r24, Z+26	; 0x1a
    418c:	93 8d       	ldd	r25, Z+27	; 0x1b
    418e:	a4 8d       	ldd	r26, Z+28	; 0x1c
    4190:	b5 8d       	ldd	r27, Z+29	; 0x1d
    4192:	46 89       	ldd	r20, Z+22	; 0x16
    4194:	57 89       	ldd	r21, Z+23	; 0x17
    4196:	60 8d       	ldd	r22, Z+24	; 0x18
    4198:	71 8d       	ldd	r23, Z+25	; 0x19
    419a:	84 1b       	sub	r24, r20
    419c:	95 0b       	sbc	r25, r21
    419e:	a6 0b       	sbc	r26, r22
    41a0:	b7 0b       	sbc	r27, r23
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:948
	if (btw > remain) btw = (UINT)remain;			/* Truncate btw by remaining bytes */
    41a2:	80 32       	cpi	r24, 0x20	; 32
    41a4:	91 05       	cpc	r25, r1
    41a6:	a1 05       	cpc	r26, r1
    41a8:	b1 05       	cpc	r27, r1
    41aa:	20 f0       	brcs	.+8      	; 0x41b4 <main+0x13b0>
    41ac:	80 e2       	ldi	r24, 0x20	; 32
    41ae:	90 e0       	ldi	r25, 0x00	; 0
    41b0:	a0 e0       	ldi	r26, 0x00	; 0
    41b2:	b0 e0       	ldi	r27, 0x00	; 0
    41b4:	7c 01       	movw	r14, r24
    41b6:	91 2c       	mov	r9, r1
    41b8:	81 2c       	mov	r8, r1
    41ba:	29 e5       	ldi	r18, 0x59	; 89
    41bc:	32 e0       	ldi	r19, 0x02	; 2
    41be:	3a 87       	std	Y+10, r19	; 0x0a
    41c0:	29 87       	std	Y+9, r18	; 0x09
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:950

	while (btw)	{									/* Repeat until all data transferred */
    41c2:	e1 14       	cp	r14, r1
    41c4:	f1 04       	cpc	r15, r1
    41c6:	09 f4       	brne	.+2      	; 0x41ca <main+0x13c6>
    41c8:	b3 c0       	rjmp	.+358    	; 0x4330 <main+0x152c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:951
		if ((UINT)fs->fptr % 512 == 0) {			/* On the sector boundary? */
    41ca:	f8 01       	movw	r30, r16
    41cc:	86 89       	ldd	r24, Z+22	; 0x16
    41ce:	97 89       	ldd	r25, Z+23	; 0x17
    41d0:	a0 8d       	ldd	r26, Z+24	; 0x18
    41d2:	b1 8d       	ldd	r27, Z+25	; 0x19
    41d4:	9c 01       	movw	r18, r24
    41d6:	31 70       	andi	r19, 0x01	; 1
    41d8:	23 2b       	or	r18, r19
    41da:	09 f0       	breq	.+2      	; 0x41de <main+0x13da>
    41dc:	66 c0       	rjmp	.+204    	; 0x42aa <main+0x14a6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:952
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1));	/* Sector offset in the cluster */
    41de:	72 80       	ldd	r7, Z+2	; 0x02
    41e0:	7a 94       	dec	r7
    41e2:	ac 01       	movw	r20, r24
    41e4:	bd 01       	movw	r22, r26
    41e6:	29 e0       	ldi	r18, 0x09	; 9
    41e8:	76 95       	lsr	r23
    41ea:	67 95       	ror	r22
    41ec:	57 95       	ror	r21
    41ee:	47 95       	ror	r20
    41f0:	2a 95       	dec	r18
    41f2:	d1 f7       	brne	.-12     	; 0x41e8 <main+0x13e4>
    41f4:	74 22       	and	r7, r20
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:953
			if (!cs) {								/* On the cluster boundary? */
    41f6:	a9 f5       	brne	.+106    	; 0x4262 <main+0x145e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:954
				if (fs->fptr == 0)					/* On the top of the file? */
    41f8:	89 2b       	or	r24, r25
    41fa:	8a 2b       	or	r24, r26
    41fc:	8b 2b       	or	r24, r27
    41fe:	31 f5       	brne	.+76     	; 0x424c <main+0x1448>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:955
					clst = fs->org_clust;
    4200:	66 8d       	ldd	r22, Z+30	; 0x1e
    4202:	77 8d       	ldd	r23, Z+31	; 0x1f
    4204:	80 a1       	ldd	r24, Z+32	; 0x20
    4206:	91 a1       	ldd	r25, Z+33	; 0x21
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:958
				else
					clst = get_fat(fs->curr_clust);
				if (clst <= 1) ABORT(FR_DISK_ERR);
    4208:	f8 01       	movw	r30, r16
    420a:	62 30       	cpi	r22, 0x02	; 2
    420c:	71 05       	cpc	r23, r1
    420e:	81 05       	cpc	r24, r1
    4210:	91 05       	cpc	r25, r1
    4212:	18 f5       	brcc	.+70     	; 0x425a <main+0x1456>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:973
		if (wcnt > btw) wcnt = btw;
		if (disk_writep(p, wcnt)) ABORT(FR_DISK_ERR);	/* Send data to the sector */
		fs->fptr += wcnt; p += wcnt;				/* Update pointers and counters */
		btw -= wcnt; *bw += wcnt;
		if ((UINT)fs->fptr % 512 == 0) {
			if (disk_writep(0, 0)) ABORT(FR_DISK_ERR);	/* Finalize the currtent secter write operation */
    4214:	11 82       	std	Z+1, r1	; 0x01
main():
    4216:	81 e0       	ldi	r24, 0x01	; 1
writeSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2710
  }
  else
  {
    errcode = pf_write(0, 0, &numBytes);
  }
  *numWrittenBytes = (byte) numBytes;
    4218:	80 92 f1 01 	sts	0x01F1, r8	; 0x8001f1 <numWriBytes>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1267
              tempByte = ioByteCnt % 32;          // [0..31]
              bufferSD[tempByte] = ioData;        // Store current exchanged data byte in the buffer array
              if (tempByte == 31)
                // Buffer full. Write all the buffer content (32 bytes) into the "disk file"
              {
                diskErr = writeSD(bufferSD, &numWriBytes);
    421c:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <diskErr>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1268
                if (numWriBytes < 32) diskErr = 19; // Reached an unexpected EOF
    4220:	ff e1       	ldi	r31, 0x1F	; 31
    4222:	f8 15       	cp	r31, r8
    4224:	08 f4       	brcc	.+2      	; 0x4228 <main+0x1424>
    4226:	86 c0       	rjmp	.+268    	; 0x4334 <main+0x1530>
    4228:	83 e1       	ldi	r24, 0x13	; 19
    422a:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <diskErr>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1269
                if (ioByteCnt >= 511)
    422e:	2f ef       	ldi	r18, 0xFF	; 255
    4230:	a2 16       	cp	r10, r18
    4232:	21 e0       	ldi	r18, 0x01	; 1
    4234:	b2 06       	cpc	r11, r18
    4236:	10 f0       	brcs	.+4      	; 0x423c <main+0x1438>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1273
                  // Finalize write operation and check result (if no previous error occurred)
                {
                  if (!diskErr) diskErr = writeSD(NULL, &numWriBytes);
                  ioOpcode = 0xFF;                // All done. Set ioOpcode = "No operation"
    4238:	d0 92 79 00 	sts	0x0079, r13	; 0x800079 <ioOpcode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1277
                }
              }
            }
            ioByteCnt++;                          // Increment the counter of the exchanged data bytes
    423c:	ff ef       	ldi	r31, 0xFF	; 255
    423e:	af 1a       	sub	r10, r31
    4240:	bf 0a       	sbc	r11, r31
    4242:	b0 92 f9 01 	sts	0x01F9, r11	; 0x8001f9 <ioByteCnt+0x1>
    4246:	a0 92 f8 01 	sts	0x01F8, r10	; 0x8001f8 <ioByteCnt>
    424a:	85 ce       	rjmp	.-758    	; 0x3f56 <main+0x1152>
pf_write():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:957
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1));	/* Sector offset in the cluster */
			if (!cs) {								/* On the cluster boundary? */
				if (fs->fptr == 0)					/* On the top of the file? */
					clst = fs->org_clust;
				else
					clst = get_fat(fs->curr_clust);
    424c:	62 a1       	ldd	r22, Z+34	; 0x22
    424e:	73 a1       	ldd	r23, Z+35	; 0x23
    4250:	84 a1       	ldd	r24, Z+36	; 0x24
    4252:	95 a1       	ldd	r25, Z+37	; 0x25
    4254:	0e 94 2c 0c 	call	0x1858	; 0x1858 <get_fat(unsigned long)>
    4258:	d7 cf       	rjmp	.-82     	; 0x4208 <main+0x1404>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:959
				if (clst <= 1) ABORT(FR_DISK_ERR);
				fs->curr_clust = clst;				/* Update current cluster */
    425a:	62 a3       	std	Z+34, r22	; 0x22
    425c:	73 a3       	std	Z+35, r23	; 0x23
    425e:	84 a3       	std	Z+36, r24	; 0x24
    4260:	95 a3       	std	Z+37, r25	; 0x25
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:961
			}
			sect = clust2sect(fs->curr_clust);		/* Get current sector */
    4262:	f8 01       	movw	r30, r16
    4264:	62 a1       	ldd	r22, Z+34	; 0x22
    4266:	73 a1       	ldd	r23, Z+35	; 0x23
    4268:	84 a1       	ldd	r24, Z+36	; 0x24
    426a:	95 a1       	ldd	r25, Z+37	; 0x25
    426c:	0e 94 a1 08 	call	0x1142	; 0x1142 <clust2sect(unsigned long)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:962
			if (!sect) ABORT(FR_DISK_ERR);
    4270:	61 15       	cp	r22, r1
    4272:	71 05       	cpc	r23, r1
    4274:	81 05       	cpc	r24, r1
    4276:	91 05       	cpc	r25, r1
    4278:	11 f4       	brne	.+4      	; 0x427e <main+0x147a>
    427a:	f8 01       	movw	r30, r16
    427c:	cb cf       	rjmp	.-106    	; 0x4214 <main+0x1410>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:963
			fs->dsect = sect + cs;
    427e:	ab 01       	movw	r20, r22
    4280:	bc 01       	movw	r22, r24
    4282:	47 0d       	add	r20, r7
    4284:	51 1d       	adc	r21, r1
    4286:	61 1d       	adc	r22, r1
    4288:	71 1d       	adc	r23, r1
    428a:	f8 01       	movw	r30, r16
    428c:	46 a3       	std	Z+38, r20	; 0x26
    428e:	57 a3       	std	Z+39, r21	; 0x27
    4290:	60 a7       	std	Z+40, r22	; 0x28
    4292:	71 a7       	std	Z+41, r23	; 0x29
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:964
			if (disk_writep(0, fs->dsect)) ABORT(FR_DISK_ERR);	/* Initiate a sector write operation */
    4294:	90 e0       	ldi	r25, 0x00	; 0
    4296:	80 e0       	ldi	r24, 0x00	; 0
    4298:	0e 94 47 16 	call	0x2c8e	; 0x2c8e <disk_writep>
    429c:	f8 01       	movw	r30, r16
    429e:	89 2b       	or	r24, r25
    42a0:	09 f0       	breq	.+2      	; 0x42a4 <main+0x14a0>
    42a2:	b8 cf       	rjmp	.-144    	; 0x4214 <main+0x1410>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:965
			fs->flag |= FA__WIP;
    42a4:	81 81       	ldd	r24, Z+1	; 0x01
    42a6:	80 64       	ori	r24, 0x40	; 64
    42a8:	81 83       	std	Z+1, r24	; 0x01
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:967
		}
		wcnt = 512 - (UINT)fs->fptr % 512;			/* Number of bytes to write to the sector */
    42aa:	f8 01       	movw	r30, r16
    42ac:	86 89       	ldd	r24, Z+22	; 0x16
    42ae:	97 89       	ldd	r25, Z+23	; 0x17
    42b0:	91 70       	andi	r25, 0x01	; 1
    42b2:	20 e0       	ldi	r18, 0x00	; 0
    42b4:	32 e0       	ldi	r19, 0x02	; 2
    42b6:	28 1b       	sub	r18, r24
    42b8:	39 0b       	sbc	r19, r25
    42ba:	37 01       	movw	r6, r14
    42bc:	2e 15       	cp	r18, r14
    42be:	3f 05       	cpc	r19, r15
    42c0:	08 f4       	brcc	.+2      	; 0x42c4 <main+0x14c0>
    42c2:	39 01       	movw	r6, r18
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:969
		if (wcnt > btw) wcnt = btw;
		if (disk_writep(p, wcnt)) ABORT(FR_DISK_ERR);	/* Send data to the sector */
    42c4:	13 01       	movw	r2, r6
    42c6:	51 2c       	mov	r5, r1
    42c8:	41 2c       	mov	r4, r1
    42ca:	b2 01       	movw	r22, r4
    42cc:	a3 01       	movw	r20, r6
    42ce:	89 85       	ldd	r24, Y+9	; 0x09
    42d0:	9a 85       	ldd	r25, Y+10	; 0x0a
    42d2:	0e 94 47 16 	call	0x2c8e	; 0x2c8e <disk_writep>
    42d6:	f8 01       	movw	r30, r16
    42d8:	89 2b       	or	r24, r25
    42da:	09 f0       	breq	.+2      	; 0x42de <main+0x14da>
    42dc:	9b cf       	rjmp	.-202    	; 0x4214 <main+0x1410>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:970
		fs->fptr += wcnt; p += wcnt;				/* Update pointers and counters */
    42de:	86 89       	ldd	r24, Z+22	; 0x16
    42e0:	97 89       	ldd	r25, Z+23	; 0x17
    42e2:	a0 8d       	ldd	r26, Z+24	; 0x18
    42e4:	b1 8d       	ldd	r27, Z+25	; 0x19
    42e6:	82 0d       	add	r24, r2
    42e8:	93 1d       	adc	r25, r3
    42ea:	a4 1d       	adc	r26, r4
    42ec:	b5 1d       	adc	r27, r5
    42ee:	86 8b       	std	Z+22, r24	; 0x16
    42f0:	97 8b       	std	Z+23, r25	; 0x17
    42f2:	a0 8f       	std	Z+24, r26	; 0x18
    42f4:	b1 8f       	std	Z+25, r27	; 0x19
    42f6:	29 85       	ldd	r18, Y+9	; 0x09
    42f8:	3a 85       	ldd	r19, Y+10	; 0x0a
    42fa:	26 0d       	add	r18, r6
    42fc:	37 1d       	adc	r19, r7
    42fe:	3a 87       	std	Y+10, r19	; 0x0a
    4300:	29 87       	std	Y+9, r18	; 0x09
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:971
		btw -= wcnt; *bw += wcnt;
    4302:	e6 18       	sub	r14, r6
    4304:	f7 08       	sbc	r15, r7
    4306:	86 0c       	add	r8, r6
    4308:	97 1c       	adc	r9, r7
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:972
		if ((UINT)fs->fptr % 512 == 0) {
    430a:	1c 01       	movw	r2, r24
    430c:	31 e0       	ldi	r19, 0x01	; 1
    430e:	33 22       	and	r3, r19
    4310:	23 28       	or	r2, r3
    4312:	09 f0       	breq	.+2      	; 0x4316 <main+0x1512>
    4314:	56 cf       	rjmp	.-340    	; 0x41c2 <main+0x13be>
disk_writep():
    4316:	0e 94 1c 09 	call	0x1238	; 0x1238 <disk_writep.part.1>
pf_write():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:973
			if (disk_writep(0, 0)) ABORT(FR_DISK_ERR);	/* Finalize the currtent secter write operation */
    431a:	f8 01       	movw	r30, r16
    431c:	89 2b       	or	r24, r25
    431e:	09 f0       	breq	.+2      	; 0x4322 <main+0x151e>
    4320:	79 cf       	rjmp	.-270    	; 0x4214 <main+0x1410>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:974
			fs->flag &= ~FA__WIP;
    4322:	81 81       	ldd	r24, Z+1	; 0x01
    4324:	8f 7b       	andi	r24, 0xBF	; 191
    4326:	81 83       	std	Z+1, r24	; 0x01
    4328:	4c cf       	rjmp	.-360    	; 0x41c2 <main+0x13be>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:934
	BYTE cs;
	UINT wcnt;
	FATFS *fs = FatFs;


	*bw = 0;
    432a:	81 2c       	mov	r8, r1
main():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:937
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
		return FR_NOT_OPENED;
    432c:	84 e0       	ldi	r24, 0x04	; 4
    432e:	74 cf       	rjmp	.-280    	; 0x4218 <main+0x1414>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:978
			if (disk_writep(0, 0)) ABORT(FR_DISK_ERR);	/* Finalize the currtent secter write operation */
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
    4330:	80 e0       	ldi	r24, 0x00	; 0
    4332:	72 cf       	rjmp	.-284    	; 0x4218 <main+0x1414>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1269
              if (tempByte == 31)
                // Buffer full. Write all the buffer content (32 bytes) into the "disk file"
              {
                diskErr = writeSD(bufferSD, &numWriBytes);
                if (numWriBytes < 32) diskErr = 19; // Reached an unexpected EOF
                if (ioByteCnt >= 511)
    4334:	3f ef       	ldi	r19, 0xFF	; 255
    4336:	a3 16       	cp	r10, r19
    4338:	31 e0       	ldi	r19, 0x01	; 1
    433a:	b3 06       	cpc	r11, r19
    433c:	08 f4       	brcc	.+2      	; 0x4340 <main+0x153c>
    433e:	7e cf       	rjmp	.-260    	; 0x423c <main+0x1438>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1272
                  // Finalize write operation and check result (if no previous error occurred)
                {
                  if (!diskErr) diskErr = writeSD(NULL, &numWriBytes);
    4340:	81 11       	cpse	r24, r1
    4342:	7a cf       	rjmp	.-268    	; 0x4238 <main+0x1434>
main():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:935
	UINT wcnt;
	FATFS *fs = FatFs;


	*bw = 0;
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    4344:	85 e0       	ldi	r24, 0x05	; 5
pf_write():
    4346:	01 15       	cp	r16, r1
    4348:	11 05       	cpc	r17, r1
    434a:	69 f0       	breq	.+26     	; 0x4366 <main+0x1562>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:936
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
    434c:	f8 01       	movw	r30, r16
    434e:	81 81       	ldd	r24, Z+1	; 0x01
    4350:	80 ff       	sbrs	r24, 0
    4352:	14 c0       	rjmp	.+40     	; 0x437c <main+0x1578>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:940
		return FR_NOT_OPENED;

	if (!btw) {		/* Finalize request */
		if ((fs->flag & FA__WIP) && disk_writep(0, 0)) ABORT(FR_DISK_ERR);
    4354:	86 ff       	sbrs	r24, 6
    4356:	0c c0       	rjmp	.+24     	; 0x4370 <main+0x156c>
disk_writep():
    4358:	0e 94 1c 09 	call	0x1238	; 0x1238 <disk_writep.part.1>
pf_write():
    435c:	89 2b       	or	r24, r25
    435e:	41 f0       	breq	.+16     	; 0x4370 <main+0x156c>
    4360:	f8 01       	movw	r30, r16
    4362:	11 82       	std	Z+1, r1	; 0x01
main():
    4364:	81 e0       	ldi	r24, 0x01	; 1
writeSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2710
  }
  else
  {
    errcode = pf_write(0, 0, &numBytes);
  }
  *numWrittenBytes = (byte) numBytes;
    4366:	10 92 f1 01 	sts	0x01F1, r1	; 0x8001f1 <numWriBytes>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2708
  {
    errcode = pf_write(buffSD, 32, &numBytes);
  }
  else
  {
    errcode = pf_write(0, 0, &numBytes);
    436a:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <diskErr>
    436e:	64 cf       	rjmp	.-312    	; 0x4238 <main+0x1434>
pf_write():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:941
		fs->flag &= ~FA__WIP;
    4370:	f8 01       	movw	r30, r16
    4372:	81 81       	ldd	r24, Z+1	; 0x01
    4374:	8f 7b       	andi	r24, 0xBF	; 191
    4376:	81 83       	std	Z+1, r24	; 0x01
main():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:942
		return FR_OK;
    4378:	80 e0       	ldi	r24, 0x00	; 0
    437a:	f5 cf       	rjmp	.-22     	; 0x4366 <main+0x1562>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/pff.cpp:937


	*bw = 0;
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
		return FR_NOT_OPENED;
    437c:	84 e0       	ldi	r24, 0x04	; 4
    437e:	f3 cf       	rjmp	.-26     	; 0x4366 <main+0x1562>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1329
            //  fixed bank mapped in the upper half of the Z80 address space (from 0x8000 to 0xFFFF).
            //
            //
            // NOTE: If the Os Bank number is greater than 2 no selection is done.

            switch (ioData)
    4380:	21 e0       	ldi	r18, 0x01	; 1
    4382:	f2 16       	cp	r15, r18
    4384:	71 f0       	breq	.+28     	; 0x43a2 <main+0x159e>
    4386:	f2 16       	cp	r15, r18
    4388:	28 f0       	brcs	.+10     	; 0x4394 <main+0x1590>
    438a:	32 e0       	ldi	r19, 0x02	; 2
    438c:	f3 12       	cpse	r15, r19
    438e:	e3 cd       	rjmp	.-1082   	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1345
                digitalWrite(BANK1, HIGH);
                break;

              case 2:                             // Os bank 2
                // Set physical bank 3 (logical bank 2)
                digitalWrite(BANK0, LOW);
    4390:	60 e0       	ldi	r22, 0x00	; 0
    4392:	08 c0       	rjmp	.+16     	; 0x43a4 <main+0x15a0>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1333

            switch (ioData)
            {
              case 0:                             // Os bank 0
                // Set physical bank 0 (logical bank 1)
                digitalWrite(BANK0, HIGH);
    4394:	61 e0       	ldi	r22, 0x01	; 1
    4396:	8c e0       	ldi	r24, 0x0C	; 12
    4398:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1334
                digitalWrite(BANK1, LOW);
    439c:	60 e0       	ldi	r22, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1340
                break;

              case 1:                             // Os bank 1
                // Set physical bank 2 (logical bank 3)
                digitalWrite(BANK0, HIGH);
                digitalWrite(BANK1, HIGH);
    439e:	8b e0       	ldi	r24, 0x0B	; 11
    43a0:	d8 cd       	rjmp	.-1104   	; 0x3f52 <main+0x114e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1339
                digitalWrite(BANK1, LOW);
                break;

              case 1:                             // Os bank 1
                // Set physical bank 2 (logical bank 3)
                digitalWrite(BANK0, HIGH);
    43a2:	61 e0       	ldi	r22, 0x01	; 1
    43a4:	8c e0       	ldi	r24, 0x0C	; 12
    43a6:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1340
                digitalWrite(BANK1, HIGH);
    43aa:	61 e0       	ldi	r22, 0x01	; 1
    43ac:	f8 cf       	rjmp	.-16     	; 0x439e <main+0x159a>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1417
            // To ensure safe Opcode calls inside the Z80 user code, before every Opcode call the interrupt must be
            //  disabled an re-enabled soon after the completion of the Opcode call.
            //
            // ...................................................................................

            Z80IntRx = ioData & 1;                // Enable/disable the Systick IRQ generation
    43ae:	8f 2d       	mov	r24, r15
    43b0:	81 70       	andi	r24, 0x01	; 1
    43b2:	80 93 f0 01 	sts	0x01F0, r24	; 0x8001f0 <Z80IntRx>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1418
            Z80IntSysTick = (ioData & (1 << 1)) >> 1;  // Enable/disable the Serial Rx IRQ generation
    43b6:	f1 fa       	bst	r15, 1
    43b8:	ff 24       	eor	r15, r15
    43ba:	f0 f8       	bld	r15, 0
    43bc:	f0 92 ef 01 	sts	0x01EF, r15	; 0x8001ef <Z80IntSysTick>
    43c0:	ca cd       	rjmp	.-1132   	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1434
            // At reset time the default value is 100ms.
            // See SETIRQ and SYSIRQ Opcodes for more info.
            //
            // NOTE: If the time is 0 milliseconds the set operation is ignored.

            if (ioData > 0) sysTickTime = ioData;
    43c2:	ff 20       	and	r15, r15
    43c4:	09 f4       	brne	.+2      	; 0x43c8 <main+0x15c4>
    43c6:	c7 cd       	rjmp	.-1138   	; 0x3f56 <main+0x1152>
    43c8:	f0 92 6c 00 	sts	0x006C, r15	; 0x80006c <sysTickTime>
    43cc:	c4 cd       	rjmp	.-1144   	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1452
            // The value of D0 can be read using the SYSFLAGS Opcode (bit D4).
            //
            // NOTE: The CP/M custom BIOS (CBIOS) must implement a read of the SYSFLAGS (bit D4) Opcode to switch on/off
            //       the CP/M warm boot message display

            cpmWarmBootFlg = ioData & 0x01;
    43ce:	8f 2d       	mov	r24, r15
    43d0:	81 70       	andi	r24, 0x01	; 1
    43d2:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <cpmWarmBootFlg>
    43d6:	bf cd       	rjmp	.-1154   	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1500
            // NOTE 1: When the GPIO is set to operate as an SPP port all the GPIO write Opcodes (GPIOA Write, GPIOB Write, IODIRA Write,
            //         IODIRB Write, GPPUA Write, GPPUB Write) are ignored/disabled.
            // NOTE 2: If the GPIO expansion module (GPE) is not found this Opcode is ignored.
            // NOTE 3: When the SPP mode is activated cannot be disabled anymore (the only way is reset the board).

            if (moduleGPIO)                       // Only if GPE was found
    43d8:	80 91 f7 01 	lds	r24, 0x01F7	; 0x8001f7 <moduleGPIO>
    43dc:	88 23       	and	r24, r24
    43de:	09 f4       	brne	.+2      	; 0x43e2 <main+0x15de>
    43e0:	ba cd       	rjmp	.-1164   	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1502
            {
              SPPmode = 1;                        // Set the SPP mode flag
    43e2:	81 e0       	ldi	r24, 0x01	; 1
    43e4:	80 93 ed 01 	sts	0x01ED, r24	; 0x8001ed <SPPmode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1503
              SPPautofd = (!ioData) & 0x01;       // Store the value of the AUTOFD Control Line (active Low))
    43e8:	11 e0       	ldi	r17, 0x01	; 1
    43ea:	f1 10       	cpse	r15, r1
    43ec:	10 e0       	ldi	r17, 0x00	; 0
    43ee:	10 93 ec 01 	sts	0x01EC, r17	; 0x8001ec <SPPautofd>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    43f2:	80 e2       	ldi	r24, 0x20	; 32
    43f4:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1507

              // Set STROBE and INIT at 1, and AUTOFD = !D0
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOA_REG);              // Select GPIOA
    43f8:	82 e1       	ldi	r24, 0x12	; 18
    43fa:	90 e0       	ldi	r25, 0x00	; 0
    43fc:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1508
              Wire.write(0b00000101 | (byte) (SPPautofd << 1)); // Write value
    4400:	11 0f       	add	r17, r17
    4402:	01 2f       	mov	r16, r17
    4404:	05 60       	ori	r16, 0x05	; 5
    4406:	80 2f       	mov	r24, r16
    4408:	90 e0       	ldi	r25, 0x00	; 0
    440a:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1509
              Wire.endTransmission();
    440e:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    4412:	80 e2       	ldi	r24, 0x20	; 32
    4414:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1513

              // Set the GPIO port to work as an SPP port (direction and pullup)
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(IODIRA_REG);             // Select IODIRA
    4418:	90 e0       	ldi	r25, 0x00	; 0
    441a:	80 e0       	ldi	r24, 0x00	; 0
    441c:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1514
              Wire.write(0b11111000);             // Write value (1 = input, 0 = ouput)
    4420:	88 ef       	ldi	r24, 0xF8	; 248
    4422:	90 e0       	ldi	r25, 0x00	; 0
    4424:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1515
              Wire.endTransmission();
    4428:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    442c:	80 e2       	ldi	r24, 0x20	; 32
    442e:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1517
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(IODIRB_REG);             // Select IODIRB
    4432:	81 e0       	ldi	r24, 0x01	; 1
    4434:	90 e0       	ldi	r25, 0x00	; 0
    4436:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1518
              Wire.write(0b00000000);             // Write value (1 = input, 0 = ouput)
    443a:	90 e0       	ldi	r25, 0x00	; 0
    443c:	80 e0       	ldi	r24, 0x00	; 0
    443e:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1519
              Wire.endTransmission();
    4442:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    4446:	80 e2       	ldi	r24, 0x20	; 32
    4448:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1521
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPPUA_REG);              // Select GPPUA
    444c:	8c e0       	ldi	r24, 0x0C	; 12
    444e:	90 e0       	ldi	r25, 0x00	; 0
    4450:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1522
              Wire.write(0b11111111);             // Write value (1 = pullup enabled, 0 = pullup disabled)
    4454:	8f ef       	ldi	r24, 0xFF	; 255
    4456:	90 e0       	ldi	r25, 0x00	; 0
    4458:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1523
              Wire.endTransmission();
    445c:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    4460:	80 e2       	ldi	r24, 0x20	; 32
    4462:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1529

              // Initialize the printer using a pulse on INIT
              // NOTE: The I2C protocol introduces delays greater than needed by the SPP, so no further delay is used here to generate the pulse
              tempByte = 0b00000001 | (byte) (SPPautofd << 1);  // Change INIT bit to active (Low)
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOA_REG);              // Select GPIOA
    4466:	82 e1       	ldi	r24, 0x12	; 18
    4468:	90 e0       	ldi	r25, 0x00	; 0
    446a:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1527
              Wire.write(0b11111111);             // Write value (1 = pullup enabled, 0 = pullup disabled)
              Wire.endTransmission();

              // Initialize the printer using a pulse on INIT
              // NOTE: The I2C protocol introduces delays greater than needed by the SPP, so no further delay is used here to generate the pulse
              tempByte = 0b00000001 | (byte) (SPPautofd << 1);  // Change INIT bit to active (Low)
    446e:	61 2f       	mov	r22, r17
    4470:	61 60       	ori	r22, 0x01	; 1
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1530
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOA_REG);              // Select GPIOA
              Wire.write(tempByte);               // Set INIT bit to active (Low)
    4472:	83 e4       	ldi	r24, 0x43	; 67
    4474:	93 e0       	ldi	r25, 0x03	; 3
    4476:	0e 94 b9 07 	call	0xf72	; 0xf72 <TwoWire::write(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1531
              Wire.endTransmission();
    447a:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1532
              tempByte = tempByte | 0b00000100;   // Change INIT bit to not active (High)
    447e:	00 93 f2 01 	sts	0x01F2, r16	; 0x8001f2 <tempByte>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    4482:	80 e2       	ldi	r24, 0x20	; 32
    4484:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1534
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOA_REG);              // Select GPIOA
    4488:	82 e1       	ldi	r24, 0x12	; 18
    448a:	90 e0       	ldi	r25, 0x00	; 0
    448c:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1535
              Wire.write(tempByte);               // Set INIT bit to not active (High)
    4490:	60 2f       	mov	r22, r16
    4492:	82 cd       	rjmp	.-1276   	; 0x3f98 <main+0x1194>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1554
            //  ready or not, so you have to use the GETSPP Opcode before for that.
            // If the SPP mode is disabled (or the GPE is not installed) this Opcode is ignored.
            //
            // NOTE: to use WRSPP the SETSPP Opcode should be called first to activate the SPP mode of the GPIO port.

            if (SPPmode)                          // Only if SPP mode is active
    4494:	80 91 ed 01 	lds	r24, 0x01ED	; 0x8001ed <SPPmode>
    4498:	88 23       	and	r24, r24
    449a:	09 f4       	brne	.+2      	; 0x449e <main+0x169a>
    449c:	5c cd       	rjmp	.-1352   	; 0x3f56 <main+0x1152>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    449e:	80 e2       	ldi	r24, 0x20	; 32
    44a0:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1558
            {
              // NOTE: The I2C protocol introduces delays greater than needed by the SPP, so no further delay is used here to generate the pulse
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOB_REG);              // Select GPIOB
    44a4:	83 e1       	ldi	r24, 0x13	; 19
    44a6:	90 e0       	ldi	r25, 0x00	; 0
    44a8:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1559
              Wire.write(ioData);                 // Data on GPIOB
    44ac:	6f 2d       	mov	r22, r15
    44ae:	83 e4       	ldi	r24, 0x43	; 67
    44b0:	93 e0       	ldi	r25, 0x03	; 3
    44b2:	0e 94 b9 07 	call	0xf72	; 0xf72 <TwoWire::write(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1560
              Wire.endTransmission();
    44b6:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1561
              tempByte = 0b11111100 | (byte) (SPPautofd << 1);  // Change STROBE bit to active (Low)
    44ba:	10 91 ec 01 	lds	r17, 0x01EC	; 0x8001ec <SPPautofd>
    44be:	11 0f       	add	r17, r17
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    44c0:	80 e2       	ldi	r24, 0x20	; 32
    44c2:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1563
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOA_REG);              // Select GPIOA
    44c6:	82 e1       	ldi	r24, 0x12	; 18
    44c8:	90 e0       	ldi	r25, 0x00	; 0
    44ca:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1561
              // NOTE: The I2C protocol introduces delays greater than needed by the SPP, so no further delay is used here to generate the pulse
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOB_REG);              // Select GPIOB
              Wire.write(ioData);                 // Data on GPIOB
              Wire.endTransmission();
              tempByte = 0b11111100 | (byte) (SPPautofd << 1);  // Change STROBE bit to active (Low)
    44ce:	61 2f       	mov	r22, r17
    44d0:	6c 6f       	ori	r22, 0xFC	; 252
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1564
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOA_REG);              // Select GPIOA
              Wire.write(tempByte);               // Set STROBE bit to active (Low)
    44d2:	83 e4       	ldi	r24, 0x43	; 67
    44d4:	93 e0       	ldi	r25, 0x03	; 3
    44d6:	0e 94 b9 07 	call	0xf72	; 0xf72 <TwoWire::write(unsigned char)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1565
              Wire.endTransmission();
    44da:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1566
              tempByte = tempByte | 0b00000001;   // Change STROBE bit to not active (High)
    44de:	1d 6f       	ori	r17, 0xFD	; 253
    44e0:	10 93 f2 01 	sts	0x01F2, r17	; 0x8001f2 <tempByte>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    44e4:	80 e2       	ldi	r24, 0x20	; 32
    44e6:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1568
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOA_REG);              // Select GPIOA
    44ea:	82 e1       	ldi	r24, 0x12	; 18
    44ec:	90 e0       	ldi	r25, 0x00	; 0
    44ee:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1569
              Wire.write(tempByte);               // Set STROBE bit to not active (High)
    44f2:	61 2f       	mov	r22, r17
    44f4:	51 cd       	rjmp	.-1374   	; 0x3f98 <main+0x1194>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1575
              Wire.endTransmission();
            }
            break;
          /*LCD FUNCTIONS*/
          case  0x20:
            if (ioData & 0x01) lcd.clear();
    44f6:	f0 fe       	sbrs	r15, 0
    44f8:	2e cd       	rjmp	.-1444   	; 0x3f56 <main+0x1152>
command():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:199
}

/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystal_I2C::command(uint8_t value) {
	send(value, 0);
    44fa:	40 e0       	ldi	r20, 0x00	; 0
    44fc:	61 e0       	ldi	r22, 0x01	; 1
    44fe:	8b e5       	ldi	r24, 0x5B	; 91
    4500:	93 e0       	ldi	r25, 0x03	; 3
    4502:	0e 94 1d 08 	call	0x103a	; 0x103a <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
clear():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:97
}

/********** high level commands, for the user! */
void LiquidCrystal_I2C::clear(){
	command(LCD_CLEARDISPLAY);// clear display, set cursor position to zero
	delayMicroseconds(2000);  // this command takes a long time!
    4506:	80 ed       	ldi	r24, 0xD0	; 208
    4508:	97 e0       	ldi	r25, 0x07	; 7
    450a:	0e 94 d6 06 	call	0xdac	; 0xdac <delayMicroseconds>
    450e:	23 cd       	rjmp	.-1466   	; 0x3f56 <main+0x1152>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1579
            break;

          case  0x21:
            if (!ioByteCnt)
    4510:	00 91 f8 01 	lds	r16, 0x01F8	; 0x8001f8 <ioByteCnt>
    4514:	10 91 f9 01 	lds	r17, 0x01F9	; 0x8001f9 <ioByteCnt+0x1>
    4518:	01 15       	cp	r16, r1
    451a:	11 05       	cpc	r17, r1
    451c:	49 f4       	brne	.+18     	; 0x4530 <main+0x172c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1582
              // X
            {
              lcdX = ioData;
    451e:	f0 92 eb 01 	sts	0x01EB, r15	; 0x8001eb <lcdX>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1591
            {
              lcdY = ioData;
              lcd.setCursor(lcdX, lcdY);
              ioOpcode = 0xFF;                    // All done. Set ioOpcode = "No operation"
            }
            ioByteCnt++;
    4522:	0f 5f       	subi	r16, 0xFF	; 255
    4524:	1f 4f       	sbci	r17, 0xFF	; 255
    4526:	10 93 f9 01 	sts	0x01F9, r17	; 0x8001f9 <ioByteCnt+0x1>
    452a:	00 93 f8 01 	sts	0x01F8, r16	; 0x8001f8 <ioByteCnt>
    452e:	13 cd       	rjmp	.-1498   	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1588
            }
            else
              // Y
            {
              lcdY = ioData;
              lcd.setCursor(lcdX, lcdY);
    4530:	60 91 eb 01 	lds	r22, 0x01EB	; 0x8001eb <lcdX>
setCursor():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:106
	command(LCD_RETURNHOME);  // set cursor position to zero
	delayMicroseconds(2000);  // this command takes a long time!
}

void LiquidCrystal_I2C::setCursor(uint8_t col, uint8_t row){
	int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
    4534:	88 e0       	ldi	r24, 0x08	; 8
    4536:	e0 e8       	ldi	r30, 0x80	; 128
    4538:	f0 e0       	ldi	r31, 0x00	; 0
    453a:	de 01       	movw	r26, r28
    453c:	11 96       	adiw	r26, 0x01	; 1
    453e:	01 90       	ld	r0, Z+
    4540:	0d 92       	st	X+, r0
    4542:	8a 95       	dec	r24
    4544:	e1 f7       	brne	.-8      	; 0x453e <main+0x173a>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:107
	if (row > _rows) {
    4546:	80 91 64 03 	lds	r24, 0x0364	; 0x800364 <lcd+0x9>
    454a:	8f 15       	cp	r24, r15
    454c:	18 f4       	brcc	.+6      	; 0x4554 <main+0x1750>
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:108
		row = _rows-1;    // we count rows starting w/0
    454e:	ff 24       	eor	r15, r15
    4550:	fa 94       	dec	r15
    4552:	f8 0e       	add	r15, r24
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:110
	}
	command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
    4554:	ef 2d       	mov	r30, r15
    4556:	f0 e0       	ldi	r31, 0x00	; 0
    4558:	ee 0f       	add	r30, r30
    455a:	ff 1f       	adc	r31, r31
    455c:	41 e0       	ldi	r20, 0x01	; 1
    455e:	50 e0       	ldi	r21, 0x00	; 0
    4560:	4c 0f       	add	r20, r28
    4562:	5d 1f       	adc	r21, r29
    4564:	e4 0f       	add	r30, r20
    4566:	f5 1f       	adc	r31, r21
    4568:	80 81       	ld	r24, Z
    456a:	68 0f       	add	r22, r24
    456c:	60 68       	ori	r22, 0x80	; 128
command():
C:\Users\anthony\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:199
}

/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystal_I2C::command(uint8_t value) {
	send(value, 0);
    456e:	40 e0       	ldi	r20, 0x00	; 0
    4570:	8b e5       	ldi	r24, 0x5B	; 91
    4572:	93 e0       	ldi	r25, 0x03	; 3
    4574:	0e 94 1d 08 	call	0x103a	; 0x103a <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1589
              ioOpcode = 0xFF;                    // All done. Set ioOpcode = "No operation"
    4578:	d0 92 79 00 	sts	0x0079, r13	; 0x800079 <ioOpcode>
    457c:	d2 cf       	rjmp	.-92     	; 0x4522 <main+0x171e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1594
            }
            ioByteCnt++;
            break;
          case  0x22:
            lcd.write(ioData);
    457e:	6f 2d       	mov	r22, r15
    4580:	8b e5       	ldi	r24, 0x5B	; 91
    4582:	93 e0       	ldi	r25, 0x03	; 3
    4584:	0e 94 34 08 	call	0x1068	; 0x1068 <LiquidCrystal_I2C::write(unsigned char)>
    4588:	e6 cc       	rjmp	.-1588   	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1597
            break;
          case  0x23:
            if ((ioByteCnt==16) || (ioData==0)){ //null char or overflow lcdBuffer
    458a:	80 91 f8 01 	lds	r24, 0x01F8	; 0x8001f8 <ioByteCnt>
    458e:	90 91 f9 01 	lds	r25, 0x01F9	; 0x8001f9 <ioByteCnt+0x1>
    4592:	fc 01       	movw	r30, r24
    4594:	e6 52       	subi	r30, 0x26	; 38
    4596:	fe 4f       	sbci	r31, 0xFE	; 254
    4598:	80 31       	cpi	r24, 0x10	; 16
    459a:	91 05       	cpc	r25, r1
    459c:	11 f0       	breq	.+4      	; 0x45a2 <main+0x179e>
    459e:	f1 10       	cpse	r15, r1
    45a0:	0a c0       	rjmp	.+20     	; 0x45b6 <main+0x17b2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1598
              lcdBuffer[ioByteCnt]=0;
    45a2:	10 82       	st	Z, r1
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1599
              lcd.print(lcdBuffer);   
    45a4:	6a ed       	ldi	r22, 0xDA	; 218
    45a6:	71 e0       	ldi	r23, 0x01	; 1
    45a8:	8b e5       	ldi	r24, 0x5B	; 91
    45aa:	93 e0       	ldi	r25, 0x03	; 3
    45ac:	0e 94 11 12 	call	0x2422	; 0x2422 <Print::print(char const*)>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1600
              ioOpcode = 0xFF;    //ok finish
    45b0:	d0 92 79 00 	sts	0x0079, r13	; 0x800079 <ioOpcode>
    45b4:	d0 cc       	rjmp	.-1632   	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1603
            }
            else{
              lcdBuffer[ioByteCnt++]=ioData; //store lcd ascii
    45b6:	01 96       	adiw	r24, 0x01	; 1
    45b8:	90 93 f9 01 	sts	0x01F9, r25	; 0x8001f9 <ioByteCnt+0x1>
    45bc:	80 93 f8 01 	sts	0x01F8, r24	; 0x8001f8 <ioByteCnt>
    45c0:	f0 82       	st	Z, r15
    45c2:	c9 cc       	rjmp	.-1646   	; 0x3f56 <main+0x1152>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1619
      digitalWrite(BUSREQ_, LOW);                 // Request for a DMA
      digitalWrite(WAIT_RES_, LOW);               // Reset WAIT FF exiting from WAIT state
      digitalWrite(WAIT_RES_, HIGH);              // Now Z80 is in DMA, so it's safe set WAIT_RES_ HIGH again
      digitalWrite(BUSREQ_, HIGH);                // Resume Z80 from DMA
    }
    else if (!digitalRead(RD_))
    45c4:	84 e1       	ldi	r24, 0x14	; 20
    45c6:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
    45ca:	89 2b       	or	r24, r25
    45cc:	09 f0       	breq	.+2      	; 0x45d0 <main+0x17cc>
    45ce:	c1 c1       	rjmp	.+898    	; 0x4952 <main+0x1b4e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1627
      // ----------------------------------------
      // VIRTUAL I/O READ OPERATIONS ENGINE
      // ----------------------------------------

    {
      ioAddress = digitalRead(AD0);             // Read Z80 address bus line AD0 (PC2)
    45d0:	82 e1       	ldi	r24, 0x12	; 18
    45d2:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1628
      ioData = 0;                               // Clear input data buffer
    45d6:	10 92 fa 01 	sts	0x01FA, r1	; 0x8001fa <ioData>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1629
      if (ioAddress)                            // Check the I/O address (only AD0 is checked!)
    45da:	88 23       	and	r24, r24
    45dc:	09 f4       	brne	.+2      	; 0x45e0 <main+0x17dc>
    45de:	79 c0       	rjmp	.+242    	; 0x46d2 <main+0x18ce>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1662
          Serial.println(irqStatus);
        }
        // DEBUG END ------------------------------
        //

        ioData = 0xFF;
    45e0:	d0 92 fa 01 	sts	0x01FA, r13	; 0x8001fa <ioData>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1663
        if (Serial.available() > 0)
    45e4:	86 ea       	ldi	r24, 0xA6	; 166
    45e6:	92 e0       	ldi	r25, 0x02	; 2
    45e8:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
    45ec:	18 16       	cp	r1, r24
    45ee:	19 06       	cpc	r1, r25
    45f0:	0c f0       	brlt	.+2      	; 0x45f4 <main+0x17f0>
    45f2:	6b c0       	rjmp	.+214    	; 0x46ca <main+0x18c6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1665
        {
          ioData = Serial.read();
    45f4:	86 ea       	ldi	r24, 0xA6	; 166
    45f6:	92 e0       	ldi	r25, 0x02	; 2
    45f8:	0e 94 1d 05 	call	0xa3a	; 0xa3a <HardwareSerial::read()>
    45fc:	80 93 fa 01 	sts	0x01FA, r24	; 0x8001fa <ioData>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1666
          LastRxIsEmpty = 0;                    // Reset the "Last Rx char was empty" flag
    4600:	10 92 d9 01 	sts	0x01D9, r1	; 0x8001d9 <LastRxIsEmpty>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1669
        }
        else LastRxIsEmpty = 1;                 // Set the "Last Rx char was empty" flag
        digitalWrite(INT_, HIGH);               // Reset the INT_ signal (if used)
    4604:	61 e0       	ldi	r22, 0x01	; 1
    4606:	81 e0       	ldi	r24, 0x01	; 1
    4608:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1670
        irqStatus = irqStatus & B11111110;      // Reset the serial Rx IRQ status bit (see SYSIRQ Opcode)
    460c:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <irqStatus>
    4610:	8e 7f       	andi	r24, 0xFE	; 254
    4612:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <irqStatus>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1671
        RxDoneFlag = 1;
    4616:	81 e0       	ldi	r24, 0x01	; 1
    4618:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <RxDoneFlag>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2026
            break;
        }
        if ((ioOpcode != 0x84) && (ioOpcode != 0x86)) ioOpcode = 0xFF;  // All done for the single byte Opcodes.
        //  Set ioOpcode = "No operation"
      }
      DDRA = 0xFF;                              // Configure Z80 data bus D0-D7 (PA0-PA7) as output
    461c:	ff ef       	ldi	r31, 0xFF	; 255
    461e:	fa bb       	out	0x1a, r31	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2027
      PORTA = ioData;                           // Current output on data bus
    4620:	80 91 fa 01 	lds	r24, 0x01FA	; 0x8001fa <ioData>
    4624:	8b bb       	out	0x1b, r24	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2030

      // Control bus sequence to exit from a wait state (M I/O read cycle)
      digitalWrite(BUSREQ_, LOW);               // Request for a DMA
    4626:	60 e0       	ldi	r22, 0x00	; 0
    4628:	8e e0       	ldi	r24, 0x0E	; 14
    462a:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2031
      digitalWrite(WAIT_RES_, LOW);             // Now is safe reset WAIT FF (exiting from WAIT state)
    462e:	60 e0       	ldi	r22, 0x00	; 0
    4630:	80 e0       	ldi	r24, 0x00	; 0
    4632:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2032
      delayMicroseconds(2);                     // Wait 2us just to be sure that Z80 read the data and go HiZ
    4636:	82 e0       	ldi	r24, 0x02	; 2
    4638:	90 e0       	ldi	r25, 0x00	; 0
    463a:	0e 94 d6 06 	call	0xdac	; 0xdac <delayMicroseconds>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2033
      DDRA = 0x00;                              // Configure Z80 data bus D0-D7 (PA0-PA7) as input with pull-up
    463e:	1a ba       	out	0x1a, r1	; 26
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2034
      PORTA = 0xFF;
    4640:	2f ef       	ldi	r18, 0xFF	; 255
    4642:	2b bb       	out	0x1b, r18	; 27
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2063
      //

      // Control bus sequence to exit from a wait state (M interrupt cycle)
      digitalWrite(BUSREQ_, LOW);               // Request for a DMA
      digitalWrite(WAIT_RES_, LOW);             // Reset WAIT FF exiting from WAIT state
      digitalWrite(WAIT_RES_, HIGH);            // Now Z80 is in DMA, so it's safe set WAIT_RES_ HIGH again
    4644:	61 e0       	ldi	r22, 0x01	; 1
    4646:	80 e0       	ldi	r24, 0x00	; 0
    4648:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2064
      digitalWrite(BUSREQ_, HIGH);              // Resume Z80 from DMA
    464c:	61 e0       	ldi	r22, 0x01	; 1
    464e:	8e e0       	ldi	r24, 0x0E	; 14
    4650:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2068
    }
  }

  if (Z80IntSysTick)
    4654:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <Z80IntSysTick>
    4658:	88 23       	and	r24, r24
    465a:	79 f1       	breq	.+94     	; 0x46ba <main+0x18b6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2071
    // Systick interrupt generation is enabled. Check if the INT_ signal must be activated
  {
    if ((micros() - timeStamp) > ((long unsigned) (sysTickTime) * 1000))
    465c:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <micros>
    4660:	00 91 d1 01 	lds	r16, 0x01D1	; 0x8001d1 <timeStamp>
    4664:	10 91 d2 01 	lds	r17, 0x01D2	; 0x8001d2 <timeStamp+0x1>
    4668:	20 91 d3 01 	lds	r18, 0x01D3	; 0x8001d3 <timeStamp+0x2>
    466c:	30 91 d4 01 	lds	r19, 0x01D4	; 0x8001d4 <timeStamp+0x3>
    4670:	4b 01       	movw	r8, r22
    4672:	5c 01       	movw	r10, r24
    4674:	80 1a       	sub	r8, r16
    4676:	91 0a       	sbc	r9, r17
    4678:	a2 0a       	sbc	r10, r18
    467a:	b3 0a       	sbc	r11, r19
    467c:	20 91 6c 00 	lds	r18, 0x006C	; 0x80006c <sysTickTime>
    4680:	30 e0       	ldi	r19, 0x00	; 0
    4682:	a8 ee       	ldi	r26, 0xE8	; 232
    4684:	b3 e0       	ldi	r27, 0x03	; 3
    4686:	0e 94 5f 25 	call	0x4abe	; 0x4abe <__umulhisi3>
    468a:	68 15       	cp	r22, r8
    468c:	79 05       	cpc	r23, r9
    468e:	8a 05       	cpc	r24, r10
    4690:	9b 05       	cpc	r25, r11
    4692:	98 f4       	brcc	.+38     	; 0x46ba <main+0x18b6>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2074
      // <sysTickTime> milliseconds are elapsed, so a Systick interrupt is required
    {
      digitalWrite(INT_, LOW);
    4694:	60 e0       	ldi	r22, 0x00	; 0
    4696:	81 e0       	ldi	r24, 0x01	; 1
    4698:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2075
      irqStatus = irqStatus | B00000010;          // Set the Systick IRQ status bit (see SYSIRQ Opcode)
    469c:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <irqStatus>
    46a0:	82 60       	ori	r24, 0x02	; 2
    46a2:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <irqStatus>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2076
      timeStamp = micros();
    46a6:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <micros>
    46aa:	60 93 d1 01 	sts	0x01D1, r22	; 0x8001d1 <timeStamp>
    46ae:	70 93 d2 01 	sts	0x01D2, r23	; 0x8001d2 <timeStamp+0x1>
    46b2:	80 93 d3 01 	sts	0x01D3, r24	; 0x8001d3 <timeStamp+0x2>
    46b6:	90 93 d4 01 	sts	0x01D4, r25	; 0x8001d4 <timeStamp+0x3>
serialEventRun():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.cpp:67
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    46ba:	0e 94 4b 05 	call	0xa96	; 0xa96 <Serial0_available()>
    46be:	88 23       	and	r24, r24
    46c0:	09 f4       	brne	.+2      	; 0x46c4 <main+0x18c0>
    46c2:	f2 cb       	rjmp	.-2076   	; 0x3ea8 <main+0x10a4>
    46c4:	0e 94 8f 10 	call	0x211e	; 0x211e <serialEvent()>
    46c8:	ef cb       	rjmp	.-2082   	; 0x3ea8 <main+0x10a4>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1668
        if (Serial.available() > 0)
        {
          ioData = Serial.read();
          LastRxIsEmpty = 0;                    // Reset the "Last Rx char was empty" flag
        }
        else LastRxIsEmpty = 1;                 // Set the "Last Rx char was empty" flag
    46ca:	81 e0       	ldi	r24, 0x01	; 1
    46cc:	80 93 d9 01 	sts	0x01D9, r24	; 0x8001d9 <LastRxIsEmpty>
    46d0:	99 cf       	rjmp	.-206    	; 0x4604 <main+0x1800>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1686
        // NOTE: For multi-byte read Opcode (as DATETIME) read sequentially all the data bytes without to send
        //       a STORE Opcode operation before each data byte after the first one.
        // .........................................................................................................
        //
      {
        switch (ioOpcode)
    46d2:	e0 91 79 00 	lds	r30, 0x0079	; 0x800079 <ioOpcode>
    46d6:	e0 58       	subi	r30, 0x80	; 128
    46d8:	eb 30       	cpi	r30, 0x0B	; 11
    46da:	58 f5       	brcc	.+86     	; 0x4732 <main+0x192e>
    46dc:	f0 e0       	ldi	r31, 0x00	; 0
    46de:	ed 58       	subi	r30, 0x8D	; 141
    46e0:	fc 4d       	sbci	r31, 0xDC	; 220
    46e2:	0c 94 9c 25 	jmp	0x4b38	; 0x4b38 <__tablejump2__>
    46e6:	7e 23       	and	r23, r30
    46e8:	a2 23       	and	r26, r18
    46ea:	bd 23       	and	r27, r29
    46ec:	c7 23       	and	r28, r23
    46ee:	ea 23       	and	r30, r26
    46f0:	26 24       	eor	r2, r6
    46f2:	29 24       	eor	r2, r9
    46f4:	7e 24       	eor	r7, r14
    46f6:	81 24       	eor	r8, r1
    46f8:	86 24       	eor	r8, r6
    46fa:	8d 24       	eor	r8, r13
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1696
            //                I/O DATA:    D7 D6 D5 D4 D3 D2 D1 D0
            //                            ---------------------------------------------------------
            //                              0  0  0  0  0  0  0  0    USER Key not pressed
            //                              0  0  0  0  0  0  0  1    USER Key pressed

            tempByte = digitalRead(USER);       // Save USER led status
    46fc:	8d e0       	ldi	r24, 0x0D	; 13
    46fe:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
    4702:	18 2f       	mov	r17, r24
    4704:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <tempByte>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1697
            pinMode(USER, INPUT_PULLUP);        // Read USER Key
    4708:	62 e0       	ldi	r22, 0x02	; 2
    470a:	8d e0       	ldi	r24, 0x0D	; 13
    470c:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1698
            ioData = !digitalRead(USER);
    4710:	8d e0       	ldi	r24, 0x0D	; 13
    4712:	0e 94 19 06 	call	0xc32	; 0xc32 <digitalRead>
    4716:	21 e0       	ldi	r18, 0x01	; 1
    4718:	89 2b       	or	r24, r25
    471a:	09 f0       	breq	.+2      	; 0x471e <main+0x191a>
    471c:	20 e0       	ldi	r18, 0x00	; 0
    471e:	20 93 fa 01 	sts	0x01FA, r18	; 0x8001fa <ioData>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1699
            pinMode(USER, OUTPUT);
    4722:	61 e0       	ldi	r22, 0x01	; 1
    4724:	8d e0       	ldi	r24, 0x0D	; 13
    4726:	0e 94 9a 06 	call	0xd34	; 0xd34 <pinMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1700
            digitalWrite(USER, tempByte);       // Restore USER led status
    472a:	61 2f       	mov	r22, r17
    472c:	8d e0       	ldi	r24, 0x0D	; 13
    472e:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2023
              ioData = Wire.read();
              ioData = (ioData & 0b11111000) | 0b00000001;      // Set D0 = 1, D1 = D2 = 0
            }
            break;
        }
        if ((ioOpcode != 0x84) && (ioOpcode != 0x86)) ioOpcode = 0xFF;  // All done for the single byte Opcodes.
    4732:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <ioOpcode>
    4736:	8d 7f       	andi	r24, 0xFD	; 253
    4738:	84 38       	cpi	r24, 0x84	; 132
    473a:	09 f4       	brne	.+2      	; 0x473e <main+0x193a>
    473c:	6f cf       	rjmp	.-290    	; 0x461c <main+0x1818>
    473e:	d0 92 79 00 	sts	0x0079, r13	; 0x800079 <ioOpcode>
    4742:	6c cf       	rjmp	.-296    	; 0x461c <main+0x1818>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1712
            //                            ---------------------------------------------------------
            //                             D7 D6 D5 D4 D3 D2 D1 D0    GPIOA value (see MCP23017 datasheet)
            //
            // NOTE: a value 0x00 is forced if the GPE Option is not present

            if (moduleGPIO)
    4744:	80 91 f7 01 	lds	r24, 0x01F7	; 0x8001f7 <moduleGPIO>
    4748:	88 23       	and	r24, r24
    474a:	99 f3       	breq	.-26     	; 0x4732 <main+0x192e>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    474c:	80 e2       	ldi	r24, 0x20	; 32
    474e:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1716
            {
              // Set MCP23017 pointer to GPIOA
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOA_REG);
    4752:	82 e1       	ldi	r24, 0x12	; 18
    4754:	90 e0       	ldi	r25, 0x00	; 0
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1738

            if (moduleGPIO)
            {
              // Set MCP23017 pointer to GPIOB
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOB_REG);
    4756:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1739
              Wire.endTransmission();
    475a:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    475e:	80 e2       	ldi	r24, 0x20	; 32
    4760:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1742
              // Read GPIOB
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.requestFrom(GPIOEXP_ADDR, 1);
    4764:	61 e0       	ldi	r22, 0x01	; 1
    4766:	70 e0       	ldi	r23, 0x00	; 0
    4768:	80 e2       	ldi	r24, 0x20	; 32
    476a:	90 e0       	ldi	r25, 0x00	; 0
    476c:	0e 94 b0 10 	call	0x2160	; 0x2160 <TwoWire::requestFrom(int, int) [clone .constprop.21]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1743
              ioData = Wire.read();
    4770:	0e 94 b7 04 	call	0x96e	; 0x96e <TwoWire::read() [clone .constprop.26]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2019

              // Read GPIOA (SPP Status Lines)
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.requestFrom(GPIOEXP_ADDR, 1);
              ioData = Wire.read();
              ioData = (ioData & 0b11111000) | 0b00000001;      // Set D0 = 1, D1 = D2 = 0
    4774:	80 93 fa 01 	sts	0x01FA, r24	; 0x8001fa <ioData>
    4778:	dc cf       	rjmp	.-72     	; 0x4732 <main+0x192e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1734
            //                            ---------------------------------------------------------
            //                             D7 D6 D5 D4 D3 D2 D1 D0    GPIOB value (see MCP23017 datasheet)
            //
            // NOTE: a value 0x00 is forced if the GPE Option is not present

            if (moduleGPIO)
    477a:	80 91 f7 01 	lds	r24, 0x01F7	; 0x8001f7 <moduleGPIO>
    477e:	88 23       	and	r24, r24
    4780:	c1 f2       	breq	.-80     	; 0x4732 <main+0x192e>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    4782:	80 e2       	ldi	r24, 0x20	; 32
    4784:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1738
            {
              // Set MCP23017 pointer to GPIOB
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOB_REG);
    4788:	83 e1       	ldi	r24, 0x13	; 19
    478a:	90 e0       	ldi	r25, 0x00	; 0
    478c:	e4 cf       	rjmp	.-56     	; 0x4756 <main+0x1952>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1765
            //                              X  X  X  1  X  X  X  X    CP/M warm boot message enabled
            //
            // NOTE 1: Currently only D0-D4 are used
            // NOTE 2: The D4 flag is set/reset using the D0 bit of the SETOPT Opcode (see SETOPT for more info)

            ioData = autoexecFlag | (foundRTC << 1) | ((Serial.available() > 0) << 2) | ((LastRxIsEmpty > 0) << 3)
    478e:	00 91 d7 01 	lds	r16, 0x01D7	; 0x8001d7 <foundRTC>
    4792:	10 e0       	ldi	r17, 0x00	; 0
    4794:	00 0f       	add	r16, r16
    4796:	11 1f       	adc	r17, r17
    4798:	f0 90 d6 01 	lds	r15, 0x01D6	; 0x8001d6 <autoexecFlag>
    479c:	86 ea       	ldi	r24, 0xA6	; 166
    479e:	92 e0       	ldi	r25, 0x02	; 2
    47a0:	0e 94 3f 05 	call	0xa7e	; 0xa7e <HardwareSerial::available()>
main():
    47a4:	34 e0       	ldi	r19, 0x04	; 4
loop():
    47a6:	18 16       	cp	r1, r24
    47a8:	19 06       	cpc	r1, r25
    47aa:	0c f0       	brlt	.+2      	; 0x47ae <main+0x19aa>
main():
    47ac:	30 e0       	ldi	r19, 0x00	; 0
loop():
    47ae:	80 91 d9 01 	lds	r24, 0x01D9	; 0x8001d9 <LastRxIsEmpty>
main():
    47b2:	28 e0       	ldi	r18, 0x08	; 8
loop():
    47b4:	81 11       	cpse	r24, r1
    47b6:	01 c0       	rjmp	.+2      	; 0x47ba <main+0x19b6>
main():
    47b8:	20 e0       	ldi	r18, 0x00	; 0
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1766
                     | (cpmWarmBootFlg << 4);
    47ba:	80 91 ee 01 	lds	r24, 0x01EE	; 0x8001ee <cpmWarmBootFlg>
    47be:	50 e1       	ldi	r21, 0x10	; 16
    47c0:	85 9f       	mul	r24, r21
    47c2:	c0 01       	movw	r24, r0
    47c4:	11 24       	eor	r1, r1
    47c6:	08 2b       	or	r16, r24
    47c8:	0f 29       	or	r16, r15
    47ca:	03 2b       	or	r16, r19
    47cc:	02 2b       	or	r16, r18
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1765
            //                              X  X  X  1  X  X  X  X    CP/M warm boot message enabled
            //
            // NOTE 1: Currently only D0-D4 are used
            // NOTE 2: The D4 flag is set/reset using the D0 bit of the SETOPT Opcode (see SETOPT for more info)

            ioData = autoexecFlag | (foundRTC << 1) | ((Serial.available() > 0) << 2) | ((LastRxIsEmpty > 0) << 3)
    47ce:	00 93 fa 01 	sts	0x01FA, r16	; 0x8001fa <ioData>
    47d2:	af cf       	rjmp	.-162    	; 0x4732 <main+0x192e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1785
            //
            // NOTE 1: If RTC is not found all read values wil be = 0
            // NOTE 2: Overread data (more then 7 bytes read) will be = 0
            // NOTE 3: The temperature (Celsius) is a byte with two complement binary format [-128..127]

            if (foundRTC)
    47d4:	80 91 d7 01 	lds	r24, 0x01D7	; 0x8001d7 <foundRTC>
    47d8:	88 23       	and	r24, r24
    47da:	a9 f1       	breq	.+106    	; 0x4846 <main+0x1a42>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1787
            {
              if (ioByteCnt == 0) readRTC(&seconds, &minutes, &hours, &day, &month, &year, &tempC); // Read from RTC
    47dc:	00 91 f8 01 	lds	r16, 0x01F8	; 0x8001f8 <ioByteCnt>
    47e0:	10 91 f9 01 	lds	r17, 0x01F9	; 0x8001f9 <ioByteCnt+0x1>
    47e4:	01 15       	cp	r16, r1
    47e6:	11 05       	cpc	r17, r1
    47e8:	69 f4       	brne	.+26     	; 0x4804 <main+0x1a00>
    47ea:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <readRTC(unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*, unsigned char*) [clone .constprop.20]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1793
              if (ioByteCnt < 7)
                // Send date/time (binary values) to Z80 bus
              {
                switch (ioByteCnt)
                {
                  case 0: ioData = seconds; break;
    47ee:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <seconds>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1799
                  case 1: ioData = minutes; break;
                  case 2: ioData = hours; break;
                  case 3: ioData = day; break;
                  case 4: ioData = month; break;
                  case 5: ioData = year; break;
                  case 6: ioData = tempC; break;
    47f2:	80 93 fa 01 	sts	0x01FA, r24	; 0x8001fa <ioData>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1903
            }
            if (ioByteCnt >= 511)
            {
              ioOpcode = 0xFF;                  // All done. Set ioOpcode = "No operation"
            }
            ioByteCnt++;                        // Increment the counter of the exchanged data bytes
    47f6:	0f 5f       	subi	r16, 0xFF	; 255
    47f8:	1f 4f       	sbci	r17, 0xFF	; 255
    47fa:	10 93 f9 01 	sts	0x01F9, r17	; 0x8001f9 <ioByteCnt+0x1>
    47fe:	00 93 f8 01 	sts	0x01F8, r16	; 0x8001f8 <ioByteCnt>
    4802:	97 cf       	rjmp	.-210    	; 0x4732 <main+0x192e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1788
            // NOTE 3: The temperature (Celsius) is a byte with two complement binary format [-128..127]

            if (foundRTC)
            {
              if (ioByteCnt == 0) readRTC(&seconds, &minutes, &hours, &day, &month, &year, &tempC); // Read from RTC
              if (ioByteCnt < 7)
    4804:	07 30       	cpi	r16, 0x07	; 7
    4806:	11 05       	cpc	r17, r1
    4808:	f0 f4       	brcc	.+60     	; 0x4846 <main+0x1a42>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1797
                {
                  case 0: ioData = seconds; break;
                  case 1: ioData = minutes; break;
                  case 2: ioData = hours; break;
                  case 3: ioData = day; break;
                  case 4: ioData = month; break;
    480a:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <month>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1791
            {
              if (ioByteCnt == 0) readRTC(&seconds, &minutes, &hours, &day, &month, &year, &tempC); // Read from RTC
              if (ioByteCnt < 7)
                // Send date/time (binary values) to Z80 bus
              {
                switch (ioByteCnt)
    480e:	04 30       	cpi	r16, 0x04	; 4
    4810:	11 05       	cpc	r17, r1
    4812:	79 f3       	breq	.-34     	; 0x47f2 <main+0x19ee>
    4814:	68 f4       	brcc	.+26     	; 0x4830 <main+0x1a2c>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1795
                {
                  case 0: ioData = seconds; break;
                  case 1: ioData = minutes; break;
                  case 2: ioData = hours; break;
    4816:	80 91 25 02 	lds	r24, 0x0225	; 0x800225 <hours>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1791
            {
              if (ioByteCnt == 0) readRTC(&seconds, &minutes, &hours, &day, &month, &year, &tempC); // Read from RTC
              if (ioByteCnt < 7)
                // Send date/time (binary values) to Z80 bus
              {
                switch (ioByteCnt)
    481a:	02 30       	cpi	r16, 0x02	; 2
    481c:	11 05       	cpc	r17, r1
    481e:	49 f3       	breq	.-46     	; 0x47f2 <main+0x19ee>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1796
                {
                  case 0: ioData = seconds; break;
                  case 1: ioData = minutes; break;
                  case 2: ioData = hours; break;
                  case 3: ioData = day; break;
    4820:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <day>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1791
            {
              if (ioByteCnt == 0) readRTC(&seconds, &minutes, &hours, &day, &month, &year, &tempC); // Read from RTC
              if (ioByteCnt < 7)
                // Send date/time (binary values) to Z80 bus
              {
                switch (ioByteCnt)
    4824:	03 30       	cpi	r16, 0x03	; 3
    4826:	11 05       	cpc	r17, r1
    4828:	21 f3       	breq	.-56     	; 0x47f2 <main+0x19ee>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1794
                {
                  case 0: ioData = seconds; break;
                  case 1: ioData = minutes; break;
    482a:	80 91 26 02 	lds	r24, 0x0226	; 0x800226 <minutes>
    482e:	e1 cf       	rjmp	.-62     	; 0x47f2 <main+0x19ee>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1798
                  case 2: ioData = hours; break;
                  case 3: ioData = day; break;
                  case 4: ioData = month; break;
                  case 5: ioData = year; break;
    4830:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <year>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1791
            {
              if (ioByteCnt == 0) readRTC(&seconds, &minutes, &hours, &day, &month, &year, &tempC); // Read from RTC
              if (ioByteCnt < 7)
                // Send date/time (binary values) to Z80 bus
              {
                switch (ioByteCnt)
    4834:	05 30       	cpi	r16, 0x05	; 5
    4836:	11 05       	cpc	r17, r1
    4838:	e1 f2       	breq	.-72     	; 0x47f2 <main+0x19ee>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1799
                  case 1: ioData = minutes; break;
                  case 2: ioData = hours; break;
                  case 3: ioData = day; break;
                  case 4: ioData = month; break;
                  case 5: ioData = year; break;
                  case 6: ioData = tempC; break;
    483a:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <tempC>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1791
            {
              if (ioByteCnt == 0) readRTC(&seconds, &minutes, &hours, &day, &month, &year, &tempC); // Read from RTC
              if (ioByteCnt < 7)
                // Send date/time (binary values) to Z80 bus
              {
                switch (ioByteCnt)
    483e:	06 30       	cpi	r16, 0x06	; 6
    4840:	11 05       	cpc	r17, r1
    4842:	b9 f2       	breq	.-82     	; 0x47f2 <main+0x19ee>
    4844:	f2 cf       	rjmp	.-28     	; 0x482a <main+0x1a26>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1803
                  case 5: ioData = year; break;
                  case 6: ioData = tempC; break;
                }
                ioByteCnt++;
              }
              else ioOpcode = 0xFF;            // All done. Set ioOpcode = "No operation"
    4846:	d0 92 79 00 	sts	0x0079, r13	; 0x800079 <ioOpcode>
    484a:	73 cf       	rjmp	.-282    	; 0x4732 <main+0x192e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1845
            //         operation
            // NOTE 2: Error codes from 0 to 6 come from the PetitFS library implementation
            // NOTE 3: ERRDISK must not be used to read the resulting error code after a SDMOUNT operation
            //         (see the SDMOUNT Opcode)

            ioData = diskErr;
    484c:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <diskErr>
    4850:	91 cf       	rjmp	.-222    	; 0x4774 <main+0x1970>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1876
            // Errors are stored into "diskErr" (see ERRDISK Opcode).
            //
            // NOTE 1: Before a READSECT operation at least a SELTRACK or a SELSECT must be always performed
            // NOTE 2: Remember to open the right "disk file" at first using the SELDISK Opcode

            if (!ioByteCnt)
    4852:	00 91 f8 01 	lds	r16, 0x01F8	; 0x8001f8 <ioByteCnt>
    4856:	10 91 f9 01 	lds	r17, 0x01F9	; 0x8001f9 <ioByteCnt+0x1>
    485a:	01 15       	cp	r16, r1
    485c:	11 05       	cpc	r17, r1
    485e:	19 f5       	brne	.+70     	; 0x48a6 <main+0x1aa2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1879
              // First byte of 512, so set the right file pointer to the current emulated track/sector first
            {
              if ((trackSel < 512) && (sectSel < 32) && (!diskErr))
    4860:	60 91 f4 01 	lds	r22, 0x01F4	; 0x8001f4 <trackSel>
    4864:	70 91 f5 01 	lds	r23, 0x01F5	; 0x8001f5 <trackSel+0x1>
    4868:	61 15       	cp	r22, r1
    486a:	82 e0       	ldi	r24, 0x02	; 2
    486c:	78 07       	cpc	r23, r24
    486e:	d8 f4       	brcc	.+54     	; 0x48a6 <main+0x1aa2>
    4870:	80 91 f3 01 	lds	r24, 0x01F3	; 0x8001f3 <sectSel>
    4874:	80 32       	cpi	r24, 0x20	; 32
    4876:	b8 f4       	brcc	.+46     	; 0x48a6 <main+0x1aa2>
    4878:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <diskErr>
    487c:	91 11       	cpse	r25, r1
    487e:	13 c0       	rjmp	.+38     	; 0x48a6 <main+0x1aa2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1882
                // Sector and track numbers valid and no previous error; set the LBA-like logical sector
              {
                diskErr = seekSD((trackSel << 5) | sectSel);  // Set the starting point inside the "disk file"
    4880:	95 e0       	ldi	r25, 0x05	; 5
    4882:	66 0f       	add	r22, r22
    4884:	77 1f       	adc	r23, r23
    4886:	9a 95       	dec	r25
    4888:	e1 f7       	brne	.-8      	; 0x4882 <main+0x1a7e>
    488a:	68 2b       	or	r22, r24
seekSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2726
// NOTE: "secNum" is in the range [0..16383], and the sector addressing is continuos inside a "disk file";
//       16383 = (512 * 32) - 1, where 512 is the number of emulated tracks, 32 is the number of emulated sectors
//
{
  byte i;
  return pf_lseek(((unsigned long) sectNum) << 9);
    488c:	90 e0       	ldi	r25, 0x00	; 0
    488e:	80 e0       	ldi	r24, 0x00	; 0
    4890:	29 e0       	ldi	r18, 0x09	; 9
    4892:	66 0f       	add	r22, r22
    4894:	77 1f       	adc	r23, r23
    4896:	88 1f       	adc	r24, r24
    4898:	99 1f       	adc	r25, r25
    489a:	2a 95       	dec	r18
    489c:	d1 f7       	brne	.-12     	; 0x4892 <main+0x1a8e>
    489e:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <pf_lseek>
    48a2:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <diskErr>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1887
                diskErr = seekSD((trackSel << 5) | sectSel);  // Set the starting point inside the "disk file"
                //  generating a 14 bit "disk file" LBA-like
                //  logical sector address created as TTTTTTTTTSSSSS
              }
            }
            if (!diskErr)
    48a6:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <diskErr>
    48aa:	81 11       	cpse	r24, r1
    48ac:	1d c0       	rjmp	.+58     	; 0x48e8 <main+0x1ae4>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1890
              // No previous error (e.g. selecting disk, track or sector)
            {
              tempByte = ioByteCnt % 32;        // [0..31]
    48ae:	90 2f       	mov	r25, r16
    48b0:	9f 71       	andi	r25, 0x1F	; 31
    48b2:	f9 2e       	mov	r15, r25
    48b4:	90 93 f2 01 	sts	0x01F2, r25	; 0x8001f2 <tempByte>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1891
              if (!tempByte)
    48b8:	91 11       	cpse	r25, r1
    48ba:	0f c0       	rjmp	.+30     	; 0x48da <main+0x1ad6>
readSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2678
// NOTE2: Past current sector boundary, the next sector will be pointed. So to read a whole file it is sufficient
//        call readSD() consecutively until EOF is reached
{
  UINT  numBytes;
  byte  errcode;
  errcode = pf_read(buffSD, 32, &numBytes);
    48bc:	ce 01       	movw	r24, r28
    48be:	01 96       	adiw	r24, 0x01	; 1
    48c0:	0e 94 9c 0c 	call	0x1938	; 0x1938 <pf_read.constprop.36>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2679
  *numReadBytes = (byte) numBytes;
    48c4:	99 81       	ldd	r25, Y+1	; 0x01
    48c6:	90 93 d5 01 	sts	0x01D5, r25	; 0x8001d5 <numReadBytes>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1895
              tempByte = ioByteCnt % 32;        // [0..31]
              if (!tempByte)
                // Read 32 bytes of the current sector on SD in the buffer (every 32 calls, starting with the first)
              {
                diskErr = readSD(bufferSD, &numReadBytes);
                if (numReadBytes < 32) diskErr = 19;    // Reached an unexpected EOF
    48ca:	90 32       	cpi	r25, 0x20	; 32
    48cc:	a8 f0       	brcs	.+42     	; 0x48f8 <main+0x1af4>
    48ce:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <diskErr>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1897
              }
              if (!diskErr) ioData = bufferSD[tempByte];// If no errors, exchange current data byte with the CPU
    48d2:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <diskErr>
    48d6:	81 11       	cpse	r24, r1
    48d8:	07 c0       	rjmp	.+14     	; 0x48e8 <main+0x1ae4>
    48da:	ef 2d       	mov	r30, r15
    48dc:	f0 e0       	ldi	r31, 0x00	; 0
    48de:	e7 5a       	subi	r30, 0xA7	; 167
    48e0:	fd 4f       	sbci	r31, 0xFD	; 253
    48e2:	80 81       	ld	r24, Z
    48e4:	80 93 fa 01 	sts	0x01FA, r24	; 0x8001fa <ioData>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1899
            }
            if (ioByteCnt >= 511)
    48e8:	0f 3f       	cpi	r16, 0xFF	; 255
    48ea:	e1 e0       	ldi	r30, 0x01	; 1
    48ec:	1e 07       	cpc	r17, r30
    48ee:	08 f4       	brcc	.+2      	; 0x48f2 <main+0x1aee>
    48f0:	82 cf       	rjmp	.-252    	; 0x47f6 <main+0x19f2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1901
            {
              ioOpcode = 0xFF;                  // All done. Set ioOpcode = "No operation"
    48f2:	d0 92 79 00 	sts	0x0079, r13	; 0x800079 <ioOpcode>
    48f6:	7f cf       	rjmp	.-258    	; 0x47f6 <main+0x19f2>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1895
              tempByte = ioByteCnt % 32;        // [0..31]
              if (!tempByte)
                // Read 32 bytes of the current sector on SD in the buffer (every 32 calls, starting with the first)
              {
                diskErr = readSD(bufferSD, &numReadBytes);
                if (numReadBytes < 32) diskErr = 19;    // Reached an unexpected EOF
    48f8:	83 e1       	ldi	r24, 0x13	; 19
    48fa:	e9 cf       	rjmp	.-46     	; 0x48ce <main+0x1aca>
mountSD():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2648
byte mountSD(FATFS* fatFs)
// Mount a volume on SD:
// *  "fatFs" is a pointer to a FATFS object (PetitFS library)
// The returned value is the resulting status (0 = ok, otherwise see printErrSD())
{
  return pf_mount(fatFs);
    48fc:	0e 94 4e 0a 	call	0x149c	; 0x149c <pf_mount.constprop.41>
    4900:	39 cf       	rjmp	.-398    	; 0x4774 <main+0x1970>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1935
            //                             D7 D6 D5 D4 D3 D2 D1 D0    free space in bytes (binary)
            //
            // NOTE: This Opcode is intended to avoid delays in serial Tx operations, as the IOS holds the Z80
            //       in a wait status if the TX buffer is full. This is no good in multitasking enviroments.

            ioData = Serial.availableForWrite() ;
    4902:	86 ea       	ldi	r24, 0xA6	; 166
    4904:	92 e0       	ldi	r25, 0x02	; 2
    4906:	0e 94 0e 05 	call	0xa1c	; 0xa1c <HardwareSerial::availableForWrite()>
    490a:	34 cf       	rjmp	.-408    	; 0x4774 <main+0x1970>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1966
            // NOTE 1: Only D0 and D1 "interrupt status bit" are currently used.
            // NOTE 2: After the SYSIRQ call all the "interrupt status bits" are cleared.
            // NOTE 3: If more than one IRQ trigger is enabled, you have to call SYSIRQ always from inside the
            //         ISR (on the Z80 side) to know the triggered IRQs.

            ioData = irqStatus;
    490c:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <irqStatus>
    4910:	80 93 fa 01 	sts	0x01FA, r24	; 0x8001fa <ioData>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:1967
            irqStatus = 0;                      // Reset all the "interrupt status bits"
    4914:	10 92 d8 01 	sts	0x01D8, r1	; 0x8001d8 <irqStatus>
    4918:	0c cf       	rjmp	.-488    	; 0x4732 <main+0x192e>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2008
            // If the SPP mode is enabled read the SPP Status Lines.
            // If the SPP mode is disabled (or the GPE is not installed) a byte of all 0s will be retrivied.
            //
            // NOTE: to use GETSPP the SETSPP Opcode should be called first to activate the SPP mode of the GPIO port.

            if (SPPmode)
    491a:	80 91 ed 01 	lds	r24, 0x01ED	; 0x8001ed <SPPmode>
    491e:	88 23       	and	r24, r24
    4920:	09 f4       	brne	.+2      	; 0x4924 <main+0x1b20>
    4922:	07 cf       	rjmp	.-498    	; 0x4732 <main+0x192e>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    4924:	80 e2       	ldi	r24, 0x20	; 32
    4926:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2012
            {
              // Set MCP23017 pointer to GPIOA
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.write(GPIOA_REG);
    492a:	82 e1       	ldi	r24, 0x12	; 18
    492c:	90 e0       	ldi	r25, 0x00	; 0
    492e:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <TwoWire::write(int) [clone .constprop.44]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2013
              Wire.endTransmission();
    4932:	0e 94 45 04 	call	0x88a	; 0x88a <TwoWire::endTransmission() [clone .constprop.30]>
beginTransmission():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\libraries\Wire\src/Wire.cpp:206
    4936:	80 e2       	ldi	r24, 0x20	; 32
    4938:	0e 94 9a 04 	call	0x934	; 0x934 <TwoWire::beginTransmission(unsigned char) [clone .constprop.29]>
loop():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2017

              // Read GPIOA (SPP Status Lines)
              Wire.beginTransmission(GPIOEXP_ADDR);
              Wire.requestFrom(GPIOEXP_ADDR, 1);
    493c:	61 e0       	ldi	r22, 0x01	; 1
    493e:	70 e0       	ldi	r23, 0x00	; 0
    4940:	80 e2       	ldi	r24, 0x20	; 32
    4942:	90 e0       	ldi	r25, 0x00	; 0
    4944:	0e 94 b0 10 	call	0x2160	; 0x2160 <TwoWire::requestFrom(int, int) [clone .constprop.21]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2018
              ioData = Wire.read();
    4948:	0e 94 b7 04 	call	0x96e	; 0x96e <TwoWire::read() [clone .constprop.26]>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2019
              ioData = (ioData & 0b11111000) | 0b00000001;      // Set D0 = 1, D1 = D2 = 0
    494c:	88 7f       	andi	r24, 0xF8	; 248
    494e:	81 60       	ori	r24, 0x01	; 1
    4950:	11 cf       	rjmp	.-478    	; 0x4774 <main+0x1970>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:2046
      // ----------------------------------------
      // VIRTUAL INTERRUPT
      // ----------------------------------------

    {
      digitalWrite(INT_, HIGH);                 // Reset the INT_ signal
    4952:	61 e0       	ldi	r22, 0x01	; 1
    4954:	81 e0       	ldi	r24, 0x01	; 1
    4956:	0e 94 42 06 	call	0xc84	; 0xc84 <digitalWrite>
    495a:	c0 ca       	rjmp	.-2688   	; 0x3edc <main+0x10d8>
setup():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:625
        ChangeRTC();                              // Change RTC Date/Time if requested
        break;
    };

    // Save selectd boot program if changed
    bootMode = inChar - '1';                      // Calculate bootMode from inChar
    495c:	8c ed       	ldi	r24, 0xDC	; 220
    495e:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <bootMode>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:627
    if (bootMode <= maxBootMode) EEPROM.update(bootModeAddr, bootMode); // Save to the internal EEPROM if required
    else bootMode = EEPROM.read(bootModeAddr);    // Reload boot mode if '0' or > '5' choice selected
    4962:	8a e0       	ldi	r24, 0x0A	; 10
    4964:	90 e0       	ldi	r25, 0x00	; 0
    4966:	0e 94 cb 13 	call	0x2796	; 0x2796 <EEPROMClass::read(int) [clone .isra.1]>
    496a:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <bootMode>
    496e:	0c 94 27 1b 	jmp	0x364e	; 0x364e <main+0x84a>
    4972:	10 91 f2 01 	lds	r17, 0x01F2	; 0x8001f2 <tempByte>
    4976:	0c 94 f3 1c 	jmp	0x39e6	; 0x39e6 <main+0xbe2>
write():
C:\Users\anthony\AppData\Local\Arduino15\packages\MightyCore\hardware\avr\3.0.3\cores\MCUdude_corefiles/HardwareSerial.h:133
    497a:	6d e0       	ldi	r22, 0x0D	; 13
    497c:	86 ea       	ldi	r24, 0xA6	; 166
    497e:	92 e0       	ldi	r25, 0x02	; 2
    4980:	0e 94 76 05 	call	0xaec	; 0xaec <HardwareSerial::write(unsigned char)>
    4984:	0c 94 9e 1b 	jmp	0x373c	; 0x373c <main+0x938>

00004988 <_GLOBAL__sub_D_lcd>:
__static_initialization_and_destruction_0():
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:232
const byte    LD_HL        =  0x36;       // Z80 instruction: LD(HL), n
const byte    INC_HL       =  0x23;       // Z80 instruction: INC HL
const byte    LD_HLnn      =  0x21;       // Z80 instruction: LD HL, nn
const byte    JP_nn        =  0xC3;       // Z80 instruction: JP nn
const String  compTimeStr  = __TIME__;    // Compile timestamp string
const String  compDateStr  = __DATE__;    // Compile datestamp string
    4988:	8f e4       	ldi	r24, 0x4F	; 79
    498a:	93 e0       	ldi	r25, 0x03	; 3
    498c:	0e 94 09 13 	call	0x2612	; 0x2612 <String::~String()>
F:\importf\Z80\S220718-R290823_IOS-Z80-MBC2/S220718-R290823_IOS-Z80-MBC2.ino:231

const byte    LD_HL        =  0x36;       // Z80 instruction: LD(HL), n
const byte    INC_HL       =  0x23;       // Z80 instruction: INC HL
const byte    LD_HLnn      =  0x21;       // Z80 instruction: LD HL, nn
const byte    JP_nn        =  0xC3;       // Z80 instruction: JP nn
const String  compTimeStr  = __TIME__;    // Compile timestamp string
    4990:	85 e5       	ldi	r24, 0x55	; 85
    4992:	93 e0       	ldi	r25, 0x03	; 3
    4994:	0c 94 09 13 	jmp	0x2612	; 0x2612 <String::~String()>

00004998 <atol>:
atol():
    4998:	1f 93       	push	r17
    499a:	fc 01       	movw	r30, r24
    499c:	99 27       	eor	r25, r25
    499e:	88 27       	eor	r24, r24
    49a0:	bc 01       	movw	r22, r24
    49a2:	e8 94       	clt
    49a4:	11 91       	ld	r17, Z+
    49a6:	10 32       	cpi	r17, 0x20	; 32
    49a8:	e9 f3       	breq	.-6      	; 0x49a4 <atol+0xc>
    49aa:	19 30       	cpi	r17, 0x09	; 9
    49ac:	10 f0       	brcs	.+4      	; 0x49b2 <atol+0x1a>
    49ae:	1e 30       	cpi	r17, 0x0E	; 14
    49b0:	c8 f3       	brcs	.-14     	; 0x49a4 <atol+0xc>
    49b2:	1b 32       	cpi	r17, 0x2B	; 43
    49b4:	51 f0       	breq	.+20     	; 0x49ca <atol+0x32>
    49b6:	1d 32       	cpi	r17, 0x2D	; 45
    49b8:	49 f4       	brne	.+18     	; 0x49cc <atol+0x34>
    49ba:	68 94       	set
    49bc:	06 c0       	rjmp	.+12     	; 0x49ca <atol+0x32>
    49be:	0e 94 f3 24 	call	0x49e6	; 0x49e6 <__mulsi_const_10>
    49c2:	61 0f       	add	r22, r17
    49c4:	71 1d       	adc	r23, r1
    49c6:	81 1d       	adc	r24, r1
    49c8:	91 1d       	adc	r25, r1
    49ca:	11 91       	ld	r17, Z+
    49cc:	10 53       	subi	r17, 0x30	; 48
    49ce:	1a 30       	cpi	r17, 0x0A	; 10
    49d0:	b0 f3       	brcs	.-20     	; 0x49be <atol+0x26>
    49d2:	3e f4       	brtc	.+14     	; 0x49e2 <atol+0x4a>
    49d4:	90 95       	com	r25
    49d6:	80 95       	com	r24
    49d8:	70 95       	com	r23
    49da:	61 95       	neg	r22
    49dc:	7f 4f       	sbci	r23, 0xFF	; 255
    49de:	8f 4f       	sbci	r24, 0xFF	; 255
    49e0:	9f 4f       	sbci	r25, 0xFF	; 255
    49e2:	1f 91       	pop	r17
    49e4:	08 95       	ret

000049e6 <__mulsi_const_10>:
__mulsi_const_10():
    49e6:	59 2f       	mov	r21, r25
    49e8:	48 2f       	mov	r20, r24
    49ea:	37 2f       	mov	r19, r23
    49ec:	26 2f       	mov	r18, r22
    49ee:	66 0f       	add	r22, r22
    49f0:	77 1f       	adc	r23, r23
    49f2:	88 1f       	adc	r24, r24
    49f4:	99 1f       	adc	r25, r25
    49f6:	66 0f       	add	r22, r22
    49f8:	77 1f       	adc	r23, r23
    49fa:	88 1f       	adc	r24, r24
    49fc:	99 1f       	adc	r25, r25
    49fe:	62 0f       	add	r22, r18
    4a00:	73 1f       	adc	r23, r19
    4a02:	84 1f       	adc	r24, r20
    4a04:	95 1f       	adc	r25, r21
    4a06:	66 0f       	add	r22, r22
    4a08:	77 1f       	adc	r23, r23
    4a0a:	88 1f       	adc	r24, r24
    4a0c:	99 1f       	adc	r25, r25
    4a0e:	08 95       	ret

00004a10 <eeprom_read_byte>:
eeprom_read_byte():
    4a10:	e1 99       	sbic	0x1c, 1	; 28
    4a12:	fe cf       	rjmp	.-4      	; 0x4a10 <eeprom_read_byte>
    4a14:	9f bb       	out	0x1f, r25	; 31
    4a16:	8e bb       	out	0x1e, r24	; 30
    4a18:	e0 9a       	sbi	0x1c, 0	; 28
    4a1a:	99 27       	eor	r25, r25
    4a1c:	8d b3       	in	r24, 0x1d	; 29
    4a1e:	08 95       	ret

00004a20 <eeprom_write_byte>:
eeprom_write_byte():
    4a20:	26 2f       	mov	r18, r22

00004a22 <eeprom_write_r18>:
    4a22:	e1 99       	sbic	0x1c, 1	; 28
    4a24:	fe cf       	rjmp	.-4      	; 0x4a22 <eeprom_write_r18>
    4a26:	9f bb       	out	0x1f, r25	; 31
    4a28:	8e bb       	out	0x1e, r24	; 30
    4a2a:	2d bb       	out	0x1d, r18	; 29
    4a2c:	0f b6       	in	r0, 0x3f	; 63
    4a2e:	f8 94       	cli
    4a30:	e2 9a       	sbi	0x1c, 2	; 28
    4a32:	e1 9a       	sbi	0x1c, 1	; 28
    4a34:	0f be       	out	0x3f, r0	; 63
    4a36:	01 96       	adiw	r24, 0x01	; 1
    4a38:	08 95       	ret

00004a3a <__muluhisi3>:
__muluhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    4a3a:	0e 94 5f 25 	call	0x4abe	; 0x4abe <__umulhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    4a3e:	a5 9f       	mul	r26, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    4a40:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    4a42:	b4 9f       	mul	r27, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    4a44:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    4a46:	a4 9f       	mul	r26, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    4a48:	80 0d       	add	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    4a4a:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    4a4c:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    4a4e:	08 95       	ret

00004a50 <__prologue_saves__>:
__prologue_saves__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2169
    4a50:	2f 92       	push	r2
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2170
    4a52:	3f 92       	push	r3
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2171
    4a54:	4f 92       	push	r4
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2172
    4a56:	5f 92       	push	r5
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2173
    4a58:	6f 92       	push	r6
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2174
    4a5a:	7f 92       	push	r7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2175
    4a5c:	8f 92       	push	r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2176
    4a5e:	9f 92       	push	r9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2177
    4a60:	af 92       	push	r10
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2178
    4a62:	bf 92       	push	r11
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2179
    4a64:	cf 92       	push	r12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2180
    4a66:	df 92       	push	r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2181
    4a68:	ef 92       	push	r14
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2182
    4a6a:	ff 92       	push	r15
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2183
    4a6c:	0f 93       	push	r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2184
    4a6e:	1f 93       	push	r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2185
    4a70:	cf 93       	push	r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2186
    4a72:	df 93       	push	r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2200
    4a74:	cd b7       	in	r28, 0x3d	; 61
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2201
    4a76:	de b7       	in	r29, 0x3e	; 62
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2202
    4a78:	ca 1b       	sub	r28, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2203
    4a7a:	db 0b       	sbc	r29, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2204
    4a7c:	0f b6       	in	r0, 0x3f	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2205
    4a7e:	f8 94       	cli
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2206
    4a80:	de bf       	out	0x3e, r29	; 62
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2207
    4a82:	0f be       	out	0x3f, r0	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2208
    4a84:	cd bf       	out	0x3d, r28	; 61
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2211
    4a86:	09 94       	ijmp

00004a88 <__epilogue_restores__>:
__epilogue_restores__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2222
    4a88:	2a 88       	ldd	r2, Y+18	; 0x12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2223
    4a8a:	39 88       	ldd	r3, Y+17	; 0x11
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2224
    4a8c:	48 88       	ldd	r4, Y+16	; 0x10
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2225
    4a8e:	5f 84       	ldd	r5, Y+15	; 0x0f
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2226
    4a90:	6e 84       	ldd	r6, Y+14	; 0x0e
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2227
    4a92:	7d 84       	ldd	r7, Y+13	; 0x0d
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2228
    4a94:	8c 84       	ldd	r8, Y+12	; 0x0c
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2229
    4a96:	9b 84       	ldd	r9, Y+11	; 0x0b
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2230
    4a98:	aa 84       	ldd	r10, Y+10	; 0x0a
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2231
    4a9a:	b9 84       	ldd	r11, Y+9	; 0x09
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2232
    4a9c:	c8 84       	ldd	r12, Y+8	; 0x08
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2233
    4a9e:	df 80       	ldd	r13, Y+7	; 0x07
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2234
    4aa0:	ee 80       	ldd	r14, Y+6	; 0x06
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2235
    4aa2:	fd 80       	ldd	r15, Y+5	; 0x05
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2236
    4aa4:	0c 81       	ldd	r16, Y+4	; 0x04
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2237
    4aa6:	1b 81       	ldd	r17, Y+3	; 0x03
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2238
    4aa8:	aa 81       	ldd	r26, Y+2	; 0x02
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2252
    4aaa:	b9 81       	ldd	r27, Y+1	; 0x01
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2253
    4aac:	ce 0f       	add	r28, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2254
    4aae:	d1 1d       	adc	r29, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2255
    4ab0:	0f b6       	in	r0, 0x3f	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2256
    4ab2:	f8 94       	cli
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2257
    4ab4:	de bf       	out	0x3e, r29	; 62
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2258
    4ab6:	0f be       	out	0x3f, r0	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2259
    4ab8:	cd bf       	out	0x3d, r28	; 61
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2260
    4aba:	ed 01       	movw	r28, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2263
    4abc:	08 95       	ret

00004abe <__umulhisi3>:
__umulhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    4abe:	a2 9f       	mul	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    4ac0:	b0 01       	movw	r22, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    4ac2:	b3 9f       	mul	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    4ac4:	c0 01       	movw	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    4ac6:	a3 9f       	mul	r26, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    4ac8:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    4aca:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    4acc:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    4ace:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    4ad0:	b2 9f       	mul	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    4ad2:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    4ad4:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    4ad6:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    4ad8:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    4ada:	08 95       	ret

00004adc <__udivmodqi4>:
__udivmodqi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1346
    4adc:	99 1b       	sub	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1347
    4ade:	79 e0       	ldi	r23, 0x09	; 9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1348
    4ae0:	04 c0       	rjmp	.+8      	; 0x4aea <__udivmodqi4_ep>

00004ae2 <__udivmodqi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1350
    4ae2:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1351
    4ae4:	96 17       	cp	r25, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1352
    4ae6:	08 f0       	brcs	.+2      	; 0x4aea <__udivmodqi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1353
    4ae8:	96 1b       	sub	r25, r22

00004aea <__udivmodqi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1355
    4aea:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1356
    4aec:	7a 95       	dec	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1357
    4aee:	c9 f7       	brne	.-14     	; 0x4ae2 <__udivmodqi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1358
    4af0:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1360
    4af2:	08 95       	ret

00004af4 <__udivmodsi4>:
__udivmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    4af4:	a1 e2       	ldi	r26, 0x21	; 33
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    4af6:	1a 2e       	mov	r1, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    4af8:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    4afa:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    4afc:	fd 01       	movw	r30, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    4afe:	0d c0       	rjmp	.+26     	; 0x4b1a <__udivmodsi4_ep>

00004b00 <__udivmodsi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    4b00:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    4b02:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    4b04:	ee 1f       	adc	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    4b06:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    4b08:	a2 17       	cp	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    4b0a:	b3 07       	cpc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    4b0c:	e4 07       	cpc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    4b0e:	f5 07       	cpc	r31, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    4b10:	20 f0       	brcs	.+8      	; 0x4b1a <__udivmodsi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    4b12:	a2 1b       	sub	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    4b14:	b3 0b       	sbc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    4b16:	e4 0b       	sbc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    4b18:	f5 0b       	sbc	r31, r21

00004b1a <__udivmodsi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    4b1a:	66 1f       	adc	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    4b1c:	77 1f       	adc	r23, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    4b1e:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    4b20:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    4b22:	1a 94       	dec	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    4b24:	69 f7       	brne	.-38     	; 0x4b00 <__udivmodsi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    4b26:	60 95       	com	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    4b28:	70 95       	com	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    4b2a:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    4b2c:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    4b2e:	9b 01       	movw	r18, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    4b30:	ac 01       	movw	r20, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    4b32:	bd 01       	movw	r22, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    4b34:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    4b36:	08 95       	ret

00004b38 <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    4b38:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    4b3a:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    4b3c:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    4b3e:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    4b40:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    4b42:	09 94       	ijmp

00004b44 <malloc>:
malloc():
    4b44:	0f 93       	push	r16
    4b46:	1f 93       	push	r17
    4b48:	cf 93       	push	r28
    4b4a:	df 93       	push	r29
    4b4c:	82 30       	cpi	r24, 0x02	; 2
    4b4e:	91 05       	cpc	r25, r1
    4b50:	10 f4       	brcc	.+4      	; 0x4b56 <malloc+0x12>
    4b52:	82 e0       	ldi	r24, 0x02	; 2
    4b54:	90 e0       	ldi	r25, 0x00	; 0
    4b56:	e0 91 69 03 	lds	r30, 0x0369	; 0x800369 <__flp>
    4b5a:	f0 91 6a 03 	lds	r31, 0x036A	; 0x80036a <__flp+0x1>
    4b5e:	30 e0       	ldi	r19, 0x00	; 0
    4b60:	20 e0       	ldi	r18, 0x00	; 0
    4b62:	b0 e0       	ldi	r27, 0x00	; 0
    4b64:	a0 e0       	ldi	r26, 0x00	; 0
    4b66:	30 97       	sbiw	r30, 0x00	; 0
    4b68:	99 f4       	brne	.+38     	; 0x4b90 <malloc+0x4c>
    4b6a:	21 15       	cp	r18, r1
    4b6c:	31 05       	cpc	r19, r1
    4b6e:	09 f4       	brne	.+2      	; 0x4b72 <malloc+0x2e>
    4b70:	4a c0       	rjmp	.+148    	; 0x4c06 <malloc+0xc2>
    4b72:	28 1b       	sub	r18, r24
    4b74:	39 0b       	sbc	r19, r25
    4b76:	24 30       	cpi	r18, 0x04	; 4
    4b78:	31 05       	cpc	r19, r1
    4b7a:	d8 f5       	brcc	.+118    	; 0x4bf2 <malloc+0xae>
    4b7c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b7e:	9b 81       	ldd	r25, Y+3	; 0x03
    4b80:	61 15       	cp	r22, r1
    4b82:	71 05       	cpc	r23, r1
    4b84:	89 f1       	breq	.+98     	; 0x4be8 <malloc+0xa4>
    4b86:	fb 01       	movw	r30, r22
    4b88:	93 83       	std	Z+3, r25	; 0x03
    4b8a:	82 83       	std	Z+2, r24	; 0x02
    4b8c:	fe 01       	movw	r30, r28
    4b8e:	11 c0       	rjmp	.+34     	; 0x4bb2 <malloc+0x6e>
    4b90:	40 81       	ld	r20, Z
    4b92:	51 81       	ldd	r21, Z+1	; 0x01
    4b94:	02 81       	ldd	r16, Z+2	; 0x02
    4b96:	13 81       	ldd	r17, Z+3	; 0x03
    4b98:	48 17       	cp	r20, r24
    4b9a:	59 07       	cpc	r21, r25
    4b9c:	e0 f0       	brcs	.+56     	; 0x4bd6 <malloc+0x92>
    4b9e:	48 17       	cp	r20, r24
    4ba0:	59 07       	cpc	r21, r25
    4ba2:	99 f4       	brne	.+38     	; 0x4bca <malloc+0x86>
    4ba4:	10 97       	sbiw	r26, 0x00	; 0
    4ba6:	61 f0       	breq	.+24     	; 0x4bc0 <malloc+0x7c>
    4ba8:	12 96       	adiw	r26, 0x02	; 2
    4baa:	0c 93       	st	X, r16
    4bac:	12 97       	sbiw	r26, 0x02	; 2
    4bae:	13 96       	adiw	r26, 0x03	; 3
    4bb0:	1c 93       	st	X, r17
    4bb2:	32 96       	adiw	r30, 0x02	; 2
    4bb4:	cf 01       	movw	r24, r30
    4bb6:	df 91       	pop	r29
    4bb8:	cf 91       	pop	r28
    4bba:	1f 91       	pop	r17
    4bbc:	0f 91       	pop	r16
    4bbe:	08 95       	ret
    4bc0:	00 93 69 03 	sts	0x0369, r16	; 0x800369 <__flp>
    4bc4:	10 93 6a 03 	sts	0x036A, r17	; 0x80036a <__flp+0x1>
    4bc8:	f4 cf       	rjmp	.-24     	; 0x4bb2 <malloc+0x6e>
    4bca:	21 15       	cp	r18, r1
    4bcc:	31 05       	cpc	r19, r1
    4bce:	51 f0       	breq	.+20     	; 0x4be4 <malloc+0xa0>
    4bd0:	42 17       	cp	r20, r18
    4bd2:	53 07       	cpc	r21, r19
    4bd4:	38 f0       	brcs	.+14     	; 0x4be4 <malloc+0xa0>
    4bd6:	a9 01       	movw	r20, r18
    4bd8:	db 01       	movw	r26, r22
    4bda:	9a 01       	movw	r18, r20
    4bdc:	bd 01       	movw	r22, r26
    4bde:	df 01       	movw	r26, r30
    4be0:	f8 01       	movw	r30, r16
    4be2:	c1 cf       	rjmp	.-126    	; 0x4b66 <malloc+0x22>
    4be4:	ef 01       	movw	r28, r30
    4be6:	f9 cf       	rjmp	.-14     	; 0x4bda <malloc+0x96>
    4be8:	90 93 6a 03 	sts	0x036A, r25	; 0x80036a <__flp+0x1>
    4bec:	80 93 69 03 	sts	0x0369, r24	; 0x800369 <__flp>
    4bf0:	cd cf       	rjmp	.-102    	; 0x4b8c <malloc+0x48>
    4bf2:	fe 01       	movw	r30, r28
    4bf4:	e2 0f       	add	r30, r18
    4bf6:	f3 1f       	adc	r31, r19
    4bf8:	81 93       	st	Z+, r24
    4bfa:	91 93       	st	Z+, r25
    4bfc:	22 50       	subi	r18, 0x02	; 2
    4bfe:	31 09       	sbc	r19, r1
    4c00:	39 83       	std	Y+1, r19	; 0x01
    4c02:	28 83       	st	Y, r18
    4c04:	d7 cf       	rjmp	.-82     	; 0x4bb4 <malloc+0x70>
    4c06:	20 91 67 03 	lds	r18, 0x0367	; 0x800367 <__brkval>
    4c0a:	30 91 68 03 	lds	r19, 0x0368	; 0x800368 <__brkval+0x1>
    4c0e:	23 2b       	or	r18, r19
    4c10:	41 f4       	brne	.+16     	; 0x4c22 <malloc+0xde>
    4c12:	20 91 7c 00 	lds	r18, 0x007C	; 0x80007c <__malloc_heap_start>
    4c16:	30 91 7d 00 	lds	r19, 0x007D	; 0x80007d <__malloc_heap_start+0x1>
    4c1a:	30 93 68 03 	sts	0x0368, r19	; 0x800368 <__brkval+0x1>
    4c1e:	20 93 67 03 	sts	0x0367, r18	; 0x800367 <__brkval>
    4c22:	20 91 7a 00 	lds	r18, 0x007A	; 0x80007a <__malloc_heap_end>
    4c26:	30 91 7b 00 	lds	r19, 0x007B	; 0x80007b <__malloc_heap_end+0x1>
    4c2a:	21 15       	cp	r18, r1
    4c2c:	31 05       	cpc	r19, r1
    4c2e:	41 f4       	brne	.+16     	; 0x4c40 <malloc+0xfc>
    4c30:	2d b7       	in	r18, 0x3d	; 61
    4c32:	3e b7       	in	r19, 0x3e	; 62
    4c34:	40 91 7e 00 	lds	r20, 0x007E	; 0x80007e <__malloc_margin>
    4c38:	50 91 7f 00 	lds	r21, 0x007F	; 0x80007f <__malloc_margin+0x1>
    4c3c:	24 1b       	sub	r18, r20
    4c3e:	35 0b       	sbc	r19, r21
    4c40:	e0 91 67 03 	lds	r30, 0x0367	; 0x800367 <__brkval>
    4c44:	f0 91 68 03 	lds	r31, 0x0368	; 0x800368 <__brkval+0x1>
    4c48:	e2 17       	cp	r30, r18
    4c4a:	f3 07       	cpc	r31, r19
    4c4c:	a0 f4       	brcc	.+40     	; 0x4c76 <malloc+0x132>
    4c4e:	2e 1b       	sub	r18, r30
    4c50:	3f 0b       	sbc	r19, r31
    4c52:	28 17       	cp	r18, r24
    4c54:	39 07       	cpc	r19, r25
    4c56:	78 f0       	brcs	.+30     	; 0x4c76 <malloc+0x132>
    4c58:	ac 01       	movw	r20, r24
    4c5a:	4e 5f       	subi	r20, 0xFE	; 254
    4c5c:	5f 4f       	sbci	r21, 0xFF	; 255
    4c5e:	24 17       	cp	r18, r20
    4c60:	35 07       	cpc	r19, r21
    4c62:	48 f0       	brcs	.+18     	; 0x4c76 <malloc+0x132>
    4c64:	4e 0f       	add	r20, r30
    4c66:	5f 1f       	adc	r21, r31
    4c68:	50 93 68 03 	sts	0x0368, r21	; 0x800368 <__brkval+0x1>
    4c6c:	40 93 67 03 	sts	0x0367, r20	; 0x800367 <__brkval>
    4c70:	81 93       	st	Z+, r24
    4c72:	91 93       	st	Z+, r25
    4c74:	9f cf       	rjmp	.-194    	; 0x4bb4 <malloc+0x70>
    4c76:	f0 e0       	ldi	r31, 0x00	; 0
    4c78:	e0 e0       	ldi	r30, 0x00	; 0
    4c7a:	9c cf       	rjmp	.-200    	; 0x4bb4 <malloc+0x70>

00004c7c <free>:
free():
    4c7c:	cf 93       	push	r28
    4c7e:	df 93       	push	r29
    4c80:	00 97       	sbiw	r24, 0x00	; 0
    4c82:	e9 f0       	breq	.+58     	; 0x4cbe <free+0x42>
    4c84:	fc 01       	movw	r30, r24
    4c86:	32 97       	sbiw	r30, 0x02	; 2
    4c88:	13 82       	std	Z+3, r1	; 0x03
    4c8a:	12 82       	std	Z+2, r1	; 0x02
    4c8c:	a0 91 69 03 	lds	r26, 0x0369	; 0x800369 <__flp>
    4c90:	b0 91 6a 03 	lds	r27, 0x036A	; 0x80036a <__flp+0x1>
    4c94:	ed 01       	movw	r28, r26
    4c96:	30 e0       	ldi	r19, 0x00	; 0
    4c98:	20 e0       	ldi	r18, 0x00	; 0
    4c9a:	10 97       	sbiw	r26, 0x00	; 0
    4c9c:	a1 f4       	brne	.+40     	; 0x4cc6 <free+0x4a>
    4c9e:	20 81       	ld	r18, Z
    4ca0:	31 81       	ldd	r19, Z+1	; 0x01
    4ca2:	82 0f       	add	r24, r18
    4ca4:	93 1f       	adc	r25, r19
    4ca6:	20 91 67 03 	lds	r18, 0x0367	; 0x800367 <__brkval>
    4caa:	30 91 68 03 	lds	r19, 0x0368	; 0x800368 <__brkval+0x1>
    4cae:	28 17       	cp	r18, r24
    4cb0:	39 07       	cpc	r19, r25
    4cb2:	09 f0       	breq	.+2      	; 0x4cb6 <free+0x3a>
    4cb4:	61 c0       	rjmp	.+194    	; 0x4d78 <free+0xfc>
    4cb6:	f0 93 68 03 	sts	0x0368, r31	; 0x800368 <__brkval+0x1>
    4cba:	e0 93 67 03 	sts	0x0367, r30	; 0x800367 <__brkval>
    4cbe:	df 91       	pop	r29
    4cc0:	cf 91       	pop	r28
    4cc2:	08 95       	ret
    4cc4:	ea 01       	movw	r28, r20
    4cc6:	ce 17       	cp	r28, r30
    4cc8:	df 07       	cpc	r29, r31
    4cca:	e8 f5       	brcc	.+122    	; 0x4d46 <free+0xca>
    4ccc:	4a 81       	ldd	r20, Y+2	; 0x02
    4cce:	5b 81       	ldd	r21, Y+3	; 0x03
    4cd0:	9e 01       	movw	r18, r28
    4cd2:	41 15       	cp	r20, r1
    4cd4:	51 05       	cpc	r21, r1
    4cd6:	b1 f7       	brne	.-20     	; 0x4cc4 <free+0x48>
    4cd8:	e9 01       	movw	r28, r18
    4cda:	fb 83       	std	Y+3, r31	; 0x03
    4cdc:	ea 83       	std	Y+2, r30	; 0x02
    4cde:	49 91       	ld	r20, Y+
    4ce0:	59 91       	ld	r21, Y+
    4ce2:	c4 0f       	add	r28, r20
    4ce4:	d5 1f       	adc	r29, r21
    4ce6:	ec 17       	cp	r30, r28
    4ce8:	fd 07       	cpc	r31, r29
    4cea:	61 f4       	brne	.+24     	; 0x4d04 <free+0x88>
    4cec:	80 81       	ld	r24, Z
    4cee:	91 81       	ldd	r25, Z+1	; 0x01
    4cf0:	02 96       	adiw	r24, 0x02	; 2
    4cf2:	84 0f       	add	r24, r20
    4cf4:	95 1f       	adc	r25, r21
    4cf6:	e9 01       	movw	r28, r18
    4cf8:	99 83       	std	Y+1, r25	; 0x01
    4cfa:	88 83       	st	Y, r24
    4cfc:	82 81       	ldd	r24, Z+2	; 0x02
    4cfe:	93 81       	ldd	r25, Z+3	; 0x03
    4d00:	9b 83       	std	Y+3, r25	; 0x03
    4d02:	8a 83       	std	Y+2, r24	; 0x02
    4d04:	f0 e0       	ldi	r31, 0x00	; 0
    4d06:	e0 e0       	ldi	r30, 0x00	; 0
    4d08:	12 96       	adiw	r26, 0x02	; 2
    4d0a:	8d 91       	ld	r24, X+
    4d0c:	9c 91       	ld	r25, X
    4d0e:	13 97       	sbiw	r26, 0x03	; 3
    4d10:	00 97       	sbiw	r24, 0x00	; 0
    4d12:	b9 f5       	brne	.+110    	; 0x4d82 <free+0x106>
    4d14:	2d 91       	ld	r18, X+
    4d16:	3c 91       	ld	r19, X
    4d18:	11 97       	sbiw	r26, 0x01	; 1
    4d1a:	cd 01       	movw	r24, r26
    4d1c:	02 96       	adiw	r24, 0x02	; 2
    4d1e:	82 0f       	add	r24, r18
    4d20:	93 1f       	adc	r25, r19
    4d22:	20 91 67 03 	lds	r18, 0x0367	; 0x800367 <__brkval>
    4d26:	30 91 68 03 	lds	r19, 0x0368	; 0x800368 <__brkval+0x1>
    4d2a:	28 17       	cp	r18, r24
    4d2c:	39 07       	cpc	r19, r25
    4d2e:	39 f6       	brne	.-114    	; 0x4cbe <free+0x42>
    4d30:	30 97       	sbiw	r30, 0x00	; 0
    4d32:	51 f5       	brne	.+84     	; 0x4d88 <free+0x10c>
    4d34:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <__flp+0x1>
    4d38:	10 92 69 03 	sts	0x0369, r1	; 0x800369 <__flp>
    4d3c:	b0 93 68 03 	sts	0x0368, r27	; 0x800368 <__brkval+0x1>
    4d40:	a0 93 67 03 	sts	0x0367, r26	; 0x800367 <__brkval>
    4d44:	bc cf       	rjmp	.-136    	; 0x4cbe <free+0x42>
    4d46:	d3 83       	std	Z+3, r29	; 0x03
    4d48:	c2 83       	std	Z+2, r28	; 0x02
    4d4a:	40 81       	ld	r20, Z
    4d4c:	51 81       	ldd	r21, Z+1	; 0x01
    4d4e:	84 0f       	add	r24, r20
    4d50:	95 1f       	adc	r25, r21
    4d52:	c8 17       	cp	r28, r24
    4d54:	d9 07       	cpc	r29, r25
    4d56:	61 f4       	brne	.+24     	; 0x4d70 <free+0xf4>
    4d58:	4e 5f       	subi	r20, 0xFE	; 254
    4d5a:	5f 4f       	sbci	r21, 0xFF	; 255
    4d5c:	88 81       	ld	r24, Y
    4d5e:	99 81       	ldd	r25, Y+1	; 0x01
    4d60:	48 0f       	add	r20, r24
    4d62:	59 1f       	adc	r21, r25
    4d64:	51 83       	std	Z+1, r21	; 0x01
    4d66:	40 83       	st	Z, r20
    4d68:	8a 81       	ldd	r24, Y+2	; 0x02
    4d6a:	9b 81       	ldd	r25, Y+3	; 0x03
    4d6c:	93 83       	std	Z+3, r25	; 0x03
    4d6e:	82 83       	std	Z+2, r24	; 0x02
    4d70:	21 15       	cp	r18, r1
    4d72:	31 05       	cpc	r19, r1
    4d74:	09 f0       	breq	.+2      	; 0x4d78 <free+0xfc>
    4d76:	b0 cf       	rjmp	.-160    	; 0x4cd8 <free+0x5c>
    4d78:	f0 93 6a 03 	sts	0x036A, r31	; 0x80036a <__flp+0x1>
    4d7c:	e0 93 69 03 	sts	0x0369, r30	; 0x800369 <__flp>
    4d80:	9e cf       	rjmp	.-196    	; 0x4cbe <free+0x42>
    4d82:	fd 01       	movw	r30, r26
    4d84:	dc 01       	movw	r26, r24
    4d86:	c0 cf       	rjmp	.-128    	; 0x4d08 <free+0x8c>
    4d88:	13 82       	std	Z+3, r1	; 0x03
    4d8a:	12 82       	std	Z+2, r1	; 0x02
    4d8c:	d7 cf       	rjmp	.-82     	; 0x4d3c <free+0xc0>

00004d8e <realloc>:
realloc():
    4d8e:	b0 e0       	ldi	r27, 0x00	; 0
    4d90:	a0 e0       	ldi	r26, 0x00	; 0
    4d92:	ed ec       	ldi	r30, 0xCD	; 205
    4d94:	f6 e2       	ldi	r31, 0x26	; 38
    4d96:	0c 94 2a 25 	jmp	0x4a54	; 0x4a54 <__prologue_saves__+0x4>
    4d9a:	8c 01       	movw	r16, r24
    4d9c:	00 97       	sbiw	r24, 0x00	; 0
    4d9e:	51 f4       	brne	.+20     	; 0x4db4 <realloc+0x26>
    4da0:	cb 01       	movw	r24, r22
    4da2:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <malloc>
    4da6:	8c 01       	movw	r16, r24
    4da8:	c8 01       	movw	r24, r16
    4daa:	cd b7       	in	r28, 0x3d	; 61
    4dac:	de b7       	in	r29, 0x3e	; 62
    4dae:	e0 e1       	ldi	r30, 0x10	; 16
    4db0:	0c 94 46 25 	jmp	0x4a8c	; 0x4a8c <__epilogue_restores__+0x4>
    4db4:	fc 01       	movw	r30, r24
    4db6:	e6 0f       	add	r30, r22
    4db8:	f7 1f       	adc	r31, r23
    4dba:	9c 01       	movw	r18, r24
    4dbc:	22 50       	subi	r18, 0x02	; 2
    4dbe:	31 09       	sbc	r19, r1
    4dc0:	e2 17       	cp	r30, r18
    4dc2:	f3 07       	cpc	r31, r19
    4dc4:	08 f4       	brcc	.+2      	; 0x4dc8 <realloc+0x3a>
    4dc6:	9d c0       	rjmp	.+314    	; 0x4f02 <realloc+0x174>
    4dc8:	d9 01       	movw	r26, r18
    4dca:	cd 91       	ld	r28, X+
    4dcc:	dc 91       	ld	r29, X
    4dce:	11 97       	sbiw	r26, 0x01	; 1
    4dd0:	c6 17       	cp	r28, r22
    4dd2:	d7 07       	cpc	r29, r23
    4dd4:	98 f0       	brcs	.+38     	; 0x4dfc <realloc+0x6e>
    4dd6:	c5 30       	cpi	r28, 0x05	; 5
    4dd8:	d1 05       	cpc	r29, r1
    4dda:	30 f3       	brcs	.-52     	; 0x4da8 <realloc+0x1a>
    4ddc:	ce 01       	movw	r24, r28
    4dde:	04 97       	sbiw	r24, 0x04	; 4
    4de0:	86 17       	cp	r24, r22
    4de2:	97 07       	cpc	r25, r23
    4de4:	08 f3       	brcs	.-62     	; 0x4da8 <realloc+0x1a>
    4de6:	c6 1b       	sub	r28, r22
    4de8:	d7 0b       	sbc	r29, r23
    4dea:	22 97       	sbiw	r28, 0x02	; 2
    4dec:	c1 93       	st	Z+, r28
    4dee:	d1 93       	st	Z+, r29
    4df0:	6d 93       	st	X+, r22
    4df2:	7c 93       	st	X, r23
    4df4:	cf 01       	movw	r24, r30
    4df6:	0e 94 3e 26 	call	0x4c7c	; 0x4c7c <free>
    4dfa:	d6 cf       	rjmp	.-84     	; 0x4da8 <realloc+0x1a>
    4dfc:	5b 01       	movw	r10, r22
    4dfe:	ac 1a       	sub	r10, r28
    4e00:	bd 0a       	sbc	r11, r29
    4e02:	4c 01       	movw	r8, r24
    4e04:	8c 0e       	add	r8, r28
    4e06:	9d 1e       	adc	r9, r29
    4e08:	a0 91 69 03 	lds	r26, 0x0369	; 0x800369 <__flp>
    4e0c:	b0 91 6a 03 	lds	r27, 0x036A	; 0x80036a <__flp+0x1>
    4e10:	51 2c       	mov	r5, r1
    4e12:	41 2c       	mov	r4, r1
    4e14:	f1 2c       	mov	r15, r1
    4e16:	e1 2c       	mov	r14, r1
    4e18:	10 97       	sbiw	r26, 0x00	; 0
    4e1a:	31 f5       	brne	.+76     	; 0x4e68 <realloc+0xda>
    4e1c:	80 91 67 03 	lds	r24, 0x0367	; 0x800367 <__brkval>
    4e20:	90 91 68 03 	lds	r25, 0x0368	; 0x800368 <__brkval+0x1>
    4e24:	88 15       	cp	r24, r8
    4e26:	99 05       	cpc	r25, r9
    4e28:	09 f0       	breq	.+2      	; 0x4e2c <realloc+0x9e>
    4e2a:	5c c0       	rjmp	.+184    	; 0x4ee4 <realloc+0x156>
    4e2c:	46 16       	cp	r4, r22
    4e2e:	57 06       	cpc	r5, r23
    4e30:	08 f0       	brcs	.+2      	; 0x4e34 <realloc+0xa6>
    4e32:	58 c0       	rjmp	.+176    	; 0x4ee4 <realloc+0x156>
    4e34:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__malloc_heap_end>
    4e38:	90 91 7b 00 	lds	r25, 0x007B	; 0x80007b <__malloc_heap_end+0x1>
    4e3c:	00 97       	sbiw	r24, 0x00	; 0
    4e3e:	41 f4       	brne	.+16     	; 0x4e50 <realloc+0xc2>
    4e40:	8d b7       	in	r24, 0x3d	; 61
    4e42:	9e b7       	in	r25, 0x3e	; 62
    4e44:	40 91 7e 00 	lds	r20, 0x007E	; 0x80007e <__malloc_margin>
    4e48:	50 91 7f 00 	lds	r21, 0x007F	; 0x80007f <__malloc_margin+0x1>
    4e4c:	84 1b       	sub	r24, r20
    4e4e:	95 0b       	sbc	r25, r21
    4e50:	e8 17       	cp	r30, r24
    4e52:	f9 07       	cpc	r31, r25
    4e54:	08 f0       	brcs	.+2      	; 0x4e58 <realloc+0xca>
    4e56:	55 c0       	rjmp	.+170    	; 0x4f02 <realloc+0x174>
    4e58:	f0 93 68 03 	sts	0x0368, r31	; 0x800368 <__brkval+0x1>
    4e5c:	e0 93 67 03 	sts	0x0367, r30	; 0x800367 <__brkval>
    4e60:	f9 01       	movw	r30, r18
    4e62:	71 83       	std	Z+1, r23	; 0x01
    4e64:	60 83       	st	Z, r22
    4e66:	a0 cf       	rjmp	.-192    	; 0x4da8 <realloc+0x1a>
    4e68:	8d 91       	ld	r24, X+
    4e6a:	9c 91       	ld	r25, X
    4e6c:	11 97       	sbiw	r26, 0x01	; 1
    4e6e:	12 96       	adiw	r26, 0x02	; 2
    4e70:	6c 90       	ld	r6, X
    4e72:	12 97       	sbiw	r26, 0x02	; 2
    4e74:	13 96       	adiw	r26, 0x03	; 3
    4e76:	7c 90       	ld	r7, X
    4e78:	13 97       	sbiw	r26, 0x03	; 3
    4e7a:	a8 15       	cp	r26, r8
    4e7c:	b9 05       	cpc	r27, r9
    4e7e:	59 f5       	brne	.+86     	; 0x4ed6 <realloc+0x148>
    4e80:	6c 01       	movw	r12, r24
    4e82:	42 e0       	ldi	r20, 0x02	; 2
    4e84:	c4 0e       	add	r12, r20
    4e86:	d1 1c       	adc	r13, r1
    4e88:	ca 14       	cp	r12, r10
    4e8a:	db 04       	cpc	r13, r11
    4e8c:	20 f1       	brcs	.+72     	; 0x4ed6 <realloc+0x148>
    4e8e:	ac 01       	movw	r20, r24
    4e90:	4a 19       	sub	r20, r10
    4e92:	5b 09       	sbc	r21, r11
    4e94:	da 01       	movw	r26, r20
    4e96:	12 96       	adiw	r26, 0x02	; 2
    4e98:	15 97       	sbiw	r26, 0x05	; 5
    4e9a:	80 f0       	brcs	.+32     	; 0x4ebc <realloc+0x12e>
    4e9c:	62 82       	std	Z+2, r6	; 0x02
    4e9e:	73 82       	std	Z+3, r7	; 0x03
    4ea0:	51 83       	std	Z+1, r21	; 0x01
    4ea2:	40 83       	st	Z, r20
    4ea4:	d9 01       	movw	r26, r18
    4ea6:	6d 93       	st	X+, r22
    4ea8:	7c 93       	st	X, r23
    4eaa:	e1 14       	cp	r14, r1
    4eac:	f1 04       	cpc	r15, r1
    4eae:	71 f0       	breq	.+28     	; 0x4ecc <realloc+0x13e>
    4eb0:	d7 01       	movw	r26, r14
    4eb2:	13 96       	adiw	r26, 0x03	; 3
    4eb4:	fc 93       	st	X, r31
    4eb6:	ee 93       	st	-X, r30
    4eb8:	12 97       	sbiw	r26, 0x02	; 2
    4eba:	76 cf       	rjmp	.-276    	; 0x4da8 <realloc+0x1a>
    4ebc:	22 96       	adiw	r28, 0x02	; 2
    4ebe:	8c 0f       	add	r24, r28
    4ec0:	9d 1f       	adc	r25, r29
    4ec2:	f9 01       	movw	r30, r18
    4ec4:	91 83       	std	Z+1, r25	; 0x01
    4ec6:	80 83       	st	Z, r24
    4ec8:	f3 01       	movw	r30, r6
    4eca:	ef cf       	rjmp	.-34     	; 0x4eaa <realloc+0x11c>
    4ecc:	f0 93 6a 03 	sts	0x036A, r31	; 0x80036a <__flp+0x1>
    4ed0:	e0 93 69 03 	sts	0x0369, r30	; 0x800369 <__flp>
    4ed4:	69 cf       	rjmp	.-302    	; 0x4da8 <realloc+0x1a>
    4ed6:	48 16       	cp	r4, r24
    4ed8:	59 06       	cpc	r5, r25
    4eda:	08 f4       	brcc	.+2      	; 0x4ede <realloc+0x150>
    4edc:	2c 01       	movw	r4, r24
    4ede:	7d 01       	movw	r14, r26
    4ee0:	d3 01       	movw	r26, r6
    4ee2:	9a cf       	rjmp	.-204    	; 0x4e18 <realloc+0x8a>
    4ee4:	cb 01       	movw	r24, r22
    4ee6:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <malloc>
    4eea:	7c 01       	movw	r14, r24
    4eec:	00 97       	sbiw	r24, 0x00	; 0
    4eee:	49 f0       	breq	.+18     	; 0x4f02 <realloc+0x174>
    4ef0:	ae 01       	movw	r20, r28
    4ef2:	b8 01       	movw	r22, r16
    4ef4:	0e 94 84 27 	call	0x4f08	; 0x4f08 <memcpy>
    4ef8:	c8 01       	movw	r24, r16
    4efa:	0e 94 3e 26 	call	0x4c7c	; 0x4c7c <free>
    4efe:	87 01       	movw	r16, r14
    4f00:	53 cf       	rjmp	.-346    	; 0x4da8 <realloc+0x1a>
    4f02:	10 e0       	ldi	r17, 0x00	; 0
    4f04:	00 e0       	ldi	r16, 0x00	; 0
    4f06:	50 cf       	rjmp	.-352    	; 0x4da8 <realloc+0x1a>

00004f08 <memcpy>:
memcpy():
    4f08:	fb 01       	movw	r30, r22
    4f0a:	dc 01       	movw	r26, r24
    4f0c:	02 c0       	rjmp	.+4      	; 0x4f12 <memcpy+0xa>
    4f0e:	01 90       	ld	r0, Z+
    4f10:	0d 92       	st	X+, r0
    4f12:	41 50       	subi	r20, 0x01	; 1
    4f14:	50 40       	sbci	r21, 0x00	; 0
    4f16:	d8 f7       	brcc	.-10     	; 0x4f0e <memcpy+0x6>
    4f18:	08 95       	ret

00004f1a <strcpy>:
strcpy():
    4f1a:	fb 01       	movw	r30, r22
    4f1c:	dc 01       	movw	r26, r24
    4f1e:	01 90       	ld	r0, Z+
    4f20:	0d 92       	st	X+, r0
    4f22:	00 20       	and	r0, r0
    4f24:	e1 f7       	brne	.-8      	; 0x4f1e <strcpy+0x4>
    4f26:	08 95       	ret

00004f28 <__do_global_dtors>:
__do_global_dtors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2496
    4f28:	14 e0       	ldi	r17, 0x04	; 4
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2497
    4f2a:	ca e1       	ldi	r28, 0x1A	; 26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2498
    4f2c:	d4 e0       	ldi	r29, 0x04	; 4
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2502
    4f2e:	04 c0       	rjmp	.+8      	; 0x4f38 <__do_global_dtors+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2508
    4f30:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2509
    4f32:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2510
    4f36:	21 96       	adiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2515
    4f38:	cb 31       	cpi	r28, 0x1B	; 27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2516
    4f3a:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2521
    4f3c:	c9 f7       	brne	.-14     	; 0x4f30 <__do_global_dtors+0x8>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    4f3e:	f8 94       	cli

00004f40 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    4f40:	ff cf       	rjmp	.-2      	; 0x4f40 <__stop_program>
